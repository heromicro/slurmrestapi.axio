/* tslint:disable */
/* eslint-disable */
/**
 * Slurm REST API
 * API to access and control Slurm
 *
 * The version of the OpenAPI document: Slurm-24.05.5&openapi/dbv0.0.39&openapi/slurmctld&openapi/slurmdbd&openapi/v0.0.39
 * Contact: sales@schedmd.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Dbv0039AccountInfo
 */
export interface Dbv0039AccountInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039AccountInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039AccountInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039AccountInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039Account>}
     * @memberof Dbv0039AccountInfo
     */
    'accounts'?: Array<V0039Account>;
}
/**
 * 
 * @export
 * @interface Dbv0039AssociationsInfo
 */
export interface Dbv0039AssociationsInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039AssociationsInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039AssociationsInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039AssociationsInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039Assoc>}
     * @memberof Dbv0039AssociationsInfo
     */
    'associations'?: Array<V0039Assoc>;
}
/**
 * 
 * @export
 * @interface Dbv0039ClustersInfo
 */
export interface Dbv0039ClustersInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039ClustersInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039ClustersInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039ClustersInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039ClusterRec>}
     * @memberof Dbv0039ClustersInfo
     */
    'clusters'?: Array<V0039ClusterRec>;
}
/**
 * 
 * @export
 * @interface Dbv0039ConfigInfo
 */
export interface Dbv0039ConfigInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039ConfigInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039ConfigInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039ConfigInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof Dbv0039ConfigInfo
     */
    'tres'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Account>}
     * @memberof Dbv0039ConfigInfo
     */
    'accounts'?: Array<V0039Account>;
    /**
     * 
     * @type {Array<V0039Assoc>}
     * @memberof Dbv0039ConfigInfo
     */
    'associations'?: Array<V0039Assoc>;
    /**
     * 
     * @type {Array<V0039User>}
     * @memberof Dbv0039ConfigInfo
     */
    'users'?: Array<V0039User>;
    /**
     * 
     * @type {Array<V0039Qos>}
     * @memberof Dbv0039ConfigInfo
     */
    'qos'?: Array<V0039Qos>;
    /**
     * 
     * @type {Array<V0039Wckey>}
     * @memberof Dbv0039ConfigInfo
     */
    'wckeys'?: Array<V0039Wckey>;
    /**
     * 
     * @type {Array<V0039ClusterRec>}
     * @memberof Dbv0039ConfigInfo
     */
    'clusters'?: Array<V0039ClusterRec>;
}
/**
 * 
 * @export
 * @interface Dbv0039Diag
 */
export interface Dbv0039Diag {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039Diag
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039Diag
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039Diag
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {V0039StatsRec}
     * @memberof Dbv0039Diag
     */
    'statistics'?: V0039StatsRec;
}
/**
 * 
 * @export
 * @interface Dbv0039Error
 */
export interface Dbv0039Error {
    /**
     * Slurm internal error number
     * @type {number}
     * @memberof Dbv0039Error
     */
    'error_number'?: number;
    /**
     * Error message
     * @type {string}
     * @memberof Dbv0039Error
     */
    'error'?: string;
    /**
     * Where error occurred in the source
     * @type {string}
     * @memberof Dbv0039Error
     */
    'source'?: string;
    /**
     * Explanation of cause of error
     * @type {string}
     * @memberof Dbv0039Error
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Dbv0039JobInfo
 */
export interface Dbv0039JobInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039JobInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039JobInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039JobInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039Job>}
     * @memberof Dbv0039JobInfo
     */
    'jobs'?: Array<V0039Job>;
}
/**
 * 
 * @export
 * @interface Dbv0039Meta
 */
export interface Dbv0039Meta {
    /**
     * 
     * @type {Dbv0039MetaPlugin}
     * @memberof Dbv0039Meta
     */
    'plugin'?: Dbv0039MetaPlugin;
    /**
     * 
     * @type {Dbv0039MetaSlurm}
     * @memberof Dbv0039Meta
     */
    'Slurm'?: Dbv0039MetaSlurm;
}
/**
 * 
 * @export
 * @interface Dbv0039MetaPlugin
 */
export interface Dbv0039MetaPlugin {
    /**
     * 
     * @type {string}
     * @memberof Dbv0039MetaPlugin
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Dbv0039MetaPlugin
     */
    'name'?: string;
}
/**
 * Slurm information
 * @export
 * @interface Dbv0039MetaSlurm
 */
export interface Dbv0039MetaSlurm {
    /**
     * 
     * @type {Dbv0039MetaSlurmVersion}
     * @memberof Dbv0039MetaSlurm
     */
    'version'?: Dbv0039MetaSlurmVersion;
    /**
     * version specifier
     * @type {string}
     * @memberof Dbv0039MetaSlurm
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface Dbv0039MetaSlurmVersion
 */
export interface Dbv0039MetaSlurmVersion {
    /**
     * 
     * @type {number}
     * @memberof Dbv0039MetaSlurmVersion
     */
    'major'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dbv0039MetaSlurmVersion
     */
    'micro'?: number;
    /**
     * 
     * @type {number}
     * @memberof Dbv0039MetaSlurmVersion
     */
    'minor'?: number;
}
/**
 * 
 * @export
 * @interface Dbv0039QosInfo
 */
export interface Dbv0039QosInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039QosInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039QosInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039QosInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * 
     * @type {Array<V0039Qos>}
     * @memberof Dbv0039QosInfo
     */
    'qos'?: Array<V0039Qos>;
}
/**
 * 
 * @export
 * @interface Dbv0039ResponseAssociationsDelete
 */
export interface Dbv0039ResponseAssociationsDelete {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039ResponseAssociationsDelete
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039ResponseAssociationsDelete
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039ResponseAssociationsDelete
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * the associations
     * @type {Array<string>}
     * @memberof Dbv0039ResponseAssociationsDelete
     */
    'removed_associations'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Dbv0039SetConfig
 */
export interface Dbv0039SetConfig {
    /**
     * 
     * @type {Array<V0039ClusterRec>}
     * @memberof Dbv0039SetConfig
     */
    'clusters'?: Array<V0039ClusterRec>;
    /**
     * 
     * @type {Array<Array<V0039Tres>>}
     * @memberof Dbv0039SetConfig
     */
    'TRES'?: Array<Array<V0039Tres>>;
    /**
     * 
     * @type {Array<V0039Account>}
     * @memberof Dbv0039SetConfig
     */
    'accounts'?: Array<V0039Account>;
    /**
     * 
     * @type {Array<V0039User>}
     * @memberof Dbv0039SetConfig
     */
    'users'?: Array<V0039User>;
    /**
     * 
     * @type {Array<V0039Qos>}
     * @memberof Dbv0039SetConfig
     */
    'qos'?: Array<V0039Qos>;
    /**
     * 
     * @type {Array<V0039Wckey>}
     * @memberof Dbv0039SetConfig
     */
    'wckeys'?: Array<V0039Wckey>;
    /**
     * 
     * @type {Array<V0039Assoc>}
     * @memberof Dbv0039SetConfig
     */
    'associations'?: Array<V0039Assoc>;
}
/**
 * 
 * @export
 * @interface Dbv0039TresInfo
 */
export interface Dbv0039TresInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039TresInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039TresInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039TresInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof Dbv0039TresInfo
     */
    'tres'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface Dbv0039TresUpdate
 */
export interface Dbv0039TresUpdate {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof Dbv0039TresUpdate
     */
    'tres'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface Dbv0039UpdateQos
 */
export interface Dbv0039UpdateQos {
    /**
     * 
     * @type {Array<V0039Qos>}
     * @memberof Dbv0039UpdateQos
     */
    'qos'?: Array<V0039Qos>;
}
/**
 * 
 * @export
 * @interface Dbv0039UpdateUsers
 */
export interface Dbv0039UpdateUsers {
    /**
     * 
     * @type {Array<V0039User>}
     * @memberof Dbv0039UpdateUsers
     */
    'users'?: Array<V0039User>;
}
/**
 * 
 * @export
 * @interface Dbv0039UserInfo
 */
export interface Dbv0039UserInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039UserInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039UserInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * Slurm warnings
     * @type {Array<Dbv0039Warning>}
     * @memberof Dbv0039UserInfo
     */
    'warnings'?: Array<Dbv0039Warning>;
    /**
     * 
     * @type {Array<V0039User>}
     * @memberof Dbv0039UserInfo
     */
    'users'?: Array<V0039User>;
}
/**
 * 
 * @export
 * @interface Dbv0039Warning
 */
export interface Dbv0039Warning {
    /**
     * Earning message
     * @type {string}
     * @memberof Dbv0039Warning
     */
    'warning'?: string;
    /**
     * Where error occurred in the source
     * @type {string}
     * @memberof Dbv0039Warning
     */
    'source'?: string;
    /**
     * Explanation of cause of error
     * @type {string}
     * @memberof Dbv0039Warning
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Dbv0039WckeyInfo
 */
export interface Dbv0039WckeyInfo {
    /**
     * 
     * @type {Dbv0039Meta}
     * @memberof Dbv0039WckeyInfo
     */
    'meta'?: Dbv0039Meta;
    /**
     * Slurm errors
     * @type {Array<Dbv0039Error>}
     * @memberof Dbv0039WckeyInfo
     */
    'errors'?: Array<Dbv0039Error>;
    /**
     * 
     * @type {Array<V0039Wckey>}
     * @memberof Dbv0039WckeyInfo
     */
    'wckeys'?: Array<V0039Wckey>;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {V0039Meta}
     * @memberof Status
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof Status
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof Status
     */
    'warnings'?: Array<V0039Warning>;
}
/**
 * 
 * @export
 * @interface V0039Account
 */
export interface V0039Account {
    /**
     * 
     * @type {Array<V0039AssocShort>}
     * @memberof V0039Account
     */
    'associations'?: Array<V0039AssocShort>;
    /**
     * 
     * @type {Array<V0039Coord>}
     * @memberof V0039Account
     */
    'coordinators'?: Array<V0039Coord>;
    /**
     * 
     * @type {string}
     * @memberof V0039Account
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof V0039Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V0039Account
     */
    'organization': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Account
     */
    'flags'?: Array<V0039AccountFlagsEnum>;
}

export const V0039AccountFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0039AccountFlagsEnum = typeof V0039AccountFlagsEnum[keyof typeof V0039AccountFlagsEnum];

/**
 * 
 * @export
 * @interface V0039Accounting
 */
export interface V0039Accounting {
    /**
     * 
     * @type {V0039AccountingAllocated}
     * @memberof V0039Accounting
     */
    'allocated'?: V0039AccountingAllocated;
    /**
     * 
     * @type {number}
     * @memberof V0039Accounting
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Accounting
     */
    'start'?: number;
    /**
     * 
     * @type {V0039Tres}
     * @memberof V0039Accounting
     */
    'TRES'?: V0039Tres;
}
/**
 * 
 * @export
 * @interface V0039AccountingAllocated
 */
export interface V0039AccountingAllocated {
    /**
     * 
     * @type {number}
     * @memberof V0039AccountingAllocated
     */
    'seconds'?: number;
}
/**
 * 
 * @export
 * @interface V0039AcctGatherEnergy
 */
export interface V0039AcctGatherEnergy {
    /**
     * 
     * @type {number}
     * @memberof V0039AcctGatherEnergy
     */
    'average_watts'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AcctGatherEnergy
     */
    'base_consumed_energy'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AcctGatherEnergy
     */
    'consumed_energy'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AcctGatherEnergy
     */
    'current_watts'?: V0039Uint32NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039AcctGatherEnergy
     */
    'previous_consumed_energy'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AcctGatherEnergy
     */
    'last_collected'?: number;
}
/**
 * 
 * @export
 * @interface V0039Assoc
 */
export interface V0039Assoc {
    /**
     * 
     * @type {string}
     * @memberof V0039Assoc
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Assoc
     */
    'cluster'?: string;
    /**
     * 
     * @type {V0039AssocDefault}
     * @memberof V0039Assoc
     */
    'default'?: V0039AssocDefault;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Assoc
     */
    'flags'?: Array<V0039AssocFlagsEnum>;
    /**
     * 
     * @type {V0039AssocMax}
     * @memberof V0039Assoc
     */
    'max'?: V0039AssocMax;
    /**
     * 
     * @type {boolean}
     * @memberof V0039Assoc
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {V0039AssocMin}
     * @memberof V0039Assoc
     */
    'min'?: V0039AssocMin;
    /**
     * 
     * @type {string}
     * @memberof V0039Assoc
     */
    'parent_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Assoc
     */
    'partition'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039Assoc
     */
    'priority'?: V0039Uint32NoVal;
    /**
     * List of QOS names
     * @type {Array<string>}
     * @memberof V0039Assoc
     */
    'qos'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V0039Assoc
     */
    'shares_raw'?: number;
    /**
     * 
     * @type {V0039AssocUsage}
     * @memberof V0039Assoc
     */
    'usage'?: V0039AssocUsage;
    /**
     * 
     * @type {string}
     * @memberof V0039Assoc
     */
    'user': string;
}

export const V0039AssocFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0039AssocFlagsEnum = typeof V0039AssocFlagsEnum[keyof typeof V0039AssocFlagsEnum];

/**
 * 
 * @export
 * @interface V0039AssocDefault
 */
export interface V0039AssocDefault {
    /**
     * 
     * @type {string}
     * @memberof V0039AssocDefault
     */
    'qos'?: string;
}
/**
 * 
 * @export
 * @interface V0039AssocMax
 */
export interface V0039AssocMax {
    /**
     * 
     * @type {V0039AssocMaxJobs}
     * @memberof V0039AssocMax
     */
    'jobs'?: V0039AssocMaxJobs;
    /**
     * 
     * @type {V0039AssocMaxTres}
     * @memberof V0039AssocMax
     */
    'tres'?: V0039AssocMaxTres;
    /**
     * 
     * @type {V0039AssocMaxPer}
     * @memberof V0039AssocMax
     */
    'per'?: V0039AssocMaxPer;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxJobs
 */
export interface V0039AssocMaxJobs {
    /**
     * 
     * @type {V0039AssocMaxJobsPer}
     * @memberof V0039AssocMaxJobs
     */
    'per'?: V0039AssocMaxJobsPer;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobs
     */
    'active'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobs
     */
    'accruing'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobs
     */
    'total'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxJobsPer
 */
export interface V0039AssocMaxJobsPer {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobsPer
     */
    'count'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobsPer
     */
    'accruing'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobsPer
     */
    'submitted'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxJobsPer
     */
    'wall_clock'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxPer
 */
export interface V0039AssocMaxPer {
    /**
     * 
     * @type {V0039AssocMaxPerAccount}
     * @memberof V0039AssocMaxPer
     */
    'account'?: V0039AssocMaxPerAccount;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxPerAccount
 */
export interface V0039AssocMaxPerAccount {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMaxPerAccount
     */
    'wall_clock'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxTres
 */
export interface V0039AssocMaxTres {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTres
     */
    'total'?: Array<V0039Tres>;
    /**
     * 
     * @type {V0039AssocMaxTresMinutes}
     * @memberof V0039AssocMaxTres
     */
    'minutes'?: V0039AssocMaxTresMinutes;
    /**
     * 
     * @type {V0039AssocMaxTresGroup}
     * @memberof V0039AssocMaxTres
     */
    'group'?: V0039AssocMaxTresGroup;
    /**
     * 
     * @type {V0039AssocMaxTresPer}
     * @memberof V0039AssocMaxTres
     */
    'per'?: V0039AssocMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxTresGroup
 */
export interface V0039AssocMaxTresGroup {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresGroup
     */
    'minutes'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresGroup
     */
    'active'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxTresMinutes
 */
export interface V0039AssocMaxTresMinutes {
    /**
     * 
     * @type {V0039AssocMaxTresMinutesPer}
     * @memberof V0039AssocMaxTresMinutes
     */
    'per'?: V0039AssocMaxTresMinutesPer;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresMinutes
     */
    'total'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxTresMinutesPer
 */
export interface V0039AssocMaxTresMinutesPer {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresMinutesPer
     */
    'job'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039AssocMaxTresPer
 */
export interface V0039AssocMaxTresPer {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresPer
     */
    'job'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039AssocMaxTresPer
     */
    'node'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039AssocMin
 */
export interface V0039AssocMin {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039AssocMin
     */
    'priority_threshold'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039AssocShort
 */
export interface V0039AssocShort {
    /**
     * 
     * @type {string}
     * @memberof V0039AssocShort
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039AssocShort
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039AssocShort
     */
    'partition'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039AssocShort
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface V0039AssocUsage
 */
export interface V0039AssocUsage {
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'accrue_job_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'group_used_wallclock'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'fairshare_factor'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'fairshare_shares'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'normalized_priority'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'normalized_shares'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'effective_normalized_usage'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'normalized_usage'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'raw_usage'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'active_jobs'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'job_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039AssocUsage
     */
    'fairshare_level'?: number;
}
/**
 * 
 * @export
 * @interface V0039ClusterRec
 */
export interface V0039ClusterRec {
    /**
     * 
     * @type {V0039ClusterRecController}
     * @memberof V0039ClusterRec
     */
    'controller'?: V0039ClusterRecController;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039ClusterRec
     */
    'flags'?: Array<V0039ClusterRecFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039ClusterRec
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ClusterRec
     */
    'nodes'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ClusterRec
     */
    'select_plugin'?: string;
    /**
     * 
     * @type {V0039ClusterRecAssociations}
     * @memberof V0039ClusterRec
     */
    'associations'?: V0039ClusterRecAssociations;
    /**
     * 
     * @type {number}
     * @memberof V0039ClusterRec
     */
    'rpc_version'?: number;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039ClusterRec
     */
    'tres'?: Array<V0039Tres>;
}

export const V0039ClusterRecFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;

export type V0039ClusterRecFlagsEnum = typeof V0039ClusterRecFlagsEnum[keyof typeof V0039ClusterRecFlagsEnum];

/**
 * 
 * @export
 * @interface V0039ClusterRecAssociations
 */
export interface V0039ClusterRecAssociations {
    /**
     * 
     * @type {V0039AssocShort}
     * @memberof V0039ClusterRecAssociations
     */
    'root'?: V0039AssocShort;
}
/**
 * 
 * @export
 * @interface V0039ClusterRecController
 */
export interface V0039ClusterRecController {
    /**
     * 
     * @type {string}
     * @memberof V0039ClusterRecController
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039ClusterRecController
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface V0039ControllerPing
 */
export interface V0039ControllerPing {
    /**
     * 
     * @type {string}
     * @memberof V0039ControllerPing
     */
    'hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ControllerPing
     */
    'pinged'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039ControllerPing
     */
    'latency'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039ControllerPing
     */
    'mode'?: string;
}
/**
 * 
 * @export
 * @interface V0039Coord
 */
export interface V0039Coord {
    /**
     * 
     * @type {string}
     * @memberof V0039Coord
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039Coord
     */
    'direct'?: boolean;
}
/**
 * 
 * @export
 * @interface V0039CronEntry
 */
export interface V0039CronEntry {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039CronEntry
     */
    'flags'?: Array<V0039CronEntryFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'minute'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'hour'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'day_of_month'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'month'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'day_of_week'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'specification'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039CronEntry
     */
    'command'?: string;
    /**
     * 
     * @type {V0039CronEntryLine}
     * @memberof V0039CronEntry
     */
    'line'?: V0039CronEntryLine;
}

export const V0039CronEntryFlagsEnum = {
    Minute: 'WILD_MINUTE',
    Hour: 'WILD_HOUR',
    DayOfMonth: 'WILD_DAY_OF_MONTH',
    Month: 'WILD_MONTH',
    DayOfWeek: 'WILD_DAY_OF_WEEK'
} as const;

export type V0039CronEntryFlagsEnum = typeof V0039CronEntryFlagsEnum[keyof typeof V0039CronEntryFlagsEnum];

/**
 * 
 * @export
 * @interface V0039CronEntryLine
 */
export interface V0039CronEntryLine {
    /**
     * 
     * @type {number}
     * @memberof V0039CronEntryLine
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039CronEntryLine
     */
    'end'?: number;
}
/**
 * 
 * @export
 * @interface V0039Diag
 */
export interface V0039Diag {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039Diag
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039Diag
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039Diag
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {V0039StatsMsg}
     * @memberof V0039Diag
     */
    'statistics'?: V0039StatsMsg;
}
/**
 * 
 * @export
 * @interface V0039Error
 */
export interface V0039Error {
    /**
     * Slurm internal error number
     * @type {number}
     * @memberof V0039Error
     */
    'error_number'?: number;
    /**
     * Error message
     * @type {string}
     * @memberof V0039Error
     */
    'error'?: string;
    /**
     * Where error occurred in the source
     * @type {string}
     * @memberof V0039Error
     */
    'source'?: string;
    /**
     * Explanation of cause of error
     * @type {string}
     * @memberof V0039Error
     */
    'description'?: string;
}
/**
 * 64 bit floating point number with flags
 * @export
 * @interface V0039Float64NoVal
 */
export interface V0039Float64NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0039Float64NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0039Float64NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0039Float64NoVal
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0039Job
 */
export interface V0039Job {
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'account'?: string;
    /**
     * 
     * @type {V0039JobComment}
     * @memberof V0039Job
     */
    'comment'?: V0039JobComment;
    /**
     * 
     * @type {number}
     * @memberof V0039Job
     */
    'allocation_nodes'?: number;
    /**
     * 
     * @type {V0039JobArray}
     * @memberof V0039Job
     */
    'array'?: V0039JobArray;
    /**
     * 
     * @type {V0039AssocShort}
     * @memberof V0039Job
     */
    'association'?: V0039AssocShort;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'block'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'constraints'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'container'?: string;
    /**
     * 
     * @type {V0039JobExitCode}
     * @memberof V0039Job
     */
    'derived_exit_code'?: V0039JobExitCode;
    /**
     * 
     * @type {V0039JobTime}
     * @memberof V0039Job
     */
    'time'?: V0039JobTime;
    /**
     * 
     * @type {V0039JobExitCode}
     * @memberof V0039Job
     */
    'exit_code'?: V0039JobExitCode;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'extra'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'failed_node'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Job
     */
    'flags'?: Array<V0039JobFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'group'?: string;
    /**
     * 
     * @type {V0039JobHet}
     * @memberof V0039Job
     */
    'het'?: V0039JobHet;
    /**
     * 
     * @type {number}
     * @memberof V0039Job
     */
    'job_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'licenses'?: string;
    /**
     * 
     * @type {V0039JobMcs}
     * @memberof V0039Job
     */
    'mcs'?: V0039JobMcs;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'nodes'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'partition'?: string;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0039Job
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039Job
     */
    'priority'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'qos'?: string;
    /**
     * 
     * @type {V0039JobRequired}
     * @memberof V0039Job
     */
    'required'?: V0039JobRequired;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'kill_request_user'?: string;
    /**
     * 
     * @type {V0039JobReservation}
     * @memberof V0039Job
     */
    'reservation'?: V0039JobReservation;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'script'?: string;
    /**
     * 
     * @type {V0039JobState}
     * @memberof V0039Job
     */
    'state'?: V0039JobState;
    /**
     * 
     * @type {Array<V0039Step>}
     * @memberof V0039Job
     */
    'steps'?: Array<V0039Step>;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'submit_line'?: string;
    /**
     * 
     * @type {V0039JobTres}
     * @memberof V0039Job
     */
    'tres'?: V0039JobTres;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'used_gres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'user'?: string;
    /**
     * 
     * @type {V0039WckeyTag}
     * @memberof V0039Job
     */
    'wckey'?: V0039WckeyTag;
    /**
     * 
     * @type {string}
     * @memberof V0039Job
     */
    'working_directory'?: string;
}

export const V0039JobFlagsEnum = {
    None: 'NONE',
    ClearScheduling: 'CLEAR_SCHEDULING',
    NotSet: 'NOT_SET',
    StartedOnSubmit: 'STARTED_ON_SUBMIT',
    StartedOnSchedule: 'STARTED_ON_SCHEDULE',
    StartedOnBackfill: 'STARTED_ON_BACKFILL',
    StartReceived: 'START_RECEIVED'
} as const;

export type V0039JobFlagsEnum = typeof V0039JobFlagsEnum[keyof typeof V0039JobFlagsEnum];

/**
 * 
 * @export
 * @interface V0039JobArray
 */
export interface V0039JobArray {
    /**
     * 
     * @type {number}
     * @memberof V0039JobArray
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0039JobArrayLimits}
     * @memberof V0039JobArray
     */
    'limits'?: V0039JobArrayLimits;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobArray
     */
    'task_id'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobArray
     */
    'task'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobArrayLimits
 */
export interface V0039JobArrayLimits {
    /**
     * 
     * @type {V0039JobArrayLimitsMax}
     * @memberof V0039JobArrayLimits
     */
    'max'?: V0039JobArrayLimitsMax;
}
/**
 * 
 * @export
 * @interface V0039JobArrayLimitsMax
 */
export interface V0039JobArrayLimitsMax {
    /**
     * 
     * @type {V0039JobArrayLimitsMaxRunning}
     * @memberof V0039JobArrayLimitsMax
     */
    'running'?: V0039JobArrayLimitsMaxRunning;
}
/**
 * 
 * @export
 * @interface V0039JobArrayLimitsMaxRunning
 */
export interface V0039JobArrayLimitsMaxRunning {
    /**
     * 
     * @type {number}
     * @memberof V0039JobArrayLimitsMaxRunning
     */
    'tasks'?: number;
}
/**
 * ArrayJob
 * @export
 * @interface V0039JobArrayResponseMsgInner
 */
export interface V0039JobArrayResponseMsgInner {
    /**
     * JobId
     * @type {number}
     * @memberof V0039JobArrayResponseMsgInner
     */
    'job_id'?: number;
    /**
     * numeric error code
     * @type {number}
     * @memberof V0039JobArrayResponseMsgInner
     */
    'error_code'?: number;
    /**
     * error code description
     * @type {string}
     * @memberof V0039JobArrayResponseMsgInner
     */
    'error'?: string;
    /**
     * error message
     * @type {string}
     * @memberof V0039JobArrayResponseMsgInner
     */
    'why'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobComment
 */
export interface V0039JobComment {
    /**
     * 
     * @type {string}
     * @memberof V0039JobComment
     */
    'administrator'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobComment
     */
    'job'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobComment
     */
    'system'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobDescMsg
 */
export interface V0039JobDescMsg {
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'account_gather_frequency'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'admin_comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'allocation_node_list'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'allocation_node_port'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'argv'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'array'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'batch_features'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'begin_time'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'flags'?: Array<V0039JobDescMsgFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'burst_buffer'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'clusters'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'cluster_constraint'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'contiguous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'container_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'core_specification'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'thread_specification'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'cpu_binding'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'cpu_binding_flags'?: Array<V0039JobDescMsgCpuBindingFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'cpu_frequency'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'cpus_per_tres'?: string;
    /**
     * 
     * @type {V0039CronEntry}
     * @memberof V0039JobDescMsg
     */
    'crontab'?: V0039CronEntry;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'deadline'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'delay_boot'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'dependency'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'end_time'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'environment': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'excluded_nodes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'extra'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'constraints'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'group_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'hetjob_group'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'immediate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'job_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'kill_on_node_fail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'licenses'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'mail_type'?: Array<V0039JobDescMsgMailTypeEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'mail_user'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'mcs_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'memory_binding'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'memory_binding_type'?: Array<V0039JobDescMsgMemoryBindingTypeEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'memory_per_tres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'network'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'nice'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'tasks'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'open_mode'?: Array<V0039JobDescMsgOpenModeEnum>;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'reserve_ports'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'overcommit'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'partition'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'distribution_plane_size'?: number;
    /**
     * removed field
     * @type {Array<any>}
     * @memberof V0039JobDescMsg
     * @deprecated
     */
    'power_flags'?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'prefer'?: string;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobDescMsg
     */
    'priority'?: V0039Uint32NoVal;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'profile'?: Array<V0039JobDescMsgProfileEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'qos'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'reboot'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'required_nodes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'requeue'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'reservation'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'script'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'shared'?: Array<V0039JobDescMsgSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'exclusive'?: Array<V0039JobDescMsgExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'oversubscribe'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'site_factor'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'spank_environment'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'distribution'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobDescMsg
     */
    'time_limit'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobDescMsg
     */
    'time_minimum'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_bind'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_freq'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_per_job'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_per_node'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_per_socket'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'tres_per_task'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'user_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobDescMsg
     */
    'wait_all_nodes'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'kill_warning_flags'?: Array<V0039JobDescMsgKillWarningFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'kill_warning_signal'?: string;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobDescMsg
     */
    'kill_warning_delay'?: V0039Uint16NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'current_working_directory'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'cpus_per_task'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'minimum_cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'maximum_cpus'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'nodes'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'minimum_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'maximum_nodes'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'minimum_boards_per_node'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'minimum_sockets_per_board'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'sockets_per_node'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'threads_per_core'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'tasks_per_node'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'tasks_per_socket'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'tasks_per_core'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'tasks_per_board'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'ntasks_per_tres'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'minimum_cpus_per_node'?: number;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobDescMsg
     */
    'memory_per_cpu'?: V0039Uint64NoVal;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobDescMsg
     */
    'memory_per_node'?: V0039Uint64NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'temporary_disk_per_node'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'selinux_context'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobDescMsg
     */
    'required_switches'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'standard_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'standard_input'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'standard_output'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'wait_for_switch'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'wckey'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobDescMsg
     */
    'x11'?: Array<V0039JobDescMsgX11Enum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'x11_magic_cookie'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobDescMsg
     */
    'x11_target_host'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobDescMsg
     */
    'x11_target_port'?: number;
}

export const V0039JobDescMsgFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GredBindingDisabled: 'GRED_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    SaveBatchScript: 'SAVE_BATCH_SCRIPT'
} as const;

export type V0039JobDescMsgFlagsEnum = typeof V0039JobDescMsgFlagsEnum[keyof typeof V0039JobDescMsgFlagsEnum];
export const V0039JobDescMsgCpuBindingFlagsEnum = {
    CpuBindToThreads: 'CPU_BIND_TO_THREADS',
    CpuBindToCores: 'CPU_BIND_TO_CORES',
    CpuBindToSockets: 'CPU_BIND_TO_SOCKETS',
    CpuBindToLdoms: 'CPU_BIND_TO_LDOMS',
    CpuAutoBindToThreads: 'CPU_AUTO_BIND_TO_THREADS',
    CpuAutoBindToCores: 'CPU_AUTO_BIND_TO_CORES',
    CpuAutoBindToSockets: 'CPU_AUTO_BIND_TO_SOCKETS',
    CpuBindNone: 'CPU_BIND_NONE',
    CpuBindRank: 'CPU_BIND_RANK',
    CpuBindMap: 'CPU_BIND_MAP',
    CpuBindMask: 'CPU_BIND_MASK',
    CpuBindLdrank: 'CPU_BIND_LDRANK',
    CpuBindLdmap: 'CPU_BIND_LDMAP',
    CpuBindLdmask: 'CPU_BIND_LDMASK',
    Verbose: 'VERBOSE',
    CpuBindOneThreadPerCore: 'CPU_BIND_ONE_THREAD_PER_CORE',
    SlurmdOffSpec: 'SLURMD_OFF_SPEC',
    CpuBindOff: 'CPU_BIND_OFF'
} as const;

export type V0039JobDescMsgCpuBindingFlagsEnum = typeof V0039JobDescMsgCpuBindingFlagsEnum[keyof typeof V0039JobDescMsgCpuBindingFlagsEnum];
export const V0039JobDescMsgMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0039JobDescMsgMailTypeEnum = typeof V0039JobDescMsgMailTypeEnum[keyof typeof V0039JobDescMsgMailTypeEnum];
export const V0039JobDescMsgMemoryBindingTypeEnum = {
    None: 'NONE',
    Rank: 'RANK',
    Map: 'MAP',
    Mask: 'MASK',
    Local: 'LOCAL',
    Verbose: 'VERBOSE',
    Sort: 'SORT',
    Prefer: 'PREFER'
} as const;

export type V0039JobDescMsgMemoryBindingTypeEnum = typeof V0039JobDescMsgMemoryBindingTypeEnum[keyof typeof V0039JobDescMsgMemoryBindingTypeEnum];
export const V0039JobDescMsgOpenModeEnum = {
    Append: 'APPEND',
    Truncate: 'TRUNCATE'
} as const;

export type V0039JobDescMsgOpenModeEnum = typeof V0039JobDescMsgOpenModeEnum[keyof typeof V0039JobDescMsgOpenModeEnum];
export const V0039JobDescMsgProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0039JobDescMsgProfileEnum = typeof V0039JobDescMsgProfileEnum[keyof typeof V0039JobDescMsgProfileEnum];
export const V0039JobDescMsgSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0039JobDescMsgSharedEnum = typeof V0039JobDescMsgSharedEnum[keyof typeof V0039JobDescMsgSharedEnum];
export const V0039JobDescMsgExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0039JobDescMsgExclusiveEnum = typeof V0039JobDescMsgExclusiveEnum[keyof typeof V0039JobDescMsgExclusiveEnum];
export const V0039JobDescMsgKillWarningFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    WarningSent: 'WARNING_SENT'
} as const;

export type V0039JobDescMsgKillWarningFlagsEnum = typeof V0039JobDescMsgKillWarningFlagsEnum[keyof typeof V0039JobDescMsgKillWarningFlagsEnum];
export const V0039JobDescMsgX11Enum = {
    ForwardAllNodes: 'FORWARD_ALL_NODES',
    BatchNode: 'BATCH_NODE',
    FirstNode: 'FIRST_NODE',
    LastNode: 'LAST_NODE'
} as const;

export type V0039JobDescMsgX11Enum = typeof V0039JobDescMsgX11Enum[keyof typeof V0039JobDescMsgX11Enum];

/**
 * job exit details
 * @export
 * @interface V0039JobExitCode
 */
export interface V0039JobExitCode {
    /**
     * exit status
     * @type {string}
     * @memberof V0039JobExitCode
     */
    'status'?: string;
    /**
     * return code (numeric)
     * @type {number}
     * @memberof V0039JobExitCode
     */
    'return_code'?: number;
    /**
     * 
     * @type {V0039JobExitCodeSignal}
     * @memberof V0039JobExitCode
     */
    'signal'?: V0039JobExitCodeSignal;
}
/**
 * Job exited due to signal
 * @export
 * @interface V0039JobExitCodeSignal
 */
export interface V0039JobExitCodeSignal {
    /**
     * signal numeric ID
     * @type {number}
     * @memberof V0039JobExitCodeSignal
     */
    'signal_id'?: number;
    /**
     * signal name
     * @type {string}
     * @memberof V0039JobExitCodeSignal
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobHet
 */
export interface V0039JobHet {
    /**
     * 
     * @type {number}
     * @memberof V0039JobHet
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobHet
     */
    'job_offset'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039JobInfo
 */
export interface V0039JobInfo {
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'account'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'accrue_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'admin_comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'allocating_node'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'array_job_id'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'array_task_id'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'array_max_tasks'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'array_task_string'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'association_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'batch_features'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'batch_flag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'batch_host'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'flags'?: Array<V0039JobInfoFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'burst_buffer'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'burst_buffer_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'cluster'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'cluster_features'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'command'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'container_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'contiguous'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'core_spec'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'thread_spec'?: number;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'cores_per_socket'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Float64NoVal}
     * @memberof V0039JobInfo
     */
    'billable_tres'?: V0039Float64NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'cpus_per_task'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'cpu_frequency_minimum'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'cpu_frequency_maximum'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'cpu_frequency_governor'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'cpus_per_tres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'cron'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'deadline'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'delay_boot'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'dependency'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'derived_exit_code'?: V0039Uint32NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'eligible_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'end_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'excluded_nodes'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'exit_code'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'extra'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'failed_node'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'features'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'federation_origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'federation_siblings_active'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'federation_siblings_viable'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'gres_detail'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'group_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'group_name'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'het_job_id'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'het_job_id_set'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'het_job_offset'?: V0039Uint32NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0039JobRes}
     * @memberof V0039JobInfo
     */
    'job_resources'?: V0039JobRes;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'job_size_str'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'job_state'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'last_sched_evaluation'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'licenses'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'mail_type'?: Array<V0039JobInfoMailTypeEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'mail_user'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'max_cpus'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'max_nodes'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'mcs_label'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'memory_per_tres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'nodes'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'nice'?: number;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'tasks_per_core'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'tasks_per_tres'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'tasks_per_node'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'tasks_per_socket'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'tasks_per_board'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'cpus'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'node_count'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'tasks'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'partition'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'prefer'?: string;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobInfo
     */
    'memory_per_cpu'?: V0039Uint64NoVal;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobInfo
     */
    'memory_per_node'?: V0039Uint64NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'minimum_cpus_per_node'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'minimum_tmp_disk_per_node'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039JobInfoPower}
     * @memberof V0039JobInfo
     */
    'power'?: V0039JobInfoPower;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'preempt_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'preemptable_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'pre_sus_time'?: number;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'priority'?: V0039Uint32NoVal;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'profile'?: Array<V0039JobInfoProfileEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'qos'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'reboot'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'required_nodes'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'minimum_switches'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'requeue'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'resize_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'restart_cnt'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'resv_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'scheduled_nodes'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'selinux_context'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'shared'?: Array<V0039JobInfoSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'exclusive'?: Array<V0039JobInfoExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0039JobInfo
     */
    'oversubscribe'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039JobInfo
     */
    'show_flags'?: Array<V0039JobInfoShowFlagsEnum>;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'sockets_per_board'?: number;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'sockets_per_node'?: V0039Uint16NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'start_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'state_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'state_reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'standard_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'standard_input'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'standard_output'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'submit_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'suspend_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'system_comment'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'time_limit'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobInfo
     */
    'time_minimum'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039JobInfo
     */
    'threads_per_core'?: V0039Uint16NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_bind'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_freq'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_per_job'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_per_node'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_per_socket'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_per_task'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_req_str'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'tres_alloc_str'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'user_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobInfo
     */
    'maximum_switch_wait_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'wckey'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobInfo
     */
    'current_working_directory'?: string;
}

export const V0039JobInfoFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GredBindingDisabled: 'GRED_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    SaveBatchScript: 'SAVE_BATCH_SCRIPT'
} as const;

export type V0039JobInfoFlagsEnum = typeof V0039JobInfoFlagsEnum[keyof typeof V0039JobInfoFlagsEnum];
export const V0039JobInfoMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0039JobInfoMailTypeEnum = typeof V0039JobInfoMailTypeEnum[keyof typeof V0039JobInfoMailTypeEnum];
export const V0039JobInfoProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0039JobInfoProfileEnum = typeof V0039JobInfoProfileEnum[keyof typeof V0039JobInfoProfileEnum];
export const V0039JobInfoSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0039JobInfoSharedEnum = typeof V0039JobInfoSharedEnum[keyof typeof V0039JobInfoSharedEnum];
export const V0039JobInfoExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0039JobInfoExclusiveEnum = typeof V0039JobInfoExclusiveEnum[keyof typeof V0039JobInfoExclusiveEnum];
export const V0039JobInfoShowFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;

export type V0039JobInfoShowFlagsEnum = typeof V0039JobInfoShowFlagsEnum[keyof typeof V0039JobInfoShowFlagsEnum];

/**
 * 
 * @export
 * @interface V0039JobInfoPower
 */
export interface V0039JobInfoPower {
    /**
     * removed field
     * @type {Array<any>}
     * @memberof V0039JobInfoPower
     * @deprecated
     */
    'flags'?: Array<any>;
}
/**
 * 
 * @export
 * @interface V0039JobMcs
 */
export interface V0039JobMcs {
    /**
     * 
     * @type {string}
     * @memberof V0039JobMcs
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobRequired
 */
export interface V0039JobRequired {
    /**
     * 
     * @type {number}
     * @memberof V0039JobRequired
     */
    'CPUs'?: number;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobRequired
     */
    'memory_per_cpu'?: V0039Uint64NoVal;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039JobRequired
     */
    'memory_per_node'?: V0039Uint64NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039JobRequired
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface V0039JobRes
 */
export interface V0039JobRes {
    /**
     * 
     * @type {string}
     * @memberof V0039JobRes
     */
    'nodes'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039JobRes
     */
    'allocated_cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobRes
     */
    'allocated_cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobRes
     */
    'allocated_hosts'?: number;
    /**
     * job node resources
     * @type {Array<any>}
     * @memberof V0039JobRes
     */
    'allocated_nodes'?: Array<any>;
}
/**
 * 
 * @export
 * @interface V0039JobReservation
 */
export interface V0039JobReservation {
    /**
     * 
     * @type {number}
     * @memberof V0039JobReservation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039JobReservation
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobState
 */
export interface V0039JobState {
    /**
     * 
     * @type {string}
     * @memberof V0039JobState
     */
    'current'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039JobState
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobSubmission
 */
export interface V0039JobSubmission {
    /**
     * Executable script (full contents) to run in batch step for all job components
     * @type {string}
     * @memberof V0039JobSubmission
     */
    'script'?: string;
    /**
     * 
     * @type {V0039JobDescMsg}
     * @memberof V0039JobSubmission
     */
    'job'?: V0039JobDescMsg;
    /**
     * 
     * @type {Array<V0039JobDescMsg>}
     * @memberof V0039JobSubmission
     */
    'jobs'?: Array<V0039JobDescMsg>;
}
/**
 * 
 * @export
 * @interface V0039JobSubmissionResponse
 */
export interface V0039JobSubmissionResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039JobSubmissionResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039JobSubmissionResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039JobSubmissionResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * new job ID
     * @type {number}
     * @memberof V0039JobSubmissionResponse
     */
    'job_id'?: number;
    /**
     * new job step ID
     * @type {string}
     * @memberof V0039JobSubmissionResponse
     */
    'step_id'?: string;
    /**
     * Message to user from job_submit plugin
     * @type {string}
     * @memberof V0039JobSubmissionResponse
     */
    'job_submit_user_msg'?: string;
}
/**
 * 
 * @export
 * @interface V0039JobTime
 */
export interface V0039JobTime {
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'elapsed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'eligible'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'end'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'submission'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0039JobTimeSystem}
     * @memberof V0039JobTime
     */
    'system'?: V0039JobTimeSystem;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039JobTime
     */
    'limit'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039JobTimeSystem}
     * @memberof V0039JobTime
     */
    'total'?: V0039JobTimeSystem;
    /**
     * 
     * @type {V0039JobTimeSystem}
     * @memberof V0039JobTime
     */
    'user'?: V0039JobTimeSystem;
}
/**
 * 
 * @export
 * @interface V0039JobTimeSystem
 */
export interface V0039JobTimeSystem {
    /**
     * 
     * @type {number}
     * @memberof V0039JobTimeSystem
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039JobTimeSystem
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0039JobTres
 */
export interface V0039JobTres {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039JobTres
     */
    'allocated'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039JobTres
     */
    'requested'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039JobUpdateResponse
 */
export interface V0039JobUpdateResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039JobUpdateResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039JobUpdateResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039JobUpdateResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * Result per ArrayJob
     * @type {Array<V0039JobArrayResponseMsgInner>}
     * @memberof V0039JobUpdateResponse
     */
    'results'?: Array<V0039JobArrayResponseMsgInner>;
}
/**
 * 
 * @export
 * @interface V0039JobsResponse
 */
export interface V0039JobsResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039JobsResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039JobsResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039JobsResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039JobInfo>}
     * @memberof V0039JobsResponse
     */
    'jobs'?: Array<V0039JobInfo>;
}
/**
 * 
 * @export
 * @interface V0039License
 */
export interface V0039License {
    /**
     * 
     * @type {string}
     * @memberof V0039License
     */
    'LicenseName'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'Total'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'Used'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'Free'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039License
     */
    'Remote'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'Reserved'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'LastConsumed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'LastDeficit'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039License
     */
    'LastUpdate'?: number;
}
/**
 * 
 * @export
 * @interface V0039LicensesInfo
 */
export interface V0039LicensesInfo {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039LicensesInfo
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039LicensesInfo
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039LicensesInfo
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039License>}
     * @memberof V0039LicensesInfo
     */
    'licenses'?: Array<V0039License>;
}
/**
 * 
 * @export
 * @interface V0039Meta
 */
export interface V0039Meta {
    /**
     * 
     * @type {Dbv0039MetaPlugin}
     * @memberof V0039Meta
     */
    'plugin'?: Dbv0039MetaPlugin;
    /**
     * 
     * @type {Dbv0039MetaSlurm}
     * @memberof V0039Meta
     */
    'Slurm'?: Dbv0039MetaSlurm;
}
/**
 * 
 * @export
 * @interface V0039Node
 */
export interface V0039Node {
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'burstbuffer_network_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'boards'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'boot_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'cluster_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'specialized_cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'cpu_binding'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039Node
     */
    'cpu_load'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039Node
     */
    'free_mem'?: V0039Uint64NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'effective_cpus'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'specialized_cpus'?: string;
    /**
     * 
     * @type {V0039AcctGatherEnergy}
     * @memberof V0039Node
     */
    'energy'?: V0039AcctGatherEnergy;
    /**
     * removed field
     * @type {object}
     * @memberof V0039Node
     * @deprecated
     */
    'external_sensors'?: object;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'extra'?: string;
    /**
     * removed field
     * @type {object}
     * @memberof V0039Node
     * @deprecated
     */
    'power'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Node
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Node
     */
    'active_features'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'gres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'gres_drained'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'gres_used'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'last_busy'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'mcs_label'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'specialized_memory'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Node
     */
    'next_state_after_reboot'?: Array<V0039NodeNextStateAfterRebootEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'hostname'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Node
     */
    'state'?: Array<V0039NodeStateEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'operating_system'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Node
     */
    'partitions'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'real_memory'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'reason_changed_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'reason_set_by_user'?: string;
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039Node
     */
    'resume_after'?: V0039Uint64NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'reservation'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'alloc_memory'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'alloc_cpus'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'alloc_idle_cpus'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'tres_used'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'tres_weighted'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'slurmd_start_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'sockets'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'threads'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'temporary_disk'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Node
     */
    'weight'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'tres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Node
     */
    'version'?: string;
}

export const V0039NodeNextStateAfterRebootEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0039NodeNextStateAfterRebootEnum = typeof V0039NodeNextStateAfterRebootEnum[keyof typeof V0039NodeNextStateAfterRebootEnum];
export const V0039NodeStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0039NodeStateEnum = typeof V0039NodeStateEnum[keyof typeof V0039NodeStateEnum];

/**
 * 
 * @export
 * @interface V0039NodesResponse
 */
export interface V0039NodesResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039NodesResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039NodesResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039NodesResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039Node>}
     * @memberof V0039NodesResponse
     */
    'nodes'?: Array<V0039Node>;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfo
 */
export interface V0039PartitionInfo {
    /**
     * 
     * @type {V0039PartitionInfoNodes}
     * @memberof V0039PartitionInfo
     */
    'nodes'?: V0039PartitionInfoNodes;
    /**
     * 
     * @type {V0039PartitionInfoAccounts}
     * @memberof V0039PartitionInfo
     */
    'accounts'?: V0039PartitionInfoAccounts;
    /**
     * 
     * @type {V0039PartitionInfoGroups}
     * @memberof V0039PartitionInfo
     */
    'groups'?: V0039PartitionInfoGroups;
    /**
     * 
     * @type {V0039PartitionInfoQos}
     * @memberof V0039PartitionInfo
     */
    'qos'?: V0039PartitionInfoQos;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfo
     */
    'alternate'?: string;
    /**
     * 
     * @type {V0039PartitionInfoTres}
     * @memberof V0039PartitionInfo
     */
    'tres'?: V0039PartitionInfoTres;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfo
     */
    'cluster'?: string;
    /**
     * 
     * @type {V0039PartitionInfoCpus}
     * @memberof V0039PartitionInfo
     */
    'cpus'?: V0039PartitionInfoCpus;
    /**
     * 
     * @type {V0039PartitionInfoDefaults}
     * @memberof V0039PartitionInfo
     */
    'defaults'?: V0039PartitionInfoDefaults;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfo
     */
    'grace_time'?: number;
    /**
     * 
     * @type {V0039PartitionInfoMaximums}
     * @memberof V0039PartitionInfo
     */
    'maximums'?: V0039PartitionInfoMaximums;
    /**
     * 
     * @type {V0039PartitionInfoMinimums}
     * @memberof V0039PartitionInfo
     */
    'minimums'?: V0039PartitionInfoMinimums;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfo
     */
    'node_sets'?: string;
    /**
     * 
     * @type {V0039PartitionInfoPriority}
     * @memberof V0039PartitionInfo
     */
    'priority'?: V0039PartitionInfoPriority;
    /**
     * 
     * @type {V0039PartitionInfoTimeouts}
     * @memberof V0039PartitionInfo
     */
    'timeouts'?: V0039PartitionInfoTimeouts;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfo
     */
    'suspend_time'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoAccounts
 */
export interface V0039PartitionInfoAccounts {
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoAccounts
     */
    'allowed'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoAccounts
     */
    'deny'?: string;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoCpus
 */
export interface V0039PartitionInfoCpus {
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoCpus
     */
    'task_binding'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoCpus
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoDefaults
 */
export interface V0039PartitionInfoDefaults {
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoDefaults
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfoDefaults
     */
    'time'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoDefaults
     */
    'job'?: string;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoGroups
 */
export interface V0039PartitionInfoGroups {
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoGroups
     */
    'allowed'?: string;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoMaximums
 */
export interface V0039PartitionInfoMaximums {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfoMaximums
     */
    'cpus_per_node'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfoMaximums
     */
    'cpus_per_socket'?: V0039Uint32NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoMaximums
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfoMaximums
     */
    'nodes'?: V0039Uint32NoVal;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoMaximums
     */
    'shares'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039PartitionInfoMaximums
     */
    'time'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039PartitionInfoMaximums
     */
    'over_time_limit'?: V0039Uint16NoVal;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoMinimums
 */
export interface V0039PartitionInfoMinimums {
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoMinimums
     */
    'nodes'?: number;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoNodes
 */
export interface V0039PartitionInfoNodes {
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoNodes
     */
    'allowed_allocation'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoNodes
     */
    'configured'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoNodes
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoPriority
 */
export interface V0039PartitionInfoPriority {
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoPriority
     */
    'job_factor'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039PartitionInfoPriority
     */
    'tier'?: number;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoQos
 */
export interface V0039PartitionInfoQos {
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoQos
     */
    'allowed'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoQos
     */
    'deny'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoQos
     */
    'assigned'?: string;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoTimeouts
 */
export interface V0039PartitionInfoTimeouts {
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039PartitionInfoTimeouts
     */
    'resume'?: V0039Uint16NoVal;
    /**
     * 
     * @type {V0039Uint16NoVal}
     * @memberof V0039PartitionInfoTimeouts
     */
    'suspend'?: V0039Uint16NoVal;
}
/**
 * 
 * @export
 * @interface V0039PartitionInfoTres
 */
export interface V0039PartitionInfoTres {
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoTres
     */
    'billing_weights'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039PartitionInfoTres
     */
    'configured'?: string;
}
/**
 * 
 * @export
 * @interface V0039PartitionsResponse
 */
export interface V0039PartitionsResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039PartitionsResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039PartitionsResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039PartitionsResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039PartitionInfo>}
     * @memberof V0039PartitionsResponse
     */
    'partitions'?: Array<V0039PartitionInfo>;
}
/**
 * 
 * @export
 * @interface V0039Pings
 */
export interface V0039Pings {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039Pings
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039Pings
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039Pings
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039ControllerPing>}
     * @memberof V0039Pings
     */
    'pings'?: Array<V0039ControllerPing>;
}
/**
 * 
 * @export
 * @interface V0039Qos
 */
export interface V0039Qos {
    /**
     * 
     * @type {string}
     * @memberof V0039Qos
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Qos
     */
    'flags'?: Array<V0039QosFlagsEnum>;
    /**
     * 
     * @type {number}
     * @memberof V0039Qos
     */
    'id'?: number;
    /**
     * 
     * @type {V0039QosLimits}
     * @memberof V0039Qos
     */
    'limits'?: V0039QosLimits;
    /**
     * 
     * @type {string}
     * @memberof V0039Qos
     */
    'name'?: string;
    /**
     * 
     * @type {V0039QosPreempt}
     * @memberof V0039Qos
     */
    'preempt'?: V0039QosPreempt;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039Qos
     */
    'priority'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Float64NoVal}
     * @memberof V0039Qos
     */
    'usage_factor'?: V0039Float64NoVal;
    /**
     * 
     * @type {V0039Float64NoVal}
     * @memberof V0039Qos
     */
    'usage_threshold'?: V0039Float64NoVal;
}

export const V0039QosFlagsEnum = {
    NotSet: 'NOT_SET',
    Add: 'ADD',
    Remove: 'REMOVE',
    PartitionMinimumNode: 'PARTITION_MINIMUM_NODE',
    PartitionMaximumNode: 'PARTITION_MAXIMUM_NODE',
    PartitionTimeLimit: 'PARTITION_TIME_LIMIT',
    EnforceUsageThreshold: 'ENFORCE_USAGE_THRESHOLD',
    NoReserve: 'NO_RESERVE',
    RequiredReservation: 'REQUIRED_RESERVATION',
    DenyLimit: 'DENY_LIMIT',
    OverridePartitionQos: 'OVERRIDE_PARTITION_QOS',
    NoDecay: 'NO_DECAY',
    UsageFactorSafe: 'USAGE_FACTOR_SAFE'
} as const;

export type V0039QosFlagsEnum = typeof V0039QosFlagsEnum[keyof typeof V0039QosFlagsEnum];

/**
 * 
 * @export
 * @interface V0039QosLimits
 */
export interface V0039QosLimits {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimits
     */
    'grace_time'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039QosLimitsMax}
     * @memberof V0039QosLimits
     */
    'max'?: V0039QosLimitsMax;
    /**
     * 
     * @type {number}
     * @memberof V0039QosLimits
     */
    'factor'?: number;
    /**
     * 
     * @type {V0039QosLimitsMin}
     * @memberof V0039QosLimits
     */
    'min'?: V0039QosLimitsMin;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMax
 */
export interface V0039QosLimitsMax {
    /**
     * 
     * @type {V0039QosLimitsMaxActiveJobs}
     * @memberof V0039QosLimitsMax
     */
    'active_jobs'?: V0039QosLimitsMaxActiveJobs;
    /**
     * 
     * @type {V0039QosLimitsMaxTres}
     * @memberof V0039QosLimitsMax
     */
    'tres'?: V0039QosLimitsMaxTres;
    /**
     * 
     * @type {V0039QosLimitsMaxWallClock}
     * @memberof V0039QosLimitsMax
     */
    'wall_clock'?: V0039QosLimitsMaxWallClock;
    /**
     * 
     * @type {V0039QosLimitsMaxJobs}
     * @memberof V0039QosLimitsMax
     */
    'jobs'?: V0039QosLimitsMaxJobs;
    /**
     * 
     * @type {V0039QosLimitsMaxJobsActiveJobs}
     * @memberof V0039QosLimitsMax
     */
    'accruing'?: V0039QosLimitsMaxJobsActiveJobs;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxActiveJobs
 */
export interface V0039QosLimitsMaxActiveJobs {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxActiveJobs
     */
    'accruing'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxActiveJobs
     */
    'count'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxJobs
 */
export interface V0039QosLimitsMaxJobs {
    /**
     * 
     * @type {V0039QosLimitsMaxJobsActiveJobs}
     * @memberof V0039QosLimitsMaxJobs
     */
    'active_jobs'?: V0039QosLimitsMaxJobsActiveJobs;
    /**
     * 
     * @type {V0039QosLimitsMaxJobsActiveJobsPer}
     * @memberof V0039QosLimitsMaxJobs
     */
    'per'?: V0039QosLimitsMaxJobsActiveJobsPer;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxJobsActiveJobs
 */
export interface V0039QosLimitsMaxJobsActiveJobs {
    /**
     * 
     * @type {V0039QosLimitsMaxJobsActiveJobsPer}
     * @memberof V0039QosLimitsMaxJobsActiveJobs
     */
    'per'?: V0039QosLimitsMaxJobsActiveJobsPer;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxJobsActiveJobsPer
 */
export interface V0039QosLimitsMaxJobsActiveJobsPer {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxJobsActiveJobsPer
     */
    'account'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxJobsActiveJobsPer
     */
    'user'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxTres
 */
export interface V0039QosLimitsMaxTres {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTres
     */
    'total'?: Array<V0039Tres>;
    /**
     * 
     * @type {V0039QosLimitsMaxTresMinutes}
     * @memberof V0039QosLimitsMaxTres
     */
    'minutes'?: V0039QosLimitsMaxTresMinutes;
    /**
     * 
     * @type {V0039QosLimitsMaxTresPer}
     * @memberof V0039QosLimitsMaxTres
     */
    'per'?: V0039QosLimitsMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxTresMinutes
 */
export interface V0039QosLimitsMaxTresMinutes {
    /**
     * 
     * @type {V0039QosLimitsMaxTresMinutesPer}
     * @memberof V0039QosLimitsMaxTresMinutes
     */
    'per'?: V0039QosLimitsMaxTresMinutesPer;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxTresMinutesPer
 */
export interface V0039QosLimitsMaxTresMinutesPer {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresMinutesPer
     */
    'qos'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresMinutesPer
     */
    'job'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresMinutesPer
     */
    'account'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresMinutesPer
     */
    'user'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxTresPer
 */
export interface V0039QosLimitsMaxTresPer {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresPer
     */
    'account'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresPer
     */
    'job'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresPer
     */
    'node'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039QosLimitsMaxTresPer
     */
    'user'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxWallClock
 */
export interface V0039QosLimitsMaxWallClock {
    /**
     * 
     * @type {V0039QosLimitsMaxWallClockPer}
     * @memberof V0039QosLimitsMaxWallClock
     */
    'per'?: V0039QosLimitsMaxWallClockPer;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMaxWallClockPer
 */
export interface V0039QosLimitsMaxWallClockPer {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxWallClockPer
     */
    'qos'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMaxWallClockPer
     */
    'job'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMin
 */
export interface V0039QosLimitsMin {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosLimitsMin
     */
    'priority_threshold'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039QosLimitsMinTres}
     * @memberof V0039QosLimitsMin
     */
    'tres'?: V0039QosLimitsMinTres;
}
/**
 * 
 * @export
 * @interface V0039QosLimitsMinTres
 */
export interface V0039QosLimitsMinTres {
    /**
     * 
     * @type {V0039AssocMaxTresMinutesPer}
     * @memberof V0039QosLimitsMinTres
     */
    'per'?: V0039AssocMaxTresMinutesPer;
}
/**
 * 
 * @export
 * @interface V0039QosPreempt
 */
export interface V0039QosPreempt {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039QosPreempt
     */
    'list'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039QosPreempt
     */
    'mode'?: Array<V0039QosPreemptModeEnum>;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039QosPreempt
     */
    'exempt_time'?: V0039Uint32NoVal;
}

export const V0039QosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;

export type V0039QosPreemptModeEnum = typeof V0039QosPreemptModeEnum[keyof typeof V0039QosPreemptModeEnum];

/**
 * 
 * @export
 * @interface V0039ReservationCoreSpec
 */
export interface V0039ReservationCoreSpec {
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationCoreSpec
     */
    'node'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationCoreSpec
     */
    'core'?: string;
}
/**
 * 
 * @export
 * @interface V0039ReservationInfo
 */
export interface V0039ReservationInfo {
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'accounts'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'burst_buffer'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039ReservationInfo
     */
    'core_count'?: number;
    /**
     * 
     * @type {Array<V0039ReservationCoreSpec>}
     * @memberof V0039ReservationInfo
     */
    'core_specializations'?: Array<V0039ReservationCoreSpec>;
    /**
     * 
     * @type {number}
     * @memberof V0039ReservationInfo
     */
    'end_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'features'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039ReservationInfo
     */
    'flags'?: Array<V0039ReservationInfoFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'groups'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'licenses'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039ReservationInfo
     */
    'max_start_delay'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039ReservationInfo
     */
    'node_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'node_list'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'partition'?: string;
    /**
     * 
     * @type {V0039ReservationInfoPurgeCompleted}
     * @memberof V0039ReservationInfo
     */
    'purge_completed'?: V0039ReservationInfoPurgeCompleted;
    /**
     * 
     * @type {number}
     * @memberof V0039ReservationInfo
     */
    'start_time'?: number;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039ReservationInfo
     */
    'watts'?: V0039Uint32NoVal;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'tres'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039ReservationInfo
     */
    'users'?: string;
}

export const V0039ReservationInfoFlagsEnum = {
    Maint: 'MAINT',
    NoMaint: 'NO_MAINT',
    Daily: 'DAILY',
    NoDaily: 'NO_DAILY',
    Weekly: 'WEEKLY',
    NoWeekly: 'NO_WEEKLY',
    IgnoreJobs: 'IGNORE_JOBS',
    NoIgnoreJobs: 'NO_IGNORE_JOBS',
    AnyNodes: 'ANY_NODES',
    Static: 'STATIC',
    NoStatic: 'NO_STATIC',
    PartNodes: 'PART_NODES',
    NoPartNodes: 'NO_PART_NODES',
    Overlap: 'OVERLAP',
    SpecNodes: 'SPEC_NODES',
    TimeFloat: 'TIME_FLOAT',
    Replace: 'REPLACE',
    AllNodes: 'ALL_NODES',
    PurgeComp: 'PURGE_COMP',
    Weekday: 'WEEKDAY',
    NoWeekday: 'NO_WEEKDAY',
    Weekend: 'WEEKEND',
    NoWeekend: 'NO_WEEKEND',
    Flex: 'FLEX',
    NoFlex: 'NO_FLEX',
    DurationPlus: 'DURATION_PLUS',
    DurationMinus: 'DURATION_MINUS',
    NoHoldJobsAfterEnd: 'NO_HOLD_JOBS_AFTER_END',
    NoPurgeComp: 'NO_PURGE_COMP',
    Magnetic: 'MAGNETIC',
    Skip: 'SKIP',
    Hourly: 'HOURLY',
    NoHourly: 'NO_HOURLY',
    Reoccurring: 'REOCCURRING'
} as const;

export type V0039ReservationInfoFlagsEnum = typeof V0039ReservationInfoFlagsEnum[keyof typeof V0039ReservationInfoFlagsEnum];

/**
 * 
 * @export
 * @interface V0039ReservationInfoPurgeCompleted
 */
export interface V0039ReservationInfoPurgeCompleted {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039ReservationInfoPurgeCompleted
     */
    'time'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039ReservationsResponse
 */
export interface V0039ReservationsResponse {
    /**
     * 
     * @type {V0039Meta}
     * @memberof V0039ReservationsResponse
     */
    'meta'?: V0039Meta;
    /**
     * Slurm errors
     * @type {Array<V0039Error>}
     * @memberof V0039ReservationsResponse
     */
    'errors'?: Array<V0039Error>;
    /**
     * Slurm warnings
     * @type {Array<V0039Warning>}
     * @memberof V0039ReservationsResponse
     */
    'warnings'?: Array<V0039Warning>;
    /**
     * 
     * @type {Array<V0039ReservationInfo>}
     * @memberof V0039ReservationsResponse
     */
    'reservations'?: Array<V0039ReservationInfo>;
}
/**
 * step details
 * @export
 * @interface V0039SlurmStepId
 */
export interface V0039SlurmStepId {
    /**
     * JobID
     * @type {number}
     * @memberof V0039SlurmStepId
     */
    'job_id'?: number;
    /**
     * HetStep
     * @type {number}
     * @memberof V0039SlurmStepId
     */
    'step_het_component'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039SlurmStepId
     */
    'step_id'?: string;
}
/**
 * 
 * @export
 * @interface V0039StatsMsg
 */
export interface V0039StatsMsg {
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'parts_packed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'req_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'req_time_start'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'server_thread_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'agent_queue_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'agent_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'agent_thread_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'dbd_agent_queue_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'gettimeofday_latency'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_max'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_last'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_mean_depth'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_cycle_per_minute'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'schedule_queue_length'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_submitted'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_started'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_completed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_canceled'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_failed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_pending'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'jobs_running'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'job_states_ts'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_backfilled_jobs'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_last_backfilled_jobs'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_backfilled_het_jobs'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_cycle_counter'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_cycle_mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_depth_mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_depth_mean_try'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_cycle_sum'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_cycle_last'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_last_depth'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_last_depth_try'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_depth_sum'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_depth_try_sum'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_queue_len'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_queue_len_mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_queue_len_sum'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_table_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_table_size_mean'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsMsg
     */
    'bf_when_last_cycle'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V0039StatsMsg
     */
    'bf_active'?: boolean;
    /**
     * RPCs by message type
     * @type {Array<V0040StatsMsgRpcsByTypeInner>}
     * @memberof V0039StatsMsg
     */
    'rpcs_by_message_type'?: Array<V0040StatsMsgRpcsByTypeInner>;
    /**
     * RPCs by user
     * @type {Array<V0040StatsMsgRpcsByUserInner>}
     * @memberof V0039StatsMsg
     */
    'rpcs_by_user'?: Array<V0040StatsMsgRpcsByUserInner>;
}
/**
 * 
 * @export
 * @interface V0039StatsRec
 */
export interface V0039StatsRec {
    /**
     * 
     * @type {number}
     * @memberof V0039StatsRec
     */
    'time_start'?: number;
    /**
     * list of recorded rollup statistics
     * @type {Array<V0040RollupStatsInner>}
     * @memberof V0039StatsRec
     */
    'rollups'?: Array<V0040RollupStatsInner>;
    /**
     * 
     * @type {Array<V0039StatsRpc>}
     * @memberof V0039StatsRec
     */
    'RPCs'?: Array<V0039StatsRpc>;
    /**
     * 
     * @type {Array<V0039StatsUser>}
     * @memberof V0039StatsRec
     */
    'users'?: Array<V0039StatsUser>;
}
/**
 * 
 * @export
 * @interface V0039StatsRpc
 */
export interface V0039StatsRpc {
    /**
     * 
     * @type {string}
     * @memberof V0039StatsRpc
     */
    'rpc'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsRpc
     */
    'count'?: number;
    /**
     * 
     * @type {V0039StatsRpcTime}
     * @memberof V0039StatsRpc
     */
    'time'?: V0039StatsRpcTime;
}
/**
 * 
 * @export
 * @interface V0039StatsRpcTime
 */
export interface V0039StatsRpcTime {
    /**
     * 
     * @type {number}
     * @memberof V0039StatsRpcTime
     */
    'average'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsRpcTime
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0039StatsUser
 */
export interface V0039StatsUser {
    /**
     * 
     * @type {string}
     * @memberof V0039StatsUser
     */
    'user'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039StatsUser
     */
    'count'?: number;
    /**
     * 
     * @type {V0039StatsRpcTime}
     * @memberof V0039StatsUser
     */
    'time'?: V0039StatsRpcTime;
}
/**
 * 
 * @export
 * @interface V0039Step
 */
export interface V0039Step {
    /**
     * 
     * @type {V0039StepTime}
     * @memberof V0039Step
     */
    'time'?: V0039StepTime;
    /**
     * 
     * @type {V0039JobExitCode}
     * @memberof V0039Step
     */
    'exit_code'?: V0039JobExitCode;
    /**
     * 
     * @type {V0039StepNodes}
     * @memberof V0039Step
     */
    'nodes'?: V0039StepNodes;
    /**
     * 
     * @type {V0039StepTasks}
     * @memberof V0039Step
     */
    'tasks'?: V0039StepTasks;
    /**
     * 
     * @type {string}
     * @memberof V0039Step
     */
    'pid'?: string;
    /**
     * 
     * @type {V0039StepCPU}
     * @memberof V0039Step
     */
    'CPU'?: V0039StepCPU;
    /**
     * 
     * @type {string}
     * @memberof V0039Step
     */
    'kill_request_user'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039Step
     */
    'state'?: string;
    /**
     * 
     * @type {V0039StepStatistics}
     * @memberof V0039Step
     */
    'statistics'?: V0039StepStatistics;
    /**
     * 
     * @type {V0039StepStep}
     * @memberof V0039Step
     */
    'step'?: V0039StepStep;
    /**
     * 
     * @type {V0039StepTask}
     * @memberof V0039Step
     */
    'task'?: V0039StepTask;
    /**
     * 
     * @type {V0039StepTres}
     * @memberof V0039Step
     */
    'tres'?: V0039StepTres;
}
/**
 * 
 * @export
 * @interface V0039StepCPU
 */
export interface V0039StepCPU {
    /**
     * 
     * @type {V0039StepCPURequestedFrequency}
     * @memberof V0039StepCPU
     */
    'requested_frequency'?: V0039StepCPURequestedFrequency;
    /**
     * 
     * @type {string}
     * @memberof V0039StepCPU
     */
    'governor'?: string;
}
/**
 * 
 * @export
 * @interface V0039StepCPURequestedFrequency
 */
export interface V0039StepCPURequestedFrequency {
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039StepCPURequestedFrequency
     */
    'min'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039StepCPURequestedFrequency
     */
    'max'?: V0039Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0039StepNodes
 */
export interface V0039StepNodes {
    /**
     * 
     * @type {number}
     * @memberof V0039StepNodes
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039StepNodes
     */
    'range'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039StepNodes
     */
    'list'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0039StepStatistics
 */
export interface V0039StepStatistics {
    /**
     * 
     * @type {V0039StepStatisticsCPU}
     * @memberof V0039StepStatistics
     */
    'CPU'?: V0039StepStatisticsCPU;
    /**
     * 
     * @type {V0039StepStatisticsEnergy}
     * @memberof V0039StepStatistics
     */
    'energy'?: V0039StepStatisticsEnergy;
}
/**
 * 
 * @export
 * @interface V0039StepStatisticsCPU
 */
export interface V0039StepStatisticsCPU {
    /**
     * 
     * @type {number}
     * @memberof V0039StepStatisticsCPU
     */
    'actual_frequency'?: number;
}
/**
 * 
 * @export
 * @interface V0039StepStatisticsEnergy
 */
export interface V0039StepStatisticsEnergy {
    /**
     * 
     * @type {V0039Uint64NoVal}
     * @memberof V0039StepStatisticsEnergy
     */
    'consumed'?: V0039Uint64NoVal;
}
/**
 * 
 * @export
 * @interface V0039StepStep
 */
export interface V0039StepStep {
    /**
     * 
     * @type {V0039SlurmStepId}
     * @memberof V0039StepStep
     */
    'id'?: V0039SlurmStepId;
    /**
     * 
     * @type {string}
     * @memberof V0039StepStep
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0039StepTask
 */
export interface V0039StepTask {
    /**
     * 
     * @type {string}
     * @memberof V0039StepTask
     */
    'distribution'?: string;
}
/**
 * 
 * @export
 * @interface V0039StepTasks
 */
export interface V0039StepTasks {
    /**
     * 
     * @type {number}
     * @memberof V0039StepTasks
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface V0039StepTime
 */
export interface V0039StepTime {
    /**
     * 
     * @type {number}
     * @memberof V0039StepTime
     */
    'elapsed'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StepTime
     */
    'end'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StepTime
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StepTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0039StepTimeSystem}
     * @memberof V0039StepTime
     */
    'system'?: V0039StepTimeSystem;
    /**
     * 
     * @type {V0039StepTimeSystem}
     * @memberof V0039StepTime
     */
    'total'?: V0039StepTimeSystem;
    /**
     * 
     * @type {V0039StepTimeSystem}
     * @memberof V0039StepTime
     */
    'user'?: V0039StepTimeSystem;
}
/**
 * 
 * @export
 * @interface V0039StepTimeSystem
 */
export interface V0039StepTimeSystem {
    /**
     * 
     * @type {number}
     * @memberof V0039StepTimeSystem
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039StepTimeSystem
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0039StepTres
 */
export interface V0039StepTres {
    /**
     * 
     * @type {V0039StepTresRequested}
     * @memberof V0039StepTres
     */
    'requested'?: V0039StepTresRequested;
    /**
     * 
     * @type {V0039StepTresConsumed}
     * @memberof V0039StepTres
     */
    'consumed'?: V0039StepTresConsumed;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTres
     */
    'allocated'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039StepTresConsumed
 */
export interface V0039StepTresConsumed {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresConsumed
     */
    'max'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresConsumed
     */
    'min'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresConsumed
     */
    'average'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresConsumed
     */
    'total'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039StepTresRequested
 */
export interface V0039StepTresRequested {
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresRequested
     */
    'max'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresRequested
     */
    'min'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresRequested
     */
    'average'?: Array<V0039Tres>;
    /**
     * 
     * @type {Array<V0039Tres>}
     * @memberof V0039StepTresRequested
     */
    'total'?: Array<V0039Tres>;
}
/**
 * 
 * @export
 * @interface V0039Tres
 */
export interface V0039Tres {
    /**
     * 
     * @type {string}
     * @memberof V0039Tres
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof V0039Tres
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof V0039Tres
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof V0039Tres
     */
    'count'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0039Uint16NoVal
 */
export interface V0039Uint16NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0039Uint16NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0039Uint16NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0039Uint16NoVal
     */
    'number'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0039Uint32NoVal
 */
export interface V0039Uint32NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0039Uint32NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0039Uint32NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0039Uint32NoVal
     */
    'number'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0039Uint64NoVal
 */
export interface V0039Uint64NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0039Uint64NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0039Uint64NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0039Uint64NoVal
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0039UpdateNodeMsg
 */
export interface V0039UpdateNodeMsg {
    /**
     * arbitrary comment
     * @type {string}
     * @memberof V0039UpdateNodeMsg
     */
    'comment'?: string;
    /**
     * default CPU binding type
     * @type {number}
     * @memberof V0039UpdateNodeMsg
     */
    'cpu_bind'?: number;
    /**
     * arbitrary string
     * @type {string}
     * @memberof V0039UpdateNodeMsg
     */
    'extra'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'features_act'?: Array<string>;
    /**
     * new generic resources for node
     * @type {string}
     * @memberof V0039UpdateNodeMsg
     */
    'gres'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'address'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'hostname'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'name'?: Array<string>;
    /**
     * assign new node state
     * @type {Array<string>}
     * @memberof V0039UpdateNodeMsg
     */
    'state'?: Array<V0039UpdateNodeMsgStateEnum>;
    /**
     * reason for node being DOWN or DRAINING
     * @type {string}
     * @memberof V0039UpdateNodeMsg
     */
    'reason'?: string;
    /**
     * user ID of sending (needed if user root is sending message)
     * @type {string}
     * @memberof V0039UpdateNodeMsg
     */
    'reason_uid'?: string;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039UpdateNodeMsg
     */
    'resume_after'?: V0039Uint32NoVal;
    /**
     * 
     * @type {V0039Uint32NoVal}
     * @memberof V0039UpdateNodeMsg
     */
    'weight'?: V0039Uint32NoVal;
}

export const V0039UpdateNodeMsgStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0039UpdateNodeMsgStateEnum = typeof V0039UpdateNodeMsgStateEnum[keyof typeof V0039UpdateNodeMsgStateEnum];

/**
 * 
 * @export
 * @interface V0039User
 */
export interface V0039User {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039User
     */
    'administrator_level'?: Array<V0039UserAdministratorLevelEnum>;
    /**
     * 
     * @type {Array<V0039AssocShort>}
     * @memberof V0039User
     */
    'associations'?: Array<V0039AssocShort>;
    /**
     * 
     * @type {Array<V0039Coord>}
     * @memberof V0039User
     */
    'coordinators'?: Array<V0039Coord>;
    /**
     * 
     * @type {V0039UserDefault}
     * @memberof V0039User
     */
    'default'?: V0039UserDefault;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039User
     */
    'flags'?: Array<V0039UserFlagsEnum>;
    /**
     * 
     * @type {string}
     * @memberof V0039User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V0039User
     */
    'old_name'?: string;
    /**
     * 
     * @type {Array<V0039Wckey>}
     * @memberof V0039User
     */
    'wckeys'?: Array<V0039Wckey>;
}

export const V0039UserAdministratorLevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;

export type V0039UserAdministratorLevelEnum = typeof V0039UserAdministratorLevelEnum[keyof typeof V0039UserAdministratorLevelEnum];
export const V0039UserFlagsEnum = {
    None: 'NONE',
    Deleted: 'DELETED'
} as const;

export type V0039UserFlagsEnum = typeof V0039UserFlagsEnum[keyof typeof V0039UserFlagsEnum];

/**
 * 
 * @export
 * @interface V0039UserDefault
 */
export interface V0039UserDefault {
    /**
     * 
     * @type {string}
     * @memberof V0039UserDefault
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0039UserDefault
     */
    'wckey'?: string;
}
/**
 * 
 * @export
 * @interface V0039Warning
 */
export interface V0039Warning {
    /**
     * Earning message
     * @type {string}
     * @memberof V0039Warning
     */
    'warning'?: string;
    /**
     * Where error occurred in the source
     * @type {string}
     * @memberof V0039Warning
     */
    'source'?: string;
    /**
     * Explanation of cause of error
     * @type {string}
     * @memberof V0039Warning
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface V0039Wckey
 */
export interface V0039Wckey {
    /**
     * 
     * @type {Array<V0039Accounting>}
     * @memberof V0039Wckey
     */
    'accounting'?: Array<V0039Accounting>;
    /**
     * 
     * @type {string}
     * @memberof V0039Wckey
     */
    'cluster': string;
    /**
     * 
     * @type {number}
     * @memberof V0039Wckey
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof V0039Wckey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof V0039Wckey
     */
    'user': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0039Wckey
     */
    'flags'?: Array<V0039WckeyFlagsEnum>;
}

export const V0039WckeyFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0039WckeyFlagsEnum = typeof V0039WckeyFlagsEnum[keyof typeof V0039WckeyFlagsEnum];

/**
 * wckey details
 * @export
 * @interface V0039WckeyTag
 */
export interface V0039WckeyTag {
    /**
     * wckey
     * @type {string}
     * @memberof V0039WckeyTag
     */
    'wckey'?: string;
    /**
     * active flags
     * @type {Array<string>}
     * @memberof V0039WckeyTag
     */
    'flags'?: Array<V0039WckeyTagFlagsEnum>;
}

export const V0039WckeyTagFlagsEnum = {
    AssignedDefault: 'ASSIGNED_DEFAULT'
} as const;

export type V0039WckeyTagFlagsEnum = typeof V0039WckeyTagFlagsEnum[keyof typeof V0039WckeyTagFlagsEnum];

/**
 * 
 * @export
 * @interface V0040Account
 */
export interface V0040Account {
    /**
     * 
     * @type {Array<V0040AssocShort>}
     * @memberof V0040Account
     */
    'associations'?: Array<V0040AssocShort>;
    /**
     * 
     * @type {Array<V0040Coord>}
     * @memberof V0040Account
     */
    'coordinators'?: Array<V0040Coord>;
    /**
     * Arbitrary string describing the account
     * @type {string}
     * @memberof V0040Account
     */
    'description': string;
    /**
     * Account name
     * @type {string}
     * @memberof V0040Account
     */
    'name': string;
    /**
     * Organization to which the account belongs
     * @type {string}
     * @memberof V0040Account
     */
    'organization': string;
    /**
     * Flags associated with the account
     * @type {Array<string>}
     * @memberof V0040Account
     */
    'flags'?: Array<V0040AccountFlagsEnum>;
}

export const V0040AccountFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0040AccountFlagsEnum = typeof V0040AccountFlagsEnum[keyof typeof V0040AccountFlagsEnum];

/**
 * 
 * @export
 * @interface V0040AccountShort
 */
export interface V0040AccountShort {
    /**
     * Arbitrary string describing the account
     * @type {string}
     * @memberof V0040AccountShort
     */
    'description'?: string;
    /**
     * Organization to which the account belongs
     * @type {string}
     * @memberof V0040AccountShort
     */
    'organization'?: string;
}
/**
 * 
 * @export
 * @interface V0040Accounting
 */
export interface V0040Accounting {
    /**
     * 
     * @type {V0040AccountingAllocated}
     * @memberof V0040Accounting
     */
    'allocated'?: V0040AccountingAllocated;
    /**
     * Association ID or Workload characterization key ID
     * @type {number}
     * @memberof V0040Accounting
     */
    'id'?: number;
    /**
     * When the record was started
     * @type {number}
     * @memberof V0040Accounting
     */
    'start'?: number;
    /**
     * 
     * @type {V0040Tres}
     * @memberof V0040Accounting
     */
    'TRES'?: V0040Tres;
}
/**
 * 
 * @export
 * @interface V0040AccountingAllocated
 */
export interface V0040AccountingAllocated {
    /**
     * Number of cpu seconds allocated
     * @type {number}
     * @memberof V0040AccountingAllocated
     */
    'seconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040AccountsAddCond
 */
export interface V0040AccountsAddCond {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040AccountsAddCond
     */
    'accounts': Array<string>;
    /**
     * 
     * @type {V0040AssocRecSet}
     * @memberof V0040AccountsAddCond
     */
    'association'?: V0040AssocRecSet;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040AccountsAddCond
     */
    'clusters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0040AcctGatherEnergy
 */
export interface V0040AcctGatherEnergy {
    /**
     * Average power consumption, in watts
     * @type {number}
     * @memberof V0040AcctGatherEnergy
     */
    'average_watts'?: number;
    /**
     * The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
     * @type {number}
     * @memberof V0040AcctGatherEnergy
     */
    'base_consumed_energy'?: number;
    /**
     * The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
     * @type {number}
     * @memberof V0040AcctGatherEnergy
     */
    'consumed_energy'?: number;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AcctGatherEnergy
     */
    'current_watts'?: V0040Uint32NoVal;
    /**
     * Previous value of consumed_energy
     * @type {number}
     * @memberof V0040AcctGatherEnergy
     */
    'previous_consumed_energy'?: number;
    /**
     * Time when energy data was last retrieved (UNIX timestamp)
     * @type {number}
     * @memberof V0040AcctGatherEnergy
     */
    'last_collected'?: number;
}
/**
 * 
 * @export
 * @interface V0040Assoc
 */
export interface V0040Assoc {
    /**
     * 
     * @type {Array<V0040Accounting>}
     * @memberof V0040Assoc
     */
    'accounting'?: Array<V0040Accounting>;
    /**
     * Account
     * @type {string}
     * @memberof V0040Assoc
     */
    'account'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040Assoc
     */
    'cluster'?: string;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0040Assoc
     */
    'comment'?: string;
    /**
     * 
     * @type {V0040AssocDefault}
     * @memberof V0040Assoc
     */
    'default'?: V0040AssocDefault;
    /**
     * Flags on the association
     * @type {Array<string>}
     * @memberof V0040Assoc
     */
    'flags'?: Array<V0040AssocFlagsEnum>;
    /**
     * 
     * @type {V0040AssocMax}
     * @memberof V0040Assoc
     */
    'max'?: V0040AssocMax;
    /**
     * 
     * @type {V0040AssocShort}
     * @memberof V0040Assoc
     */
    'id'?: V0040AssocShort;
    /**
     * Is default association for user
     * @type {boolean}
     * @memberof V0040Assoc
     */
    'is_default'?: boolean;
    /**
     * Complete path up the hierarchy to the root association
     * @type {string}
     * @memberof V0040Assoc
     */
    'lineage'?: string;
    /**
     * 
     * @type {V0040AssocMin}
     * @memberof V0040Assoc
     */
    'min'?: V0040AssocMin;
    /**
     * Name of parent account
     * @type {string}
     * @memberof V0040Assoc
     */
    'parent_account'?: string;
    /**
     * Partition name
     * @type {string}
     * @memberof V0040Assoc
     */
    'partition'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040Assoc
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * List of QOS names
     * @type {Array<string>}
     * @memberof V0040Assoc
     */
    'qos'?: Array<string>;
    /**
     * Allocated shares used for fairshare calculation
     * @type {number}
     * @memberof V0040Assoc
     */
    'shares_raw'?: number;
    /**
     * User name
     * @type {string}
     * @memberof V0040Assoc
     */
    'user': string;
}

export const V0040AssocFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0040AssocFlagsEnum = typeof V0040AssocFlagsEnum[keyof typeof V0040AssocFlagsEnum];

/**
 * 
 * @export
 * @interface V0040AssocDefault
 */
export interface V0040AssocDefault {
    /**
     * Default QOS
     * @type {string}
     * @memberof V0040AssocDefault
     */
    'qos'?: string;
}
/**
 * 
 * @export
 * @interface V0040AssocMax
 */
export interface V0040AssocMax {
    /**
     * 
     * @type {V0040AssocMaxJobs}
     * @memberof V0040AssocMax
     */
    'jobs'?: V0040AssocMaxJobs;
    /**
     * 
     * @type {V0040AssocMaxTres}
     * @memberof V0040AssocMax
     */
    'tres'?: V0040AssocMaxTres;
    /**
     * 
     * @type {V0040AssocMaxPer}
     * @memberof V0040AssocMax
     */
    'per'?: V0040AssocMaxPer;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxJobs
 */
export interface V0040AssocMaxJobs {
    /**
     * 
     * @type {V0040AssocMaxJobsPer}
     * @memberof V0040AssocMaxJobs
     */
    'per'?: V0040AssocMaxJobsPer;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobs
     */
    'active'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobs
     */
    'accruing'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobs
     */
    'total'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxJobsPer
 */
export interface V0040AssocMaxJobsPer {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobsPer
     */
    'count'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobsPer
     */
    'accruing'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobsPer
     */
    'submitted'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxJobsPer
     */
    'wall_clock'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxPer
 */
export interface V0040AssocMaxPer {
    /**
     * 
     * @type {V0040AssocMaxPerAccount}
     * @memberof V0040AssocMaxPer
     */
    'account'?: V0040AssocMaxPerAccount;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxPerAccount
 */
export interface V0040AssocMaxPerAccount {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMaxPerAccount
     */
    'wall_clock'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxTres
 */
export interface V0040AssocMaxTres {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTres
     */
    'total'?: Array<V0040Tres>;
    /**
     * 
     * @type {V0040AssocMaxTresGroup}
     * @memberof V0040AssocMaxTres
     */
    'group'?: V0040AssocMaxTresGroup;
    /**
     * 
     * @type {V0040AssocMaxTresMinutes}
     * @memberof V0040AssocMaxTres
     */
    'minutes'?: V0040AssocMaxTresMinutes;
    /**
     * 
     * @type {V0040AssocMaxTresPer}
     * @memberof V0040AssocMaxTres
     */
    'per'?: V0040AssocMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxTresGroup
 */
export interface V0040AssocMaxTresGroup {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTresGroup
     */
    'minutes'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTresGroup
     */
    'active'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxTresMinutes
 */
export interface V0040AssocMaxTresMinutes {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTresMinutes
     */
    'total'?: Array<V0040Tres>;
    /**
     * 
     * @type {V0040QosLimitsMinTresPer}
     * @memberof V0040AssocMaxTresMinutes
     */
    'per'?: V0040QosLimitsMinTresPer;
}
/**
 * 
 * @export
 * @interface V0040AssocMaxTresPer
 */
export interface V0040AssocMaxTresPer {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTresPer
     */
    'job'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocMaxTresPer
     */
    'node'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040AssocMin
 */
export interface V0040AssocMin {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocMin
     */
    'priority_threshold'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040AssocRecSet
 */
export interface V0040AssocRecSet {
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0040AssocRecSet
     */
    'comment'?: string;
    /**
     * Default QOS
     * @type {string}
     * @memberof V0040AssocRecSet
     */
    'defaultqos'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'grpjobs'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'grpjobsaccrue'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'grpsubmitjobs'?: V0040Uint32NoVal;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'grptres'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'grptresmins'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'grptresrunmins'?: Array<V0040Tres>;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'grpwall'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'maxjobs'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'maxjobsaccrue'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'maxsubmitjobs'?: V0040Uint32NoVal;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'maxtresminsperjob'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'maxtresrunmins'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'maxtresperjob'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040AssocRecSet
     */
    'maxtrespernode'?: Array<V0040Tres>;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'maxwalldurationperjob'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'minpriothresh'?: V0040Uint32NoVal;
    /**
     * Name of parent account
     * @type {string}
     * @memberof V0040AssocRecSet
     */
    'parent'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocRecSet
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * List of QOS names
     * @type {Array<string>}
     * @memberof V0040AssocRecSet
     */
    'qoslevel'?: Array<string>;
    /**
     * Allocated shares used for fairshare calculation
     * @type {number}
     * @memberof V0040AssocRecSet
     */
    'fairshare'?: number;
}
/**
 * 
 * @export
 * @interface V0040AssocSharesObjWrap
 */
export interface V0040AssocSharesObjWrap {
    /**
     * Association ID
     * @type {number}
     * @memberof V0040AssocSharesObjWrap
     */
    'id'?: number;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040AssocSharesObjWrap
     */
    'cluster'?: string;
    /**
     * Share name
     * @type {string}
     * @memberof V0040AssocSharesObjWrap
     */
    'name'?: string;
    /**
     * Parent name
     * @type {string}
     * @memberof V0040AssocSharesObjWrap
     */
    'parent'?: string;
    /**
     * Partition name
     * @type {string}
     * @memberof V0040AssocSharesObjWrap
     */
    'partition'?: string;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040AssocSharesObjWrap
     */
    'shares_normalized'?: V0040Float64NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040AssocSharesObjWrap
     */
    'shares'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040AssocSharesObjWrapTres}
     * @memberof V0040AssocSharesObjWrap
     */
    'tres'?: V0040AssocSharesObjWrapTres;
    /**
     * Effective, normalized usage
     * @type {number}
     * @memberof V0040AssocSharesObjWrap
     */
    'effective_usage'?: number;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040AssocSharesObjWrap
     */
    'usage_normalized'?: V0040Float64NoVal;
    /**
     * Measure of tresbillableunits usage
     * @type {number}
     * @memberof V0040AssocSharesObjWrap
     */
    'usage'?: number;
    /**
     * 
     * @type {V0040AssocSharesObjWrapFairshare}
     * @memberof V0040AssocSharesObjWrap
     */
    'fairshare'?: V0040AssocSharesObjWrapFairshare;
    /**
     * User or account association
     * @type {Array<string>}
     * @memberof V0040AssocSharesObjWrap
     */
    'type'?: Array<V0040AssocSharesObjWrapTypeEnum>;
}

export const V0040AssocSharesObjWrapTypeEnum = {
    User: 'USER',
    Association: 'ASSOCIATION'
} as const;

export type V0040AssocSharesObjWrapTypeEnum = typeof V0040AssocSharesObjWrapTypeEnum[keyof typeof V0040AssocSharesObjWrapTypeEnum];

/**
 * 
 * @export
 * @interface V0040AssocSharesObjWrapFairshare
 */
export interface V0040AssocSharesObjWrapFairshare {
    /**
     * Fairshare factor
     * @type {number}
     * @memberof V0040AssocSharesObjWrapFairshare
     */
    'factor'?: number;
    /**
     * Fairshare factor at this level; stored on an assoc as a long double, but that is not needed for display in sshare
     * @type {number}
     * @memberof V0040AssocSharesObjWrapFairshare
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface V0040AssocSharesObjWrapTres
 */
export interface V0040AssocSharesObjWrapTres {
    /**
     * 
     * @type {Array<V0040SharesUint64Tres>}
     * @memberof V0040AssocSharesObjWrapTres
     */
    'run_seconds'?: Array<V0040SharesUint64Tres>;
    /**
     * 
     * @type {Array<V0040SharesUint64Tres>}
     * @memberof V0040AssocSharesObjWrapTres
     */
    'group_minutes'?: Array<V0040SharesUint64Tres>;
    /**
     * 
     * @type {Array<V0040SharesFloat128Tres>}
     * @memberof V0040AssocSharesObjWrapTres
     */
    'usage'?: Array<V0040SharesFloat128Tres>;
}
/**
 * 
 * @export
 * @interface V0040AssocShort
 */
export interface V0040AssocShort {
    /**
     * Account
     * @type {string}
     * @memberof V0040AssocShort
     */
    'account'?: string;
    /**
     * Cluster
     * @type {string}
     * @memberof V0040AssocShort
     */
    'cluster'?: string;
    /**
     * Partition
     * @type {string}
     * @memberof V0040AssocShort
     */
    'partition'?: string;
    /**
     * User name
     * @type {string}
     * @memberof V0040AssocShort
     */
    'user': string;
    /**
     * Numeric association ID
     * @type {number}
     * @memberof V0040AssocShort
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface V0040BfExitFields
 */
export interface V0040BfExitFields {
    /**
     * Reached end of queue
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'end_job_queue'?: number;
    /**
     * Reached number of jobs allowed to start
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'bf_max_job_start'?: number;
    /**
     * Reached number of jobs allowed to be tested
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'bf_max_job_test'?: number;
    /**
     * Reached maximum allowed scheduler time
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'bf_max_time'?: number;
    /**
     * Reached table size limit
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'bf_node_space_size'?: number;
    /**
     * System state changed
     * @type {number}
     * @memberof V0040BfExitFields
     */
    'state_changed'?: number;
}
/**
 * 
 * @export
 * @interface V0040ClusterRec
 */
export interface V0040ClusterRec {
    /**
     * 
     * @type {V0040ClusterRecController}
     * @memberof V0040ClusterRec
     */
    'controller'?: V0040ClusterRecController;
    /**
     * Flags
     * @type {Array<string>}
     * @memberof V0040ClusterRec
     */
    'flags'?: Array<V0040ClusterRecFlagsEnum>;
    /**
     * ClusterName
     * @type {string}
     * @memberof V0040ClusterRec
     */
    'name'?: string;
    /**
     * Node names
     * @type {string}
     * @memberof V0040ClusterRec
     */
    'nodes'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0040ClusterRec
     */
    'select_plugin'?: string;
    /**
     * 
     * @type {V0040ClusterRecAssociations}
     * @memberof V0040ClusterRec
     */
    'associations'?: V0040ClusterRecAssociations;
    /**
     * RPC version used in the cluster
     * @type {number}
     * @memberof V0040ClusterRec
     */
    'rpc_version'?: number;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040ClusterRec
     */
    'tres'?: Array<V0040Tres>;
}

export const V0040ClusterRecFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;

export type V0040ClusterRecFlagsEnum = typeof V0040ClusterRecFlagsEnum[keyof typeof V0040ClusterRecFlagsEnum];

/**
 * 
 * @export
 * @interface V0040ClusterRecAssociations
 */
export interface V0040ClusterRecAssociations {
    /**
     * 
     * @type {V0040AssocShort}
     * @memberof V0040ClusterRecAssociations
     */
    'root'?: V0040AssocShort;
}
/**
 * 
 * @export
 * @interface V0040ClusterRecController
 */
export interface V0040ClusterRecController {
    /**
     * ControlHost
     * @type {string}
     * @memberof V0040ClusterRecController
     */
    'host'?: string;
    /**
     * ControlPort
     * @type {number}
     * @memberof V0040ClusterRecController
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface V0040ControllerPing
 */
export interface V0040ControllerPing {
    /**
     * Target for ping
     * @type {string}
     * @memberof V0040ControllerPing
     */
    'hostname'?: string;
    /**
     * Ping result
     * @type {string}
     * @memberof V0040ControllerPing
     */
    'pinged'?: string;
    /**
     * Number of microseconds it took to successfully ping or timeout
     * @type {number}
     * @memberof V0040ControllerPing
     */
    'latency'?: number;
    /**
     * The operating mode of the responding slurmctld
     * @type {string}
     * @memberof V0040ControllerPing
     */
    'mode'?: string;
}
/**
 * 
 * @export
 * @interface V0040Coord
 */
export interface V0040Coord {
    /**
     * User name
     * @type {string}
     * @memberof V0040Coord
     */
    'name': string;
    /**
     * Indicates whether the coordinator was directly assigned to this account
     * @type {boolean}
     * @memberof V0040Coord
     */
    'direct'?: boolean;
}
/**
 * 
 * @export
 * @interface V0040CronEntry
 */
export interface V0040CronEntry {
    /**
     * Flags
     * @type {Array<string>}
     * @memberof V0040CronEntry
     */
    'flags'?: Array<V0040CronEntryFlagsEnum>;
    /**
     * Ranged string specifying eligible minute values (e.g. 0-10,50)
     * @type {string}
     * @memberof V0040CronEntry
     */
    'minute'?: string;
    /**
     * Ranged string specifying eligible hour values (e.g. 0-5,23)
     * @type {string}
     * @memberof V0040CronEntry
     */
    'hour'?: string;
    /**
     * Ranged string specifying eligible day of month values (e.g. 0-10,29)
     * @type {string}
     * @memberof V0040CronEntry
     */
    'day_of_month'?: string;
    /**
     * Ranged string specifying eligible month values (e.g. 0-5,12)
     * @type {string}
     * @memberof V0040CronEntry
     */
    'month'?: string;
    /**
     * Ranged string specifying eligible day of week values (e.g.0-3,7)
     * @type {string}
     * @memberof V0040CronEntry
     */
    'day_of_week'?: string;
    /**
     * Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
     * @type {string}
     * @memberof V0040CronEntry
     */
    'specification'?: string;
    /**
     * Command to run
     * @type {string}
     * @memberof V0040CronEntry
     */
    'command'?: string;
    /**
     * 
     * @type {V0040CronEntryLine}
     * @memberof V0040CronEntry
     */
    'line'?: V0040CronEntryLine;
}

export const V0040CronEntryFlagsEnum = {
    Minute: 'WILD_MINUTE',
    Hour: 'WILD_HOUR',
    DayOfMonth: 'WILD_DAY_OF_MONTH',
    Month: 'WILD_MONTH',
    DayOfWeek: 'WILD_DAY_OF_WEEK'
} as const;

export type V0040CronEntryFlagsEnum = typeof V0040CronEntryFlagsEnum[keyof typeof V0040CronEntryFlagsEnum];

/**
 * 
 * @export
 * @interface V0040CronEntryLine
 */
export interface V0040CronEntryLine {
    /**
     * Start of this entry in file
     * @type {number}
     * @memberof V0040CronEntryLine
     */
    'start'?: number;
    /**
     * End of this entry in file
     * @type {number}
     * @memberof V0040CronEntryLine
     */
    'end'?: number;
}
/**
 * 64 bit floating point number with flags
 * @export
 * @interface V0040Float64NoVal
 */
export interface V0040Float64NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0040Float64NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0040Float64NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0040Float64NoVal
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0040Instance
 */
export interface V0040Instance {
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040Instance
     */
    'cluster'?: string;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040Instance
     */
    'extra'?: string;
    /**
     * Cloud instance ID
     * @type {string}
     * @memberof V0040Instance
     */
    'instance_id'?: string;
    /**
     * Cloud instance type
     * @type {string}
     * @memberof V0040Instance
     */
    'instance_type'?: string;
    /**
     * NodeName
     * @type {string}
     * @memberof V0040Instance
     */
    'node_name'?: string;
    /**
     * 
     * @type {V0040InstanceTime}
     * @memberof V0040Instance
     */
    'time'?: V0040InstanceTime;
}
/**
 * 
 * @export
 * @interface V0040InstanceTime
 */
export interface V0040InstanceTime {
    /**
     * When the instance will end (UNIX timestamp)
     * @type {number}
     * @memberof V0040InstanceTime
     */
    'time_end'?: number;
    /**
     * When the instance will start (UNIX timestamp)
     * @type {number}
     * @memberof V0040InstanceTime
     */
    'time_start'?: number;
}
/**
 * 
 * @export
 * @interface V0040Job
 */
export interface V0040Job {
    /**
     * Account the job ran under
     * @type {string}
     * @memberof V0040Job
     */
    'account'?: string;
    /**
     * 
     * @type {V0040JobComment}
     * @memberof V0040Job
     */
    'comment'?: V0040JobComment;
    /**
     * List of nodes allocated to the job
     * @type {number}
     * @memberof V0040Job
     */
    'allocation_nodes'?: number;
    /**
     * 
     * @type {V0040JobArray}
     * @memberof V0040Job
     */
    'array'?: V0040JobArray;
    /**
     * 
     * @type {V0040AssocShort}
     * @memberof V0040Job
     */
    'association'?: V0040AssocShort;
    /**
     * The name of the block to be used (used with Blue Gene systems)
     * @type {string}
     * @memberof V0040Job
     */
    'block'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040Job
     */
    'cluster'?: string;
    /**
     * Feature(s) the job requested as a constraint
     * @type {string}
     * @memberof V0040Job
     */
    'constraints'?: string;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0040Job
     */
    'container'?: string;
    /**
     * 
     * @type {V0040ProcessExitCodeVerbose}
     * @memberof V0040Job
     */
    'derived_exit_code'?: V0040ProcessExitCodeVerbose;
    /**
     * 
     * @type {V0040JobTime}
     * @memberof V0040Job
     */
    'time'?: V0040JobTime;
    /**
     * 
     * @type {V0040ProcessExitCodeVerbose}
     * @memberof V0040Job
     */
    'exit_code'?: V0040ProcessExitCodeVerbose;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040Job
     */
    'extra'?: string;
    /**
     * Name of node that caused job failure
     * @type {string}
     * @memberof V0040Job
     */
    'failed_node'?: string;
    /**
     * Flags associated with the job
     * @type {Array<string>}
     * @memberof V0040Job
     */
    'flags'?: Array<V0040JobFlagsEnum>;
    /**
     * Group ID of the user that owns the job
     * @type {string}
     * @memberof V0040Job
     */
    'group'?: string;
    /**
     * 
     * @type {V0040JobHet}
     * @memberof V0040Job
     */
    'het'?: V0040JobHet;
    /**
     * Job ID
     * @type {number}
     * @memberof V0040Job
     */
    'job_id'?: number;
    /**
     * Job name
     * @type {string}
     * @memberof V0040Job
     */
    'name'?: string;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0040Job
     */
    'licenses'?: string;
    /**
     * 
     * @type {V0040JobMcs}
     * @memberof V0040Job
     */
    'mcs'?: V0040JobMcs;
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0040Job
     */
    'nodes'?: string;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0040Job
     */
    'partition'?: string;
    /**
     * Job held
     * @type {boolean}
     * @memberof V0040Job
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040Job
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0040Job
     */
    'qos'?: string;
    /**
     * 
     * @type {V0040JobRequired}
     * @memberof V0040Job
     */
    'required'?: V0040JobRequired;
    /**
     * User ID that requested termination of the job
     * @type {string}
     * @memberof V0040Job
     */
    'kill_request_user'?: string;
    /**
     * 
     * @type {V0040JobReservation}
     * @memberof V0040Job
     */
    'reservation'?: V0040JobReservation;
    /**
     * Job batch script; only the first component in a HetJob is populated or honored
     * @type {string}
     * @memberof V0040Job
     */
    'script'?: string;
    /**
     * 
     * @type {V0040JobState}
     * @memberof V0040Job
     */
    'state'?: V0040JobState;
    /**
     * 
     * @type {Array<V0040Step>}
     * @memberof V0040Job
     */
    'steps'?: Array<V0040Step>;
    /**
     * Command used to submit the job
     * @type {string}
     * @memberof V0040Job
     */
    'submit_line'?: string;
    /**
     * 
     * @type {V0040JobTres}
     * @memberof V0040Job
     */
    'tres'?: V0040JobTres;
    /**
     * Generic resources used by job
     * @type {string}
     * @memberof V0040Job
     */
    'used_gres'?: string;
    /**
     * User that owns the job
     * @type {string}
     * @memberof V0040Job
     */
    'user'?: string;
    /**
     * 
     * @type {V0040WckeyTagStruct}
     * @memberof V0040Job
     */
    'wckey'?: V0040WckeyTagStruct;
    /**
     * Path to current working directory
     * @type {string}
     * @memberof V0040Job
     */
    'working_directory'?: string;
}

export const V0040JobFlagsEnum = {
    None: 'NONE',
    ClearScheduling: 'CLEAR_SCHEDULING',
    NotSet: 'NOT_SET',
    StartedOnSubmit: 'STARTED_ON_SUBMIT',
    StartedOnSchedule: 'STARTED_ON_SCHEDULE',
    StartedOnBackfill: 'STARTED_ON_BACKFILL',
    StartReceived: 'START_RECEIVED'
} as const;

export type V0040JobFlagsEnum = typeof V0040JobFlagsEnum[keyof typeof V0040JobFlagsEnum];

/**
 * 
 * @export
 * @interface V0040JobArray
 */
export interface V0040JobArray {
    /**
     * Job ID of job array, or 0 if N/A
     * @type {number}
     * @memberof V0040JobArray
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0040JobArrayLimits}
     * @memberof V0040JobArray
     */
    'limits'?: V0040JobArrayLimits;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobArray
     */
    'task_id'?: V0040Uint32NoVal;
    /**
     * String expression of task IDs in this record
     * @type {string}
     * @memberof V0040JobArray
     */
    'task'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobArrayLimits
 */
export interface V0040JobArrayLimits {
    /**
     * 
     * @type {V0040JobArrayLimitsMax}
     * @memberof V0040JobArrayLimits
     */
    'max'?: V0040JobArrayLimitsMax;
}
/**
 * 
 * @export
 * @interface V0040JobArrayLimitsMax
 */
export interface V0040JobArrayLimitsMax {
    /**
     * 
     * @type {V0040JobArrayLimitsMaxRunning}
     * @memberof V0040JobArrayLimitsMax
     */
    'running'?: V0040JobArrayLimitsMaxRunning;
}
/**
 * 
 * @export
 * @interface V0040JobArrayLimitsMaxRunning
 */
export interface V0040JobArrayLimitsMaxRunning {
    /**
     * Maximum number of simultaneously running tasks, 0 if no limit
     * @type {number}
     * @memberof V0040JobArrayLimitsMaxRunning
     */
    'tasks'?: number;
}
/**
 * 
 * @export
 * @interface V0040JobArrayResponseMsgEntry
 */
export interface V0040JobArrayResponseMsgEntry {
    /**
     * Job ID for updated Job
     * @type {number}
     * @memberof V0040JobArrayResponseMsgEntry
     */
    'job_id'?: number;
    /**
     * Step ID for updated Job
     * @type {string}
     * @memberof V0040JobArrayResponseMsgEntry
     */
    'step_id'?: string;
    /**
     * Verbose update status or error
     * @type {string}
     * @memberof V0040JobArrayResponseMsgEntry
     */
    'error'?: string;
    /**
     * Verbose update status or error
     * @type {number}
     * @memberof V0040JobArrayResponseMsgEntry
     */
    'error_code'?: number;
    /**
     * Update response message
     * @type {string}
     * @memberof V0040JobArrayResponseMsgEntry
     */
    'why'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobComment
 */
export interface V0040JobComment {
    /**
     * Arbitrary comment made by administrator
     * @type {string}
     * @memberof V0040JobComment
     */
    'administrator'?: string;
    /**
     * Arbitrary comment made by user
     * @type {string}
     * @memberof V0040JobComment
     */
    'job'?: string;
    /**
     * Arbitrary comment from slurmctld
     * @type {string}
     * @memberof V0040JobComment
     */
    'system'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobDescMsg
 */
export interface V0040JobDescMsg {
    /**
     * Account associated with the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'account'?: string;
    /**
     * Job accounting and profiling sampling intervals in seconds
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'account_gather_frequency'?: string;
    /**
     * Arbitrary comment made by administrator
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'admin_comment'?: string;
    /**
     * Local node making the resource allocation
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'allocation_node_list'?: string;
    /**
     * Port to send allocation confirmation to
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'allocation_node_port'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'argv'?: Array<string>;
    /**
     * Job array index value specification
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'array'?: string;
    /**
     * Features required for batch script\'s node
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'batch_features'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsg
     */
    'begin_time'?: V0040Uint64NoVal;
    /**
     * Job flags
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'flags'?: Array<V0040JobDescMsgFlagsEnum>;
    /**
     * Burst buffer specifications
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'burst_buffer'?: string;
    /**
     * Clusters that a federated job can run on
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'clusters'?: string;
    /**
     * Required features that a federated cluster must have to have a sibling job submitted to it
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'cluster_constraint'?: string;
    /**
     * Arbitrary comment made by user
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'comment'?: string;
    /**
     * True if job requires contiguous nodes
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'contiguous'?: boolean;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'container'?: string;
    /**
     * OCI container ID
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'container_id'?: string;
    /**
     * Cores per socket required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'cores_per_socket'?: number;
    /**
     * Specialized core count
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'core_specification'?: number;
    /**
     * Specialized thread count
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'thread_specification'?: number;
    /**
     * Method for binding tasks to allocated CPUs
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'cpu_binding'?: string;
    /**
     * Flags for CPU binding
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'cpu_binding_flags'?: Array<V0040JobDescMsgCpuBindingFlagsEnum>;
    /**
     * Requested CPU frequency range <p1>[-p2][:p3]
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'cpu_frequency'?: string;
    /**
     * Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'cpus_per_tres'?: string;
    /**
     * 
     * @type {V0040CronEntry}
     * @memberof V0040JobDescMsg
     */
    'crontab'?: V0040CronEntry;
    /**
     * Latest time that the job may start (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'deadline'?: number;
    /**
     * Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'delay_boot'?: number;
    /**
     * Other jobs that must meet certain criteria before this job can start
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'dependency'?: string;
    /**
     * Expected end time (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'end_time'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'environment'?: Array<string>;
    /**
     * 
     * @type {V0040JobDescMsgRlimits}
     * @memberof V0040JobDescMsg
     */
    'rlimits'?: V0040JobDescMsgRlimits;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'excluded_nodes'?: Array<string>;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'extra'?: string;
    /**
     * Comma separated list of features that are required
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'constraints'?: string;
    /**
     * Group ID of the user that owns the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'group_id'?: string;
    /**
     * Unique sequence number applied to this component of the heterogeneous job
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'hetjob_group'?: number;
    /**
     * If true, exit if resources are not available within the time period specified
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'immediate'?: boolean;
    /**
     * Job ID
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'job_id'?: number;
    /**
     * If true, kill job on node failure
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'kill_on_node_fail'?: boolean;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'licenses'?: string;
    /**
     * Mail event type(s)
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'mail_type'?: Array<V0040JobDescMsgMailTypeEnum>;
    /**
     * User to receive email notifications
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'mail_user'?: string;
    /**
     * Multi-Category Security label on the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'mcs_label'?: string;
    /**
     * Binding map for map/mask_cpu
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'memory_binding'?: string;
    /**
     * Method for binding tasks to memory
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'memory_binding_type'?: Array<V0040JobDescMsgMemoryBindingTypeEnum>;
    /**
     * Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'memory_per_tres'?: string;
    /**
     * Job name
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'name'?: string;
    /**
     * Network specs for job step
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'network'?: string;
    /**
     * Requested job priority change
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'nice'?: number;
    /**
     * Number of tasks
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'tasks'?: number;
    /**
     * Open mode used for stdout and stderr files
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'open_mode'?: Array<V0040JobDescMsgOpenModeEnum>;
    /**
     * Port to send various notification msg to
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'reserve_ports'?: number;
    /**
     * Overcommit resources
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'overcommit'?: boolean;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'partition'?: string;
    /**
     * Plane size specification when distribution specifies plane
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'distribution_plane_size'?: number;
    /**
     * removed field
     * @type {Array<any>}
     * @memberof V0040JobDescMsg
     * @deprecated
     */
    'power_flags'?: Array<any>;
    /**
     * Comma separated list of features that are preferred but not required
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'prefer'?: string;
    /**
     * Job held
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobDescMsg
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * Profile used by the acct_gather_profile plugin
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'profile'?: Array<V0040JobDescMsgProfileEnum>;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'qos'?: string;
    /**
     * Node reboot requested before start
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'reboot'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'required_nodes'?: Array<string>;
    /**
     * Determines whether the job may be requeued
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'requeue'?: boolean;
    /**
     * Name of reservation to use
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'reservation'?: string;
    /**
     * Job batch script; only the first component in a HetJob is populated or honored
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'script'?: string;
    /**
     * How the job can share resources with other jobs, if at all
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'shared'?: Array<V0040JobDescMsgSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'exclusive'?: Array<V0040JobDescMsgExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'oversubscribe'?: boolean;
    /**
     * Site-specific priority factor
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'site_factor'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'spank_environment'?: Array<string>;
    /**
     * Layout
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'distribution'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobDescMsg
     */
    'time_limit'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobDescMsg
     */
    'time_minimum'?: V0040Uint32NoVal;
    /**
     * Task to TRES binding directives
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_bind'?: string;
    /**
     * TRES frequency directives
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_freq'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_per_job'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every node
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_per_node'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every socket
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_per_socket'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every task
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'tres_per_task'?: string;
    /**
     * User ID that owns the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'user_id'?: string;
    /**
     * If true, wait to start until after all nodes have booted
     * @type {boolean}
     * @memberof V0040JobDescMsg
     */
    'wait_all_nodes'?: boolean;
    /**
     * Flags related to job signals
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'kill_warning_flags'?: Array<V0040JobDescMsgKillWarningFlagsEnum>;
    /**
     * Signal to send when approaching end time (e.g. \"10\" or \"USR1\")
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'kill_warning_signal'?: string;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobDescMsg
     */
    'kill_warning_delay'?: V0040Uint16NoVal;
    /**
     * Working directory to use for the job
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'current_working_directory'?: string;
    /**
     * Number of CPUs required by each task
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'cpus_per_task'?: number;
    /**
     * Minimum number of CPUs required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'minimum_cpus'?: number;
    /**
     * Maximum number of CPUs required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'maximum_cpus'?: number;
    /**
     * Node count range specification (e.g. 1-15:4)
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'nodes'?: string;
    /**
     * Minimum node count
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'minimum_nodes'?: number;
    /**
     * Maximum node count
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'maximum_nodes'?: number;
    /**
     * Boards per node required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'minimum_boards_per_node'?: number;
    /**
     * Sockets per board required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'minimum_sockets_per_board'?: number;
    /**
     * Sockets per node required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'sockets_per_node'?: number;
    /**
     * Threads per core required
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'threads_per_core'?: number;
    /**
     * Number of tasks to invoke on each node
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'tasks_per_node'?: number;
    /**
     * Number of tasks to invoke on each socket
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'tasks_per_socket'?: number;
    /**
     * Number of tasks to invoke on each core
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'tasks_per_core'?: number;
    /**
     * Number of tasks to invoke on each board
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'tasks_per_board'?: number;
    /**
     * Number of tasks that can access each GPU
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'ntasks_per_tres'?: number;
    /**
     * Minimum number of CPUs per node
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'minimum_cpus_per_node'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsg
     */
    'memory_per_cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsg
     */
    'memory_per_node'?: V0040Uint64NoVal;
    /**
     * Minimum tmp disk space required per node
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'temporary_disk_per_node'?: number;
    /**
     * SELinux context
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'selinux_context'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobDescMsg
     */
    'required_switches'?: V0040Uint32NoVal;
    /**
     * Path to stderr file
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'standard_error'?: string;
    /**
     * Path to stdin file
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'standard_input'?: string;
    /**
     * Path to stdout file
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'standard_output'?: string;
    /**
     * Maximum time to wait for switches in seconds
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'wait_for_switch'?: number;
    /**
     * Workload characterization key
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'wckey'?: string;
    /**
     * X11 forwarding options
     * @type {Array<string>}
     * @memberof V0040JobDescMsg
     */
    'x11'?: Array<V0040JobDescMsgX11Enum>;
    /**
     * Magic cookie for X11 forwarding
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'x11_magic_cookie'?: string;
    /**
     * Hostname or UNIX socket if x11_target_port=0
     * @type {string}
     * @memberof V0040JobDescMsg
     */
    'x11_target_host'?: string;
    /**
     * TCP port
     * @type {number}
     * @memberof V0040JobDescMsg
     */
    'x11_target_port'?: number;
}

export const V0040JobDescMsgFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GresBindingDisabled: 'GRES_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    SaveBatchScript: 'SAVE_BATCH_SCRIPT',
    GresOneTaskPerSharing: 'GRES_ONE_TASK_PER_SHARING',
    GresMultipleTasksPerSharing: 'GRES_MULTIPLE_TASKS_PER_SHARING',
    GresAllowTaskSharing: 'GRES_ALLOW_TASK_SHARING'
} as const;

export type V0040JobDescMsgFlagsEnum = typeof V0040JobDescMsgFlagsEnum[keyof typeof V0040JobDescMsgFlagsEnum];
export const V0040JobDescMsgCpuBindingFlagsEnum = {
    CpuBindToThreads: 'CPU_BIND_TO_THREADS',
    CpuBindToCores: 'CPU_BIND_TO_CORES',
    CpuBindToSockets: 'CPU_BIND_TO_SOCKETS',
    CpuBindToLdoms: 'CPU_BIND_TO_LDOMS',
    CpuBindNone: 'CPU_BIND_NONE',
    CpuBindRank: 'CPU_BIND_RANK',
    CpuBindMap: 'CPU_BIND_MAP',
    CpuBindMask: 'CPU_BIND_MASK',
    CpuBindLdrank: 'CPU_BIND_LDRANK',
    CpuBindLdmap: 'CPU_BIND_LDMAP',
    CpuBindLdmask: 'CPU_BIND_LDMASK',
    Verbose: 'VERBOSE',
    CpuBindOneThreadPerCore: 'CPU_BIND_ONE_THREAD_PER_CORE'
} as const;

export type V0040JobDescMsgCpuBindingFlagsEnum = typeof V0040JobDescMsgCpuBindingFlagsEnum[keyof typeof V0040JobDescMsgCpuBindingFlagsEnum];
export const V0040JobDescMsgMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0040JobDescMsgMailTypeEnum = typeof V0040JobDescMsgMailTypeEnum[keyof typeof V0040JobDescMsgMailTypeEnum];
export const V0040JobDescMsgMemoryBindingTypeEnum = {
    None: 'NONE',
    Rank: 'RANK',
    Map: 'MAP',
    Mask: 'MASK',
    Local: 'LOCAL',
    Verbose: 'VERBOSE',
    Sort: 'SORT',
    Prefer: 'PREFER'
} as const;

export type V0040JobDescMsgMemoryBindingTypeEnum = typeof V0040JobDescMsgMemoryBindingTypeEnum[keyof typeof V0040JobDescMsgMemoryBindingTypeEnum];
export const V0040JobDescMsgOpenModeEnum = {
    Append: 'APPEND',
    Truncate: 'TRUNCATE'
} as const;

export type V0040JobDescMsgOpenModeEnum = typeof V0040JobDescMsgOpenModeEnum[keyof typeof V0040JobDescMsgOpenModeEnum];
export const V0040JobDescMsgProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0040JobDescMsgProfileEnum = typeof V0040JobDescMsgProfileEnum[keyof typeof V0040JobDescMsgProfileEnum];
export const V0040JobDescMsgSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0040JobDescMsgSharedEnum = typeof V0040JobDescMsgSharedEnum[keyof typeof V0040JobDescMsgSharedEnum];
export const V0040JobDescMsgExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0040JobDescMsgExclusiveEnum = typeof V0040JobDescMsgExclusiveEnum[keyof typeof V0040JobDescMsgExclusiveEnum];
export const V0040JobDescMsgKillWarningFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    NoCronJobs: 'NO_CRON_JOBS',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;

export type V0040JobDescMsgKillWarningFlagsEnum = typeof V0040JobDescMsgKillWarningFlagsEnum[keyof typeof V0040JobDescMsgKillWarningFlagsEnum];
export const V0040JobDescMsgX11Enum = {
    ForwardAllNodes: 'FORWARD_ALL_NODES',
    BatchNode: 'BATCH_NODE',
    FirstNode: 'FIRST_NODE',
    LastNode: 'LAST_NODE'
} as const;

export type V0040JobDescMsgX11Enum = typeof V0040JobDescMsgX11Enum[keyof typeof V0040JobDescMsgX11Enum];

/**
 * 
 * @export
 * @interface V0040JobDescMsgRlimits
 */
export interface V0040JobDescMsgRlimits {
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'fsize'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'data'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'stack'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'core'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'rss'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'nproc'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'nofile'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'memlock'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobDescMsgRlimits
     */
    'as'?: V0040Uint64NoVal;
}
/**
 * 
 * @export
 * @interface V0040JobHet
 */
export interface V0040JobHet {
    /**
     * Heterogeneous job ID, if applicable
     * @type {number}
     * @memberof V0040JobHet
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobHet
     */
    'job_offset'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040JobInfo
 */
export interface V0040JobInfo {
    /**
     * Account associated with the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'account'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'accrue_time'?: V0040Uint64NoVal;
    /**
     * Arbitrary comment made by administrator
     * @type {string}
     * @memberof V0040JobInfo
     */
    'admin_comment'?: string;
    /**
     * Local node making the resource allocation
     * @type {string}
     * @memberof V0040JobInfo
     */
    'allocating_node'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'array_job_id'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'array_task_id'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'array_max_tasks'?: V0040Uint32NoVal;
    /**
     * String expression of task IDs in this record
     * @type {string}
     * @memberof V0040JobInfo
     */
    'array_task_string'?: string;
    /**
     * Unique identifier for the association
     * @type {number}
     * @memberof V0040JobInfo
     */
    'association_id'?: number;
    /**
     * Features required for batch script\'s node
     * @type {string}
     * @memberof V0040JobInfo
     */
    'batch_features'?: string;
    /**
     * True if batch job
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'batch_flag'?: boolean;
    /**
     * Name of host running batch script
     * @type {string}
     * @memberof V0040JobInfo
     */
    'batch_host'?: string;
    /**
     * Job flags
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'flags'?: Array<V0040JobInfoFlagsEnum>;
    /**
     * Burst buffer specifications
     * @type {string}
     * @memberof V0040JobInfo
     */
    'burst_buffer'?: string;
    /**
     * Burst buffer state details
     * @type {string}
     * @memberof V0040JobInfo
     */
    'burst_buffer_state'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040JobInfo
     */
    'cluster'?: string;
    /**
     * List of required cluster features
     * @type {string}
     * @memberof V0040JobInfo
     */
    'cluster_features'?: string;
    /**
     * Executed command
     * @type {string}
     * @memberof V0040JobInfo
     */
    'command'?: string;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0040JobInfo
     */
    'comment'?: string;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0040JobInfo
     */
    'container'?: string;
    /**
     * OCI container ID
     * @type {string}
     * @memberof V0040JobInfo
     */
    'container_id'?: string;
    /**
     * True if job requires contiguous nodes
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'contiguous'?: boolean;
    /**
     * Specialized core count
     * @type {number}
     * @memberof V0040JobInfo
     */
    'core_spec'?: number;
    /**
     * Specialized thread count
     * @type {number}
     * @memberof V0040JobInfo
     */
    'thread_spec'?: number;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'cores_per_socket'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040JobInfo
     */
    'billable_tres'?: V0040Float64NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'cpus_per_task'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'cpu_frequency_minimum'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'cpu_frequency_maximum'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'cpu_frequency_governor'?: V0040Uint32NoVal;
    /**
     * Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0040JobInfo
     */
    'cpus_per_tres'?: string;
    /**
     * Time specification for scrontab job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'cron'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'deadline'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'delay_boot'?: V0040Uint32NoVal;
    /**
     * Other jobs that must meet certain criteria before this job can start
     * @type {string}
     * @memberof V0040JobInfo
     */
    'dependency'?: string;
    /**
     * 
     * @type {V0040ProcessExitCodeVerbose}
     * @memberof V0040JobInfo
     */
    'derived_exit_code'?: V0040ProcessExitCodeVerbose;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'eligible_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'end_time'?: V0040Uint64NoVal;
    /**
     * Comma separated list of nodes that may not be used
     * @type {string}
     * @memberof V0040JobInfo
     */
    'excluded_nodes'?: string;
    /**
     * 
     * @type {V0040ProcessExitCodeVerbose}
     * @memberof V0040JobInfo
     */
    'exit_code'?: V0040ProcessExitCodeVerbose;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040JobInfo
     */
    'extra'?: string;
    /**
     * Name of node that caused job failure
     * @type {string}
     * @memberof V0040JobInfo
     */
    'failed_node'?: string;
    /**
     * Comma separated list of features that are required
     * @type {string}
     * @memberof V0040JobInfo
     */
    'features'?: string;
    /**
     * Origin cluster\'s name (when using federation)
     * @type {string}
     * @memberof V0040JobInfo
     */
    'federation_origin'?: string;
    /**
     * Active sibling job names
     * @type {string}
     * @memberof V0040JobInfo
     */
    'federation_siblings_active'?: string;
    /**
     * Viable sibling job names
     * @type {string}
     * @memberof V0040JobInfo
     */
    'federation_siblings_viable'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'gres_detail'?: Array<string>;
    /**
     * Group ID of the user that owns the job
     * @type {number}
     * @memberof V0040JobInfo
     */
    'group_id'?: number;
    /**
     * Group name of the user that owns the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'group_name'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'het_job_id'?: V0040Uint32NoVal;
    /**
     * Job ID range for all heterogeneous job components
     * @type {string}
     * @memberof V0040JobInfo
     */
    'het_job_id_set'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'het_job_offset'?: V0040Uint32NoVal;
    /**
     * Job ID
     * @type {number}
     * @memberof V0040JobInfo
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0040JobRes}
     * @memberof V0040JobInfo
     */
    'job_resources'?: V0040JobRes;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'job_size_str'?: Array<string>;
    /**
     * Current state
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'job_state'?: Array<V0040JobInfoJobStateEnum>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'last_sched_evaluation'?: V0040Uint64NoVal;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'licenses'?: string;
    /**
     * Mail event type(s)
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'mail_type'?: Array<V0040JobInfoMailTypeEnum>;
    /**
     * User to receive email notifications
     * @type {string}
     * @memberof V0040JobInfo
     */
    'mail_user'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'max_cpus'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'max_nodes'?: V0040Uint32NoVal;
    /**
     * Multi-Category Security label on the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'mcs_label'?: string;
    /**
     * Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0040JobInfo
     */
    'memory_per_tres'?: string;
    /**
     * Job name
     * @type {string}
     * @memberof V0040JobInfo
     */
    'name'?: string;
    /**
     * Network specs for the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'network'?: string;
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'nodes'?: string;
    /**
     * Requested job priority change
     * @type {number}
     * @memberof V0040JobInfo
     */
    'nice'?: number;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'tasks_per_core'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'tasks_per_tres'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'tasks_per_node'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'tasks_per_socket'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'tasks_per_board'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'cpus'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'node_count'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'tasks'?: V0040Uint32NoVal;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'partition'?: string;
    /**
     * Feature(s) the job requested but that are not required
     * @type {string}
     * @memberof V0040JobInfo
     */
    'prefer'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'memory_per_cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'memory_per_node'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'minimum_cpus_per_node'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'minimum_tmp_disk_per_node'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040JobInfoPower}
     * @memberof V0040JobInfo
     */
    'power'?: V0040JobInfoPower;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'preempt_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'preemptable_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'pre_sus_time'?: V0040Uint64NoVal;
    /**
     * Job held
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * Profile used by the acct_gather_profile plugin
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'profile'?: Array<V0040JobInfoProfileEnum>;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'qos'?: string;
    /**
     * Node reboot requested before start
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'reboot'?: boolean;
    /**
     * Comma separated list of required nodes
     * @type {string}
     * @memberof V0040JobInfo
     */
    'required_nodes'?: string;
    /**
     * Maximum number of switches (the \'minimum\' in the key is incorrect)
     * @type {number}
     * @memberof V0040JobInfo
     */
    'minimum_switches'?: number;
    /**
     * Determines whether the job may be requeued
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'requeue'?: boolean;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'resize_time'?: V0040Uint64NoVal;
    /**
     * Number of job restarts
     * @type {number}
     * @memberof V0040JobInfo
     */
    'restart_cnt'?: number;
    /**
     * Name of reservation to use
     * @type {string}
     * @memberof V0040JobInfo
     */
    'resv_name'?: string;
    /**
     * List of nodes scheduled to be used for the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'scheduled_nodes'?: string;
    /**
     * SELinux context
     * @type {string}
     * @memberof V0040JobInfo
     */
    'selinux_context'?: string;
    /**
     * How the job can share resources with other jobs, if at all
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'shared'?: Array<V0040JobInfoSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'exclusive'?: Array<V0040JobInfoExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0040JobInfo
     */
    'oversubscribe'?: boolean;
    /**
     * Job details shown in this response
     * @type {Array<string>}
     * @memberof V0040JobInfo
     */
    'show_flags'?: Array<V0040JobInfoShowFlagsEnum>;
    /**
     * Number of sockets per board required
     * @type {number}
     * @memberof V0040JobInfo
     */
    'sockets_per_board'?: number;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'sockets_per_node'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'start_time'?: V0040Uint64NoVal;
    /**
     * Optional details for state_reason
     * @type {string}
     * @memberof V0040JobInfo
     */
    'state_description'?: string;
    /**
     * Reason for current Pending or Failed state
     * @type {string}
     * @memberof V0040JobInfo
     */
    'state_reason'?: string;
    /**
     * Path to stderr file
     * @type {string}
     * @memberof V0040JobInfo
     */
    'standard_error'?: string;
    /**
     * Path to stdin file
     * @type {string}
     * @memberof V0040JobInfo
     */
    'standard_input'?: string;
    /**
     * Path to stdout file
     * @type {string}
     * @memberof V0040JobInfo
     */
    'standard_output'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'submit_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobInfo
     */
    'suspend_time'?: V0040Uint64NoVal;
    /**
     * Arbitrary comment from slurmctld
     * @type {string}
     * @memberof V0040JobInfo
     */
    'system_comment'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'time_limit'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobInfo
     */
    'time_minimum'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040JobInfo
     */
    'threads_per_core'?: V0040Uint16NoVal;
    /**
     * Task to TRES binding directives
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_bind'?: string;
    /**
     * TRES frequency directives
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_freq'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_per_job'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per node
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_per_node'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per socket
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_per_socket'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per task
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_per_task'?: string;
    /**
     * TRES requested by the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_req_str'?: string;
    /**
     * TRES used by the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'tres_alloc_str'?: string;
    /**
     * User ID that owns the job
     * @type {number}
     * @memberof V0040JobInfo
     */
    'user_id'?: number;
    /**
     * User name that owns the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'user_name'?: string;
    /**
     * Maximum time to wait for switches in seconds
     * @type {number}
     * @memberof V0040JobInfo
     */
    'maximum_switch_wait_time'?: number;
    /**
     * Workload characterization key
     * @type {string}
     * @memberof V0040JobInfo
     */
    'wckey'?: string;
    /**
     * Working directory to use for the job
     * @type {string}
     * @memberof V0040JobInfo
     */
    'current_working_directory'?: string;
}

export const V0040JobInfoFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GresBindingDisabled: 'GRES_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    SaveBatchScript: 'SAVE_BATCH_SCRIPT',
    GresOneTaskPerSharing: 'GRES_ONE_TASK_PER_SHARING',
    GresMultipleTasksPerSharing: 'GRES_MULTIPLE_TASKS_PER_SHARING',
    GresAllowTaskSharing: 'GRES_ALLOW_TASK_SHARING'
} as const;

export type V0040JobInfoFlagsEnum = typeof V0040JobInfoFlagsEnum[keyof typeof V0040JobInfoFlagsEnum];
export const V0040JobInfoJobStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0040JobInfoJobStateEnum = typeof V0040JobInfoJobStateEnum[keyof typeof V0040JobInfoJobStateEnum];
export const V0040JobInfoMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0040JobInfoMailTypeEnum = typeof V0040JobInfoMailTypeEnum[keyof typeof V0040JobInfoMailTypeEnum];
export const V0040JobInfoProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0040JobInfoProfileEnum = typeof V0040JobInfoProfileEnum[keyof typeof V0040JobInfoProfileEnum];
export const V0040JobInfoSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0040JobInfoSharedEnum = typeof V0040JobInfoSharedEnum[keyof typeof V0040JobInfoSharedEnum];
export const V0040JobInfoExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs'
} as const;

export type V0040JobInfoExclusiveEnum = typeof V0040JobInfoExclusiveEnum[keyof typeof V0040JobInfoExclusiveEnum];
export const V0040JobInfoShowFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;

export type V0040JobInfoShowFlagsEnum = typeof V0040JobInfoShowFlagsEnum[keyof typeof V0040JobInfoShowFlagsEnum];

/**
 * 
 * @export
 * @interface V0040JobInfoPower
 */
export interface V0040JobInfoPower {
    /**
     * removed field
     * @type {Array<any>}
     * @memberof V0040JobInfoPower
     * @deprecated
     */
    'flags'?: Array<any>;
}
/**
 * 
 * @export
 * @interface V0040JobMcs
 */
export interface V0040JobMcs {
    /**
     * Multi-Category Security label on the job
     * @type {string}
     * @memberof V0040JobMcs
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobRequired
 */
export interface V0040JobRequired {
    /**
     * Minimum number of CPUs required
     * @type {number}
     * @memberof V0040JobRequired
     */
    'CPUs'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobRequired
     */
    'memory_per_cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040JobRequired
     */
    'memory_per_node'?: V0040Uint64NoVal;
}
/**
 * 
 * @export
 * @interface V0040JobRes
 */
export interface V0040JobRes {
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0040JobRes
     */
    'nodes'?: string;
    /**
     * Number of allocated cores
     * @type {number}
     * @memberof V0040JobRes
     */
    'allocated_cores'?: number;
    /**
     * Number of allocated CPUs
     * @type {number}
     * @memberof V0040JobRes
     */
    'allocated_cpus'?: number;
    /**
     * Number of allocated hosts
     * @type {number}
     * @memberof V0040JobRes
     */
    'allocated_hosts'?: number;
    /**
     * job node resources
     * @type {Array<any>}
     * @memberof V0040JobRes
     */
    'allocated_nodes'?: Array<any>;
}
/**
 * 
 * @export
 * @interface V0040JobReservation
 */
export interface V0040JobReservation {
    /**
     * Unique identifier of requested reservation
     * @type {number}
     * @memberof V0040JobReservation
     */
    'id'?: number;
    /**
     * Name of reservation to use
     * @type {string}
     * @memberof V0040JobReservation
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobState
 */
export interface V0040JobState {
    /**
     * Current state
     * @type {Array<string>}
     * @memberof V0040JobState
     */
    'current'?: Array<V0040JobStateCurrentEnum>;
    /**
     * Reason for previous Pending or Failed state
     * @type {string}
     * @memberof V0040JobState
     */
    'reason'?: string;
}

export const V0040JobStateCurrentEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0040JobStateCurrentEnum = typeof V0040JobStateCurrentEnum[keyof typeof V0040JobStateCurrentEnum];

/**
 * 
 * @export
 * @interface V0040JobSubmitReq
 */
export interface V0040JobSubmitReq {
    /**
     * Batch job script; must be specified in first component of jobs or in job if this field is not populated
     * @type {string}
     * @memberof V0040JobSubmitReq
     */
    'script'?: string;
    /**
     * 
     * @type {Array<V0040JobDescMsg>}
     * @memberof V0040JobSubmitReq
     */
    'jobs'?: Array<V0040JobDescMsg>;
    /**
     * 
     * @type {V0040JobDescMsg}
     * @memberof V0040JobSubmitReq
     */
    'job'?: V0040JobDescMsg;
}
/**
 * 
 * @export
 * @interface V0040JobSubmitResponseMsg
 */
export interface V0040JobSubmitResponseMsg {
    /**
     * New job ID
     * @type {number}
     * @memberof V0040JobSubmitResponseMsg
     */
    'job_id'?: number;
    /**
     * New job step ID
     * @type {string}
     * @memberof V0040JobSubmitResponseMsg
     */
    'step_id'?: string;
    /**
     * Error code
     * @type {number}
     * @memberof V0040JobSubmitResponseMsg
     */
    'error_code'?: number;
    /**
     * Error message
     * @type {string}
     * @memberof V0040JobSubmitResponseMsg
     */
    'error'?: string;
    /**
     * Message to user from job_submit plugin
     * @type {string}
     * @memberof V0040JobSubmitResponseMsg
     */
    'job_submit_user_msg'?: string;
}
/**
 * 
 * @export
 * @interface V0040JobTime
 */
export interface V0040JobTime {
    /**
     * Elapsed time in seconds
     * @type {number}
     * @memberof V0040JobTime
     */
    'elapsed'?: number;
    /**
     * Time when the job became eligible to run (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobTime
     */
    'eligible'?: number;
    /**
     * End time (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobTime
     */
    'end'?: number;
    /**
     * Time execution began (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobTime
     */
    'start'?: number;
    /**
     * Time when the job was submitted (UNIX timestamp)
     * @type {number}
     * @memberof V0040JobTime
     */
    'submission'?: number;
    /**
     * Total time in suspended state in seconds
     * @type {number}
     * @memberof V0040JobTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0040JobTimeSystem}
     * @memberof V0040JobTime
     */
    'system'?: V0040JobTimeSystem;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040JobTime
     */
    'limit'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040JobTimeTotal}
     * @memberof V0040JobTime
     */
    'total'?: V0040JobTimeTotal;
    /**
     * 
     * @type {V0040JobTimeUser}
     * @memberof V0040JobTime
     */
    'user'?: V0040JobTimeUser;
}
/**
 * 
 * @export
 * @interface V0040JobTimeSystem
 */
export interface V0040JobTimeSystem {
    /**
     * System CPU time used by the job in seconds
     * @type {number}
     * @memberof V0040JobTimeSystem
     */
    'seconds'?: number;
    /**
     * System CPU time used by the job in microseconds
     * @type {number}
     * @memberof V0040JobTimeSystem
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040JobTimeTotal
 */
export interface V0040JobTimeTotal {
    /**
     * Sum of System and User CPU time used by the job in seconds
     * @type {number}
     * @memberof V0040JobTimeTotal
     */
    'seconds'?: number;
    /**
     * Sum of System and User CPU time used by the job in microseconds
     * @type {number}
     * @memberof V0040JobTimeTotal
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040JobTimeUser
 */
export interface V0040JobTimeUser {
    /**
     * User CPU time used by the job in seconds
     * @type {number}
     * @memberof V0040JobTimeUser
     */
    'seconds'?: number;
    /**
     * User CPU time used by the job in microseconds
     * @type {number}
     * @memberof V0040JobTimeUser
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040JobTres
 */
export interface V0040JobTres {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040JobTres
     */
    'allocated'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040JobTres
     */
    'requested'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040KillJobsMsg
 */
export interface V0040KillJobsMsg {
    /**
     * Filter jobs to a specific account
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'account'?: string;
    /**
     * Filter jobs according to flags
     * @type {Array<string>}
     * @memberof V0040KillJobsMsg
     */
    'flags'?: Array<V0040KillJobsMsgFlagsEnum>;
    /**
     * Filter jobs to a specific name
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'job_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040KillJobsMsg
     */
    'jobs'?: Array<string>;
    /**
     * Filter jobs to a specific partition
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'partition'?: string;
    /**
     * Filter jobs to a specific QOS
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'qos'?: string;
    /**
     * Filter jobs to a specific reservation
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'reservation'?: string;
    /**
     * Signal to send to jobs
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'signal'?: string;
    /**
     * Filter jobs to a specific state
     * @type {Array<string>}
     * @memberof V0040KillJobsMsg
     */
    'job_state'?: Array<V0040KillJobsMsgJobStateEnum>;
    /**
     * Filter jobs to a specific numeric user id
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'user_id'?: string;
    /**
     * Filter jobs to a specific user name
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'user_name'?: string;
    /**
     * Filter jobs to a specific wckey
     * @type {string}
     * @memberof V0040KillJobsMsg
     */
    'wckey'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040KillJobsMsg
     */
    'nodes'?: Array<string>;
}

export const V0040KillJobsMsgFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    NoCronJobs: 'NO_CRON_JOBS',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;

export type V0040KillJobsMsgFlagsEnum = typeof V0040KillJobsMsgFlagsEnum[keyof typeof V0040KillJobsMsgFlagsEnum];
export const V0040KillJobsMsgJobStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0040KillJobsMsgJobStateEnum = typeof V0040KillJobsMsgJobStateEnum[keyof typeof V0040KillJobsMsgJobStateEnum];

/**
 * 
 * @export
 * @interface V0040KillJobsRespJob
 */
export interface V0040KillJobsRespJob {
    /**
     * 
     * @type {V0040KillJobsRespJobError}
     * @memberof V0040KillJobsRespJob
     */
    'error'?: V0040KillJobsRespJobError;
    /**
     * Job or Step ID that signaling failed
     * @type {string}
     * @memberof V0040KillJobsRespJob
     */
    'step_id': string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040KillJobsRespJob
     */
    'job_id': V0040Uint32NoVal;
    /**
     * 
     * @type {V0040KillJobsRespJobFederation}
     * @memberof V0040KillJobsRespJob
     */
    'federation'?: V0040KillJobsRespJobFederation;
}
/**
 * 
 * @export
 * @interface V0040KillJobsRespJobError
 */
export interface V0040KillJobsRespJobError {
    /**
     * String error encountered signaling job
     * @type {string}
     * @memberof V0040KillJobsRespJobError
     */
    'string'?: string;
    /**
     * Numeric error encountered signaling job
     * @type {number}
     * @memberof V0040KillJobsRespJobError
     */
    'code'?: number;
    /**
     * Error message why signaling job failed
     * @type {string}
     * @memberof V0040KillJobsRespJobError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface V0040KillJobsRespJobFederation
 */
export interface V0040KillJobsRespJobFederation {
    /**
     * Name of federation sibling (may be empty for non-federation)
     * @type {string}
     * @memberof V0040KillJobsRespJobFederation
     */
    'sibling'?: string;
}
/**
 * 
 * @export
 * @interface V0040License
 */
export interface V0040License {
    /**
     * Name of the license
     * @type {string}
     * @memberof V0040License
     */
    'LicenseName'?: string;
    /**
     * Total number of licenses present
     * @type {number}
     * @memberof V0040License
     */
    'Total'?: number;
    /**
     * Number of licenses in use
     * @type {number}
     * @memberof V0040License
     */
    'Used'?: number;
    /**
     * Number of licenses currently available
     * @type {number}
     * @memberof V0040License
     */
    'Free'?: number;
    /**
     * Indicates whether licenses are served by the database
     * @type {boolean}
     * @memberof V0040License
     */
    'Remote'?: boolean;
    /**
     * Number of licenses reserved
     * @type {number}
     * @memberof V0040License
     */
    'Reserved'?: number;
    /**
     * Last known number of licenses that were consumed in the license manager (Remote Only)
     * @type {number}
     * @memberof V0040License
     */
    'LastConsumed'?: number;
    /**
     * Number of \"missing licenses\" from the cluster\'s perspective
     * @type {number}
     * @memberof V0040License
     */
    'LastDeficit'?: number;
    /**
     * When the license information was last updated (UNIX Timestamp)
     * @type {number}
     * @memberof V0040License
     */
    'LastUpdate'?: number;
}
/**
 * 
 * @export
 * @interface V0040Node
 */
export interface V0040Node {
    /**
     * Computer architecture
     * @type {string}
     * @memberof V0040Node
     */
    'architecture'?: string;
    /**
     * Alternate network path to be used for sbcast network traffic
     * @type {string}
     * @memberof V0040Node
     */
    'burstbuffer_network_address'?: string;
    /**
     * Number of Baseboards in nodes with a baseboard controller
     * @type {number}
     * @memberof V0040Node
     */
    'boards'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'boot_time'?: V0040Uint64NoVal;
    /**
     * Cluster name (only set in federated environments)
     * @type {string}
     * @memberof V0040Node
     */
    'cluster_name'?: string;
    /**
     * Number of cores in a single physical processor socket
     * @type {number}
     * @memberof V0040Node
     */
    'cores'?: number;
    /**
     * Number of cores reserved for system use
     * @type {number}
     * @memberof V0040Node
     */
    'specialized_cores'?: number;
    /**
     * Default method for binding tasks to allocated CPUs
     * @type {number}
     * @memberof V0040Node
     */
    'cpu_binding'?: number;
    /**
     * CPU load as reported by the OS
     * @type {number}
     * @memberof V0040Node
     */
    'cpu_load'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'free_mem'?: V0040Uint64NoVal;
    /**
     * Total CPUs, including cores and threads
     * @type {number}
     * @memberof V0040Node
     */
    'cpus'?: number;
    /**
     * Number of effective CPUs (excluding specialized CPUs)
     * @type {number}
     * @memberof V0040Node
     */
    'effective_cpus'?: number;
    /**
     * Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
     * @type {string}
     * @memberof V0040Node
     */
    'specialized_cpus'?: string;
    /**
     * 
     * @type {V0040AcctGatherEnergy}
     * @memberof V0040Node
     */
    'energy'?: V0040AcctGatherEnergy;
    /**
     * removed field
     * @type {object}
     * @memberof V0040Node
     * @deprecated
     */
    'external_sensors'?: object;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040Node
     */
    'extra'?: string;
    /**
     * removed field
     * @type {object}
     * @memberof V0040Node
     * @deprecated
     */
    'power'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040Node
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040Node
     */
    'active_features'?: Array<string>;
    /**
     * Generic resources
     * @type {string}
     * @memberof V0040Node
     */
    'gres'?: string;
    /**
     * Drained generic resources
     * @type {string}
     * @memberof V0040Node
     */
    'gres_drained'?: string;
    /**
     * Generic resources currently in use
     * @type {string}
     * @memberof V0040Node
     */
    'gres_used'?: string;
    /**
     * Cloud instance ID
     * @type {string}
     * @memberof V0040Node
     */
    'instance_id'?: string;
    /**
     * Cloud instance type
     * @type {string}
     * @memberof V0040Node
     */
    'instance_type'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'last_busy'?: V0040Uint64NoVal;
    /**
     * Multi-Category Security label
     * @type {string}
     * @memberof V0040Node
     */
    'mcs_label'?: string;
    /**
     * Combined memory limit, in MB, for Slurm compute node daemons
     * @type {number}
     * @memberof V0040Node
     */
    'specialized_memory'?: number;
    /**
     * NodeName
     * @type {string}
     * @memberof V0040Node
     */
    'name'?: string;
    /**
     * The state the node will be assigned after rebooting
     * @type {Array<string>}
     * @memberof V0040Node
     */
    'next_state_after_reboot'?: Array<V0040NodeNextStateAfterRebootEnum>;
    /**
     * NodeAddr, used to establish a communication path
     * @type {string}
     * @memberof V0040Node
     */
    'address'?: string;
    /**
     * NodeHostname
     * @type {string}
     * @memberof V0040Node
     */
    'hostname'?: string;
    /**
     * Node state(s) applicable to this node
     * @type {Array<string>}
     * @memberof V0040Node
     */
    'state'?: Array<V0040NodeStateEnum>;
    /**
     * Operating system reported by the node
     * @type {string}
     * @memberof V0040Node
     */
    'operating_system'?: string;
    /**
     * User allowed to run jobs on this node (unset if no restriction)
     * @type {string}
     * @memberof V0040Node
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040Node
     */
    'partitions'?: Array<string>;
    /**
     * TCP port number of the slurmd
     * @type {number}
     * @memberof V0040Node
     */
    'port'?: number;
    /**
     * Total memory in MB on the node
     * @type {number}
     * @memberof V0040Node
     */
    'real_memory'?: number;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0040Node
     */
    'comment'?: string;
    /**
     * Describes why the node is in a \"DOWN\", \"DRAINED\", \"DRAINING\", \"FAILING\" or \"FAIL\" state
     * @type {string}
     * @memberof V0040Node
     */
    'reason'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'reason_changed_at'?: V0040Uint64NoVal;
    /**
     * User who set the reason
     * @type {string}
     * @memberof V0040Node
     */
    'reason_set_by_user'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'resume_after'?: V0040Uint64NoVal;
    /**
     * Name of reservation containing this node
     * @type {string}
     * @memberof V0040Node
     */
    'reservation'?: string;
    /**
     * Total memory in MB currently allocated for jobs
     * @type {number}
     * @memberof V0040Node
     */
    'alloc_memory'?: number;
    /**
     * Total number of CPUs currently allocated for jobs
     * @type {number}
     * @memberof V0040Node
     */
    'alloc_cpus'?: number;
    /**
     * Total number of idle CPUs
     * @type {number}
     * @memberof V0040Node
     */
    'alloc_idle_cpus'?: number;
    /**
     * Trackable resources currently allocated for jobs
     * @type {string}
     * @memberof V0040Node
     */
    'tres_used'?: string;
    /**
     * Weighted number of billable trackable resources allocated
     * @type {number}
     * @memberof V0040Node
     */
    'tres_weighted'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040Node
     */
    'slurmd_start_time'?: V0040Uint64NoVal;
    /**
     * Number of physical processor sockets/chips on the node
     * @type {number}
     * @memberof V0040Node
     */
    'sockets'?: number;
    /**
     * Number of logical threads in a single physical core
     * @type {number}
     * @memberof V0040Node
     */
    'threads'?: number;
    /**
     * Total size in MB of temporary disk storage in TmpFS
     * @type {number}
     * @memberof V0040Node
     */
    'temporary_disk'?: number;
    /**
     * Weight of the node for scheduling purposes
     * @type {number}
     * @memberof V0040Node
     */
    'weight'?: number;
    /**
     * Configured trackable resources
     * @type {string}
     * @memberof V0040Node
     */
    'tres'?: string;
    /**
     * Slurmd version
     * @type {string}
     * @memberof V0040Node
     */
    'version'?: string;
}

export const V0040NodeNextStateAfterRebootEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0040NodeNextStateAfterRebootEnum = typeof V0040NodeNextStateAfterRebootEnum[keyof typeof V0040NodeNextStateAfterRebootEnum];
export const V0040NodeStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0040NodeStateEnum = typeof V0040NodeStateEnum[keyof typeof V0040NodeStateEnum];

/**
 * 
 * @export
 * @interface V0040OpenapiAccountsAddCondResp
 */
export interface V0040OpenapiAccountsAddCondResp {
    /**
     * 
     * @type {V0040AccountsAddCond}
     * @memberof V0040OpenapiAccountsAddCondResp
     */
    'association_condition'?: V0040AccountsAddCond;
    /**
     * 
     * @type {V0040AccountShort}
     * @memberof V0040OpenapiAccountsAddCondResp
     */
    'account'?: V0040AccountShort;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAccountsAddCondResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAccountsAddCondResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAccountsAddCondResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiAccountsAddCondRespStr
 */
export interface V0040OpenapiAccountsAddCondRespStr {
    /**
     * added_accounts
     * @type {string}
     * @memberof V0040OpenapiAccountsAddCondRespStr
     */
    'added_accounts': string;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAccountsAddCondRespStr
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAccountsAddCondRespStr
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAccountsAddCondRespStr
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiAccountsRemovedResp
 */
export interface V0040OpenapiAccountsRemovedResp {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiAccountsRemovedResp
     */
    'removed_accounts': Array<string>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAccountsRemovedResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAccountsRemovedResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAccountsRemovedResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiAccountsResp
 */
export interface V0040OpenapiAccountsResp {
    /**
     * 
     * @type {Array<V0040Account>}
     * @memberof V0040OpenapiAccountsResp
     */
    'accounts': Array<V0040Account>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAccountsResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAccountsResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAccountsResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiAssocsRemovedResp
 */
export interface V0040OpenapiAssocsRemovedResp {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiAssocsRemovedResp
     */
    'removed_associations': Array<string>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAssocsRemovedResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAssocsRemovedResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAssocsRemovedResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiAssocsResp
 */
export interface V0040OpenapiAssocsResp {
    /**
     * 
     * @type {Array<V0040Assoc>}
     * @memberof V0040OpenapiAssocsResp
     */
    'associations': Array<V0040Assoc>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiAssocsResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiAssocsResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiAssocsResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiClustersRemovedResp
 */
export interface V0040OpenapiClustersRemovedResp {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiClustersRemovedResp
     */
    'deleted_clusters': Array<string>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiClustersRemovedResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiClustersRemovedResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiClustersRemovedResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiClustersResp
 */
export interface V0040OpenapiClustersResp {
    /**
     * 
     * @type {Array<V0040ClusterRec>}
     * @memberof V0040OpenapiClustersResp
     */
    'clusters': Array<V0040ClusterRec>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiClustersResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiClustersResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiClustersResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiDiagResp
 */
export interface V0040OpenapiDiagResp {
    /**
     * 
     * @type {V0040StatsMsg}
     * @memberof V0040OpenapiDiagResp
     */
    'statistics': V0040StatsMsg;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiDiagResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiDiagResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiDiagResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiError
 */
export interface V0040OpenapiError {
    /**
     * Long form error description
     * @type {string}
     * @memberof V0040OpenapiError
     */
    'description'?: string;
    /**
     * Slurm numeric error identifier
     * @type {number}
     * @memberof V0040OpenapiError
     */
    'error_number'?: number;
    /**
     * Short form error description
     * @type {string}
     * @memberof V0040OpenapiError
     */
    'error'?: string;
    /**
     * Source of error or where error was first detected
     * @type {string}
     * @memberof V0040OpenapiError
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiInstancesResp
 */
export interface V0040OpenapiInstancesResp {
    /**
     * 
     * @type {Array<V0040Instance>}
     * @memberof V0040OpenapiInstancesResp
     */
    'instances': Array<V0040Instance>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiInstancesResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiInstancesResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiInstancesResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiJobInfoResp
 */
export interface V0040OpenapiJobInfoResp {
    /**
     * 
     * @type {Array<V0040JobInfo>}
     * @memberof V0040OpenapiJobInfoResp
     */
    'jobs': Array<V0040JobInfo>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiJobInfoResp
     */
    'last_backfill': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiJobInfoResp
     */
    'last_update': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiJobInfoResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiJobInfoResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiJobInfoResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiJobPostResponse
 */
export interface V0040OpenapiJobPostResponse {
    /**
     * 
     * @type {Array<V0040JobArrayResponseMsgEntry>}
     * @memberof V0040OpenapiJobPostResponse
     */
    'results'?: Array<V0040JobArrayResponseMsgEntry>;
    /**
     * First updated Job ID - Use results instead
     * @type {string}
     * @memberof V0040OpenapiJobPostResponse
     */
    'job_id'?: string;
    /**
     * First updated Step ID - Use results instead
     * @type {string}
     * @memberof V0040OpenapiJobPostResponse
     */
    'step_id'?: string;
    /**
     * First updated Job submision user message - Use results instead
     * @type {string}
     * @memberof V0040OpenapiJobPostResponse
     */
    'job_submit_user_msg'?: string;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiJobPostResponse
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiJobPostResponse
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiJobPostResponse
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiJobSubmitResponse
 */
export interface V0040OpenapiJobSubmitResponse {
    /**
     * 
     * @type {V0040JobSubmitResponseMsg}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'result'?: V0040JobSubmitResponseMsg;
    /**
     * Submitted Job ID
     * @type {number}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'job_id'?: number;
    /**
     * Submitted Step ID
     * @type {string}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'step_id'?: string;
    /**
     * job submision user message
     * @type {string}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'job_submit_user_msg'?: string;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiJobSubmitResponse
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiKillJobsResp
 */
export interface V0040OpenapiKillJobsResp {
    /**
     * List of jobs signal responses
     * @type {Array<V0040KillJobsRespJob>}
     * @memberof V0040OpenapiKillJobsResp
     */
    'status': Array<V0040KillJobsRespJob>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiKillJobsResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiKillJobsResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiKillJobsResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiLicensesResp
 */
export interface V0040OpenapiLicensesResp {
    /**
     * 
     * @type {Array<V0040License>}
     * @memberof V0040OpenapiLicensesResp
     */
    'licenses': Array<V0040License>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiLicensesResp
     */
    'last_update': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiLicensesResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiLicensesResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiLicensesResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiMeta
 */
export interface V0040OpenapiMeta {
    /**
     * 
     * @type {V0040OpenapiMetaPlugin}
     * @memberof V0040OpenapiMeta
     */
    'plugin'?: V0040OpenapiMetaPlugin;
    /**
     * 
     * @type {V0040OpenapiMetaClient}
     * @memberof V0040OpenapiMeta
     */
    'client'?: V0040OpenapiMetaClient;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiMeta
     */
    'command'?: Array<string>;
    /**
     * 
     * @type {V0040OpenapiMetaSlurm}
     * @memberof V0040OpenapiMeta
     */
    'slurm'?: V0040OpenapiMetaSlurm;
}
/**
 * 
 * @export
 * @interface V0040OpenapiMetaClient
 */
export interface V0040OpenapiMetaClient {
    /**
     * Client source description
     * @type {string}
     * @memberof V0040OpenapiMetaClient
     */
    'source'?: string;
    /**
     * Client user (if known)
     * @type {string}
     * @memberof V0040OpenapiMetaClient
     */
    'user'?: string;
    /**
     * Client group (if known)
     * @type {string}
     * @memberof V0040OpenapiMetaClient
     */
    'group'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiMetaPlugin
 */
export interface V0040OpenapiMetaPlugin {
    /**
     * Slurm plugin type (if applicable)
     * @type {string}
     * @memberof V0040OpenapiMetaPlugin
     */
    'type'?: string;
    /**
     * Slurm plugin name (if applicable)
     * @type {string}
     * @memberof V0040OpenapiMetaPlugin
     */
    'name'?: string;
    /**
     * Slurm data_parser plugin
     * @type {string}
     * @memberof V0040OpenapiMetaPlugin
     */
    'data_parser'?: string;
    /**
     * Slurm accounting plugin
     * @type {string}
     * @memberof V0040OpenapiMetaPlugin
     */
    'accounting_storage'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiMetaSlurm
 */
export interface V0040OpenapiMetaSlurm {
    /**
     * 
     * @type {V0040OpenapiMetaSlurmVersion}
     * @memberof V0040OpenapiMetaSlurm
     */
    'version'?: V0040OpenapiMetaSlurmVersion;
    /**
     * Slurm release string
     * @type {string}
     * @memberof V0040OpenapiMetaSlurm
     */
    'release'?: string;
    /**
     * Slurm cluster name
     * @type {string}
     * @memberof V0040OpenapiMetaSlurm
     */
    'cluster'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiMetaSlurmVersion
 */
export interface V0040OpenapiMetaSlurmVersion {
    /**
     * Slurm release major version
     * @type {string}
     * @memberof V0040OpenapiMetaSlurmVersion
     */
    'major'?: string;
    /**
     * Slurm release micro version
     * @type {string}
     * @memberof V0040OpenapiMetaSlurmVersion
     */
    'micro'?: string;
    /**
     * Slurm release minor version
     * @type {string}
     * @memberof V0040OpenapiMetaSlurmVersion
     */
    'minor'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiNodesResp
 */
export interface V0040OpenapiNodesResp {
    /**
     * 
     * @type {Array<V0040Node>}
     * @memberof V0040OpenapiNodesResp
     */
    'nodes': Array<V0040Node>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiNodesResp
     */
    'last_update': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiNodesResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiNodesResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiNodesResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiPartitionResp
 */
export interface V0040OpenapiPartitionResp {
    /**
     * 
     * @type {Array<V0040PartitionInfo>}
     * @memberof V0040OpenapiPartitionResp
     */
    'partitions': Array<V0040PartitionInfo>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiPartitionResp
     */
    'last_update': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiPartitionResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiPartitionResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiPartitionResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiPingArrayResp
 */
export interface V0040OpenapiPingArrayResp {
    /**
     * 
     * @type {Array<V0040ControllerPing>}
     * @memberof V0040OpenapiPingArrayResp
     */
    'pings': Array<V0040ControllerPing>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiPingArrayResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiPingArrayResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiPingArrayResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiReservationResp
 */
export interface V0040OpenapiReservationResp {
    /**
     * 
     * @type {Array<V0040ReservationInfo>}
     * @memberof V0040OpenapiReservationResp
     */
    'reservations': Array<V0040ReservationInfo>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040OpenapiReservationResp
     */
    'last_update': V0040Uint64NoVal;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiReservationResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiReservationResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiReservationResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiResp
 */
export interface V0040OpenapiResp {
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSharesResp
 */
export interface V0040OpenapiSharesResp {
    /**
     * 
     * @type {V0040SharesRespMsg}
     * @memberof V0040OpenapiSharesResp
     */
    'shares': V0040SharesRespMsg;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSharesResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSharesResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSharesResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSlurmdbdConfigResp
 */
export interface V0040OpenapiSlurmdbdConfigResp {
    /**
     * 
     * @type {Array<V0040ClusterRec>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'clusters'?: Array<V0040ClusterRec>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'tres'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Account>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'accounts'?: Array<V0040Account>;
    /**
     * 
     * @type {Array<V0040User>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'users'?: Array<V0040User>;
    /**
     * 
     * @type {Array<V0040Qos>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'qos'?: Array<V0040Qos>;
    /**
     * 
     * @type {Array<V0040Wckey>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'wckeys'?: Array<V0040Wckey>;
    /**
     * 
     * @type {Array<V0040Assoc>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'associations'?: Array<V0040Assoc>;
    /**
     * 
     * @type {Array<V0040Instance>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'instances'?: Array<V0040Instance>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSlurmdbdConfigResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSlurmdbdJobsResp
 */
export interface V0040OpenapiSlurmdbdJobsResp {
    /**
     * 
     * @type {Array<V0040Job>}
     * @memberof V0040OpenapiSlurmdbdJobsResp
     */
    'jobs': Array<V0040Job>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSlurmdbdJobsResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSlurmdbdJobsResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSlurmdbdJobsResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSlurmdbdQosRemovedResp
 */
export interface V0040OpenapiSlurmdbdQosRemovedResp {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiSlurmdbdQosRemovedResp
     */
    'removed_qos': Array<string>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSlurmdbdQosRemovedResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSlurmdbdQosRemovedResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSlurmdbdQosRemovedResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSlurmdbdQosResp
 */
export interface V0040OpenapiSlurmdbdQosResp {
    /**
     * 
     * @type {Array<V0040Qos>}
     * @memberof V0040OpenapiSlurmdbdQosResp
     */
    'qos': Array<V0040Qos>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSlurmdbdQosResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSlurmdbdQosResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSlurmdbdQosResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiSlurmdbdStatsResp
 */
export interface V0040OpenapiSlurmdbdStatsResp {
    /**
     * 
     * @type {V0040StatsRec}
     * @memberof V0040OpenapiSlurmdbdStatsResp
     */
    'statistics': V0040StatsRec;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiSlurmdbdStatsResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiSlurmdbdStatsResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiSlurmdbdStatsResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiTresResp
 */
export interface V0040OpenapiTresResp {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040OpenapiTresResp
     */
    'TRES': Array<V0040Tres>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiTresResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiTresResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiTresResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiUsersAddCondResp
 */
export interface V0040OpenapiUsersAddCondResp {
    /**
     * 
     * @type {V0040UsersAddCond}
     * @memberof V0040OpenapiUsersAddCondResp
     */
    'association_condition': V0040UsersAddCond;
    /**
     * 
     * @type {V0040UserShort}
     * @memberof V0040OpenapiUsersAddCondResp
     */
    'user': V0040UserShort;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiUsersAddCondResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiUsersAddCondResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiUsersAddCondResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiUsersAddCondRespStr
 */
export interface V0040OpenapiUsersAddCondRespStr {
    /**
     * added_users
     * @type {string}
     * @memberof V0040OpenapiUsersAddCondRespStr
     */
    'added_users': string;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiUsersAddCondRespStr
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiUsersAddCondRespStr
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiUsersAddCondRespStr
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiUsersResp
 */
export interface V0040OpenapiUsersResp {
    /**
     * 
     * @type {Array<V0040User>}
     * @memberof V0040OpenapiUsersResp
     */
    'users': Array<V0040User>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiUsersResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiUsersResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiUsersResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiWarning
 */
export interface V0040OpenapiWarning {
    /**
     * Long form warning description
     * @type {string}
     * @memberof V0040OpenapiWarning
     */
    'description'?: string;
    /**
     * Source of warning or where warning was first detected
     * @type {string}
     * @memberof V0040OpenapiWarning
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface V0040OpenapiWckeyRemovedResp
 */
export interface V0040OpenapiWckeyRemovedResp {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040OpenapiWckeyRemovedResp
     */
    'deleted_wckeys': Array<string>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiWckeyRemovedResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiWckeyRemovedResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiWckeyRemovedResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040OpenapiWckeyResp
 */
export interface V0040OpenapiWckeyResp {
    /**
     * 
     * @type {Array<V0040Wckey>}
     * @memberof V0040OpenapiWckeyResp
     */
    'wckeys': Array<V0040Wckey>;
    /**
     * 
     * @type {V0040OpenapiMeta}
     * @memberof V0040OpenapiWckeyResp
     */
    'meta'?: V0040OpenapiMeta;
    /**
     * 
     * @type {Array<V0040OpenapiError>}
     * @memberof V0040OpenapiWckeyResp
     */
    'errors'?: Array<V0040OpenapiError>;
    /**
     * 
     * @type {Array<V0040OpenapiWarning>}
     * @memberof V0040OpenapiWckeyResp
     */
    'warnings'?: Array<V0040OpenapiWarning>;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfo
 */
export interface V0040PartitionInfo {
    /**
     * 
     * @type {V0040PartitionInfoNodes}
     * @memberof V0040PartitionInfo
     */
    'nodes'?: V0040PartitionInfoNodes;
    /**
     * 
     * @type {V0040PartitionInfoAccounts}
     * @memberof V0040PartitionInfo
     */
    'accounts'?: V0040PartitionInfoAccounts;
    /**
     * 
     * @type {V0040PartitionInfoGroups}
     * @memberof V0040PartitionInfo
     */
    'groups'?: V0040PartitionInfoGroups;
    /**
     * 
     * @type {V0040PartitionInfoQos}
     * @memberof V0040PartitionInfo
     */
    'qos'?: V0040PartitionInfoQos;
    /**
     * Alternate
     * @type {string}
     * @memberof V0040PartitionInfo
     */
    'alternate'?: string;
    /**
     * 
     * @type {V0040PartitionInfoTres}
     * @memberof V0040PartitionInfo
     */
    'tres'?: V0040PartitionInfoTres;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040PartitionInfo
     */
    'cluster'?: string;
    /**
     * 
     * @type {V0040PartitionInfoCpus}
     * @memberof V0040PartitionInfo
     */
    'cpus'?: V0040PartitionInfoCpus;
    /**
     * 
     * @type {V0040PartitionInfoDefaults}
     * @memberof V0040PartitionInfo
     */
    'defaults'?: V0040PartitionInfoDefaults;
    /**
     * GraceTime
     * @type {number}
     * @memberof V0040PartitionInfo
     */
    'grace_time'?: number;
    /**
     * 
     * @type {V0040PartitionInfoMaximums}
     * @memberof V0040PartitionInfo
     */
    'maximums'?: V0040PartitionInfoMaximums;
    /**
     * 
     * @type {V0040PartitionInfoMinimums}
     * @memberof V0040PartitionInfo
     */
    'minimums'?: V0040PartitionInfoMinimums;
    /**
     * PartitionName
     * @type {string}
     * @memberof V0040PartitionInfo
     */
    'name'?: string;
    /**
     * NodeSets
     * @type {string}
     * @memberof V0040PartitionInfo
     */
    'node_sets'?: string;
    /**
     * 
     * @type {V0040PartitionInfoPriority}
     * @memberof V0040PartitionInfo
     */
    'priority'?: V0040PartitionInfoPriority;
    /**
     * 
     * @type {V0040PartitionInfoTimeouts}
     * @memberof V0040PartitionInfo
     */
    'timeouts'?: V0040PartitionInfoTimeouts;
    /**
     * 
     * @type {V0040PartitionInfoPartition}
     * @memberof V0040PartitionInfo
     */
    'partition'?: V0040PartitionInfoPartition;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfo
     */
    'suspend_time'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoAccounts
 */
export interface V0040PartitionInfoAccounts {
    /**
     * AllowAccounts
     * @type {string}
     * @memberof V0040PartitionInfoAccounts
     */
    'allowed'?: string;
    /**
     * DenyAccounts
     * @type {string}
     * @memberof V0040PartitionInfoAccounts
     */
    'deny'?: string;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoCpus
 */
export interface V0040PartitionInfoCpus {
    /**
     * CpuBind
     * @type {number}
     * @memberof V0040PartitionInfoCpus
     */
    'task_binding'?: number;
    /**
     * TotalCPUs
     * @type {number}
     * @memberof V0040PartitionInfoCpus
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoDefaults
 */
export interface V0040PartitionInfoDefaults {
    /**
     * DefMemPerCPU or DefMemPerNode
     * @type {number}
     * @memberof V0040PartitionInfoDefaults
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040PartitionInfoDefaults
     */
    'partition_memory_per_cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040PartitionInfoDefaults
     */
    'partition_memory_per_node'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfoDefaults
     */
    'time'?: V0040Uint32NoVal;
    /**
     * JobDefaults
     * @type {string}
     * @memberof V0040PartitionInfoDefaults
     */
    'job'?: string;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoGroups
 */
export interface V0040PartitionInfoGroups {
    /**
     * AllowGroups
     * @type {string}
     * @memberof V0040PartitionInfoGroups
     */
    'allowed'?: string;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoMaximums
 */
export interface V0040PartitionInfoMaximums {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'cpus_per_node'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'cpus_per_socket'?: V0040Uint32NoVal;
    /**
     * MaxMemPerCPU or MaxMemPerNode
     * @type {number}
     * @memberof V0040PartitionInfoMaximums
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'partition_memory_per_cpu'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'partition_memory_per_node'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'nodes'?: V0040Uint32NoVal;
    /**
     * OverSubscribe
     * @type {number}
     * @memberof V0040PartitionInfoMaximums
     */
    'shares'?: number;
    /**
     * 
     * @type {V0040PartitionInfoMaximumsOversubscribe}
     * @memberof V0040PartitionInfoMaximums
     */
    'oversubscribe'?: V0040PartitionInfoMaximumsOversubscribe;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'time'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040PartitionInfoMaximums
     */
    'over_time_limit'?: V0040Uint16NoVal;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoMaximumsOversubscribe
 */
export interface V0040PartitionInfoMaximumsOversubscribe {
    /**
     * Maximum number of jobs allowed to oversubscribe resources
     * @type {number}
     * @memberof V0040PartitionInfoMaximumsOversubscribe
     */
    'jobs'?: number;
    /**
     * Flags applicable to the OverSubscribe setting
     * @type {Array<string>}
     * @memberof V0040PartitionInfoMaximumsOversubscribe
     */
    'flags'?: Array<V0040PartitionInfoMaximumsOversubscribeFlagsEnum>;
}

export const V0040PartitionInfoMaximumsOversubscribeFlagsEnum = {
    Force: 'force'
} as const;

export type V0040PartitionInfoMaximumsOversubscribeFlagsEnum = typeof V0040PartitionInfoMaximumsOversubscribeFlagsEnum[keyof typeof V0040PartitionInfoMaximumsOversubscribeFlagsEnum];

/**
 * 
 * @export
 * @interface V0040PartitionInfoMinimums
 */
export interface V0040PartitionInfoMinimums {
    /**
     * MinNodes
     * @type {number}
     * @memberof V0040PartitionInfoMinimums
     */
    'nodes'?: number;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoNodes
 */
export interface V0040PartitionInfoNodes {
    /**
     * AllocNodes
     * @type {string}
     * @memberof V0040PartitionInfoNodes
     */
    'allowed_allocation'?: string;
    /**
     * Nodes
     * @type {string}
     * @memberof V0040PartitionInfoNodes
     */
    'configured'?: string;
    /**
     * TotalNodes
     * @type {number}
     * @memberof V0040PartitionInfoNodes
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoPartition
 */
export interface V0040PartitionInfoPartition {
    /**
     * Current state(s)
     * @type {Array<string>}
     * @memberof V0040PartitionInfoPartition
     */
    'state'?: Array<V0040PartitionInfoPartitionStateEnum>;
}

export const V0040PartitionInfoPartitionStateEnum = {
    Inactive: 'INACTIVE',
    Unknown: 'UNKNOWN',
    Up: 'UP',
    Down: 'DOWN',
    Drain: 'DRAIN'
} as const;

export type V0040PartitionInfoPartitionStateEnum = typeof V0040PartitionInfoPartitionStateEnum[keyof typeof V0040PartitionInfoPartitionStateEnum];

/**
 * 
 * @export
 * @interface V0040PartitionInfoPriority
 */
export interface V0040PartitionInfoPriority {
    /**
     * PriorityJobFactor
     * @type {number}
     * @memberof V0040PartitionInfoPriority
     */
    'job_factor'?: number;
    /**
     * PriorityTier
     * @type {number}
     * @memberof V0040PartitionInfoPriority
     */
    'tier'?: number;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoQos
 */
export interface V0040PartitionInfoQos {
    /**
     * AllowQOS
     * @type {string}
     * @memberof V0040PartitionInfoQos
     */
    'allowed'?: string;
    /**
     * DenyQOS
     * @type {string}
     * @memberof V0040PartitionInfoQos
     */
    'deny'?: string;
    /**
     * QOS
     * @type {string}
     * @memberof V0040PartitionInfoQos
     */
    'assigned'?: string;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoTimeouts
 */
export interface V0040PartitionInfoTimeouts {
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040PartitionInfoTimeouts
     */
    'resume'?: V0040Uint16NoVal;
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040PartitionInfoTimeouts
     */
    'suspend'?: V0040Uint16NoVal;
}
/**
 * 
 * @export
 * @interface V0040PartitionInfoTres
 */
export interface V0040PartitionInfoTres {
    /**
     * TRESBillingWeights
     * @type {string}
     * @memberof V0040PartitionInfoTres
     */
    'billing_weights'?: string;
    /**
     * TRES
     * @type {string}
     * @memberof V0040PartitionInfoTres
     */
    'configured'?: string;
}
/**
 * 
 * @export
 * @interface V0040ProcessExitCodeVerbose
 */
export interface V0040ProcessExitCodeVerbose {
    /**
     * Status given by return code
     * @type {Array<string>}
     * @memberof V0040ProcessExitCodeVerbose
     */
    'status'?: Array<V0040ProcessExitCodeVerboseStatusEnum>;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040ProcessExitCodeVerbose
     */
    'return_code'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040ProcessExitCodeVerboseSignal}
     * @memberof V0040ProcessExitCodeVerbose
     */
    'signal'?: V0040ProcessExitCodeVerboseSignal;
}

export const V0040ProcessExitCodeVerboseStatusEnum = {
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR',
    Signaled: 'SIGNALED',
    CoreDumped: 'CORE_DUMPED'
} as const;

export type V0040ProcessExitCodeVerboseStatusEnum = typeof V0040ProcessExitCodeVerboseStatusEnum[keyof typeof V0040ProcessExitCodeVerboseStatusEnum];

/**
 * 
 * @export
 * @interface V0040ProcessExitCodeVerboseSignal
 */
export interface V0040ProcessExitCodeVerboseSignal {
    /**
     * 
     * @type {V0040Uint16NoVal}
     * @memberof V0040ProcessExitCodeVerboseSignal
     */
    'id'?: V0040Uint16NoVal;
    /**
     * Signal sent to process
     * @type {string}
     * @memberof V0040ProcessExitCodeVerboseSignal
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0040Qos
 */
export interface V0040Qos {
    /**
     * Arbitrary description
     * @type {string}
     * @memberof V0040Qos
     */
    'description'?: string;
    /**
     * Flags, to avoid modifying current values specify NOT_SET.
     * @type {Array<string>}
     * @memberof V0040Qos
     */
    'flags'?: Array<V0040QosFlagsEnum>;
    /**
     * Unique ID
     * @type {number}
     * @memberof V0040Qos
     */
    'id'?: number;
    /**
     * 
     * @type {V0040QosLimits}
     * @memberof V0040Qos
     */
    'limits'?: V0040QosLimits;
    /**
     * Name
     * @type {string}
     * @memberof V0040Qos
     */
    'name'?: string;
    /**
     * 
     * @type {V0040QosPreempt}
     * @memberof V0040Qos
     */
    'preempt'?: V0040QosPreempt;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040Qos
     */
    'priority'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040Qos
     */
    'usage_factor'?: V0040Float64NoVal;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040Qos
     */
    'usage_threshold'?: V0040Float64NoVal;
}

export const V0040QosFlagsEnum = {
    NotSet: 'NOT_SET',
    Add: 'ADD',
    Remove: 'REMOVE',
    PartitionMinimumNode: 'PARTITION_MINIMUM_NODE',
    PartitionMaximumNode: 'PARTITION_MAXIMUM_NODE',
    PartitionTimeLimit: 'PARTITION_TIME_LIMIT',
    EnforceUsageThreshold: 'ENFORCE_USAGE_THRESHOLD',
    NoReserve: 'NO_RESERVE',
    RequiredReservation: 'REQUIRED_RESERVATION',
    DenyLimit: 'DENY_LIMIT',
    OverridePartitionQos: 'OVERRIDE_PARTITION_QOS',
    NoDecay: 'NO_DECAY',
    UsageFactorSafe: 'USAGE_FACTOR_SAFE',
    Relative: 'RELATIVE'
} as const;

export type V0040QosFlagsEnum = typeof V0040QosFlagsEnum[keyof typeof V0040QosFlagsEnum];

/**
 * 
 * @export
 * @interface V0040QosLimits
 */
export interface V0040QosLimits {
    /**
     * GraceTime
     * @type {number}
     * @memberof V0040QosLimits
     */
    'grace_time'?: number;
    /**
     * 
     * @type {V0040QosLimitsMax}
     * @memberof V0040QosLimits
     */
    'max'?: V0040QosLimitsMax;
    /**
     * 
     * @type {V0040Float64NoVal}
     * @memberof V0040QosLimits
     */
    'factor'?: V0040Float64NoVal;
    /**
     * 
     * @type {V0040QosLimitsMin}
     * @memberof V0040QosLimits
     */
    'min'?: V0040QosLimitsMin;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMax
 */
export interface V0040QosLimitsMax {
    /**
     * 
     * @type {V0040QosLimitsMaxActiveJobs}
     * @memberof V0040QosLimitsMax
     */
    'active_jobs'?: V0040QosLimitsMaxActiveJobs;
    /**
     * 
     * @type {V0040QosLimitsMaxTres}
     * @memberof V0040QosLimitsMax
     */
    'tres'?: V0040QosLimitsMaxTres;
    /**
     * 
     * @type {V0040QosLimitsMaxWallClock}
     * @memberof V0040QosLimitsMax
     */
    'wall_clock'?: V0040QosLimitsMaxWallClock;
    /**
     * 
     * @type {V0040QosLimitsMaxJobs}
     * @memberof V0040QosLimitsMax
     */
    'jobs'?: V0040QosLimitsMaxJobs;
    /**
     * 
     * @type {V0040QosLimitsMaxJobsActiveJobs}
     * @memberof V0040QosLimitsMax
     */
    'accruing'?: V0040QosLimitsMaxJobsActiveJobs;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxActiveJobs
 */
export interface V0040QosLimitsMaxActiveJobs {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxActiveJobs
     */
    'accruing'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxActiveJobs
     */
    'count'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxJobs
 */
export interface V0040QosLimitsMaxJobs {
    /**
     * 
     * @type {V0040QosLimitsMaxJobsActiveJobs}
     * @memberof V0040QosLimitsMaxJobs
     */
    'active_jobs'?: V0040QosLimitsMaxJobsActiveJobs;
    /**
     * 
     * @type {V0040QosLimitsMaxJobsActiveJobsPer}
     * @memberof V0040QosLimitsMaxJobs
     */
    'per'?: V0040QosLimitsMaxJobsActiveJobsPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxJobsActiveJobs
 */
export interface V0040QosLimitsMaxJobsActiveJobs {
    /**
     * 
     * @type {V0040QosLimitsMaxJobsActiveJobsPer}
     * @memberof V0040QosLimitsMaxJobsActiveJobs
     */
    'per'?: V0040QosLimitsMaxJobsActiveJobsPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxJobsActiveJobsPer
 */
export interface V0040QosLimitsMaxJobsActiveJobsPer {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxJobsActiveJobsPer
     */
    'account'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxJobsActiveJobsPer
     */
    'user'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxTres
 */
export interface V0040QosLimitsMaxTres {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTres
     */
    'total'?: Array<V0040Tres>;
    /**
     * 
     * @type {V0040QosLimitsMaxTresMinutes}
     * @memberof V0040QosLimitsMaxTres
     */
    'minutes'?: V0040QosLimitsMaxTresMinutes;
    /**
     * 
     * @type {V0040QosLimitsMaxTresPer}
     * @memberof V0040QosLimitsMaxTres
     */
    'per'?: V0040QosLimitsMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxTresMinutes
 */
export interface V0040QosLimitsMaxTresMinutes {
    /**
     * 
     * @type {V0040QosLimitsMaxTresMinutesPer}
     * @memberof V0040QosLimitsMaxTresMinutes
     */
    'per'?: V0040QosLimitsMaxTresMinutesPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxTresMinutesPer
 */
export interface V0040QosLimitsMaxTresMinutesPer {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresMinutesPer
     */
    'qos'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresMinutesPer
     */
    'job'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresMinutesPer
     */
    'account'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresMinutesPer
     */
    'user'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxTresPer
 */
export interface V0040QosLimitsMaxTresPer {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresPer
     */
    'account'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresPer
     */
    'job'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresPer
     */
    'node'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMaxTresPer
     */
    'user'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxWallClock
 */
export interface V0040QosLimitsMaxWallClock {
    /**
     * 
     * @type {V0040QosLimitsMaxWallClockPer}
     * @memberof V0040QosLimitsMaxWallClock
     */
    'per'?: V0040QosLimitsMaxWallClockPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMaxWallClockPer
 */
export interface V0040QosLimitsMaxWallClockPer {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxWallClockPer
     */
    'qos'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMaxWallClockPer
     */
    'job'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMin
 */
export interface V0040QosLimitsMin {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosLimitsMin
     */
    'priority_threshold'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040QosLimitsMinTres}
     * @memberof V0040QosLimitsMin
     */
    'tres'?: V0040QosLimitsMinTres;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMinTres
 */
export interface V0040QosLimitsMinTres {
    /**
     * 
     * @type {V0040QosLimitsMinTresPer}
     * @memberof V0040QosLimitsMinTres
     */
    'per'?: V0040QosLimitsMinTresPer;
}
/**
 * 
 * @export
 * @interface V0040QosLimitsMinTresPer
 */
export interface V0040QosLimitsMinTresPer {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040QosLimitsMinTresPer
     */
    'job'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040QosPreempt
 */
export interface V0040QosPreempt {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040QosPreempt
     */
    'list'?: Array<string>;
    /**
     * PreemptMode
     * @type {Array<string>}
     * @memberof V0040QosPreempt
     */
    'mode'?: Array<V0040QosPreemptModeEnum>;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040QosPreempt
     */
    'exempt_time'?: V0040Uint32NoVal;
}

export const V0040QosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;

export type V0040QosPreemptModeEnum = typeof V0040QosPreemptModeEnum[keyof typeof V0040QosPreemptModeEnum];

/**
 * 
 * @export
 * @interface V0040ReservationCoreSpec
 */
export interface V0040ReservationCoreSpec {
    /**
     * Name of reserved node
     * @type {string}
     * @memberof V0040ReservationCoreSpec
     */
    'node'?: string;
    /**
     * IDs of reserved cores
     * @type {string}
     * @memberof V0040ReservationCoreSpec
     */
    'core'?: string;
}
/**
 * 
 * @export
 * @interface V0040ReservationInfo
 */
export interface V0040ReservationInfo {
    /**
     * Comma separated list of permitted accounts
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'accounts'?: string;
    /**
     * BurstBuffer
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'burst_buffer'?: string;
    /**
     * CoreCnt
     * @type {number}
     * @memberof V0040ReservationInfo
     */
    'core_count'?: number;
    /**
     * 
     * @type {Array<V0040ReservationCoreSpec>}
     * @memberof V0040ReservationInfo
     */
    'core_specializations'?: Array<V0040ReservationCoreSpec>;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040ReservationInfo
     */
    'end_time'?: V0040Uint64NoVal;
    /**
     * Features
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'features'?: string;
    /**
     * Flags associated with the reservation
     * @type {Array<string>}
     * @memberof V0040ReservationInfo
     */
    'flags'?: Array<V0040ReservationInfoFlagsEnum>;
    /**
     * Groups
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'groups'?: string;
    /**
     * Licenses
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'licenses'?: string;
    /**
     * MaxStartDelay in seconds
     * @type {number}
     * @memberof V0040ReservationInfo
     */
    'max_start_delay'?: number;
    /**
     * ReservationName
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'name'?: string;
    /**
     * NodeCnt
     * @type {number}
     * @memberof V0040ReservationInfo
     */
    'node_count'?: number;
    /**
     * Nodes
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'node_list'?: string;
    /**
     * PartitionName
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'partition'?: string;
    /**
     * 
     * @type {V0040ReservationInfoPurgeCompleted}
     * @memberof V0040ReservationInfo
     */
    'purge_completed'?: V0040ReservationInfoPurgeCompleted;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040ReservationInfo
     */
    'start_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040ReservationInfo
     */
    'watts'?: V0040Uint32NoVal;
    /**
     * Comma separated list of required TRES
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'tres'?: string;
    /**
     * Comma separated list of permitted users
     * @type {string}
     * @memberof V0040ReservationInfo
     */
    'users'?: string;
}

export const V0040ReservationInfoFlagsEnum = {
    Maint: 'MAINT',
    NoMaint: 'NO_MAINT',
    Daily: 'DAILY',
    NoDaily: 'NO_DAILY',
    Weekly: 'WEEKLY',
    NoWeekly: 'NO_WEEKLY',
    IgnoreJobs: 'IGNORE_JOBS',
    NoIgnoreJobs: 'NO_IGNORE_JOBS',
    AnyNodes: 'ANY_NODES',
    Static: 'STATIC',
    NoStatic: 'NO_STATIC',
    PartNodes: 'PART_NODES',
    NoPartNodes: 'NO_PART_NODES',
    Overlap: 'OVERLAP',
    SpecNodes: 'SPEC_NODES',
    TimeFloat: 'TIME_FLOAT',
    Replace: 'REPLACE',
    AllNodes: 'ALL_NODES',
    PurgeComp: 'PURGE_COMP',
    Weekday: 'WEEKDAY',
    NoWeekday: 'NO_WEEKDAY',
    Weekend: 'WEEKEND',
    NoWeekend: 'NO_WEEKEND',
    Flex: 'FLEX',
    NoFlex: 'NO_FLEX',
    DurationPlus: 'DURATION_PLUS',
    DurationMinus: 'DURATION_MINUS',
    NoHoldJobsAfterEnd: 'NO_HOLD_JOBS_AFTER_END',
    NoPurgeComp: 'NO_PURGE_COMP',
    Magnetic: 'MAGNETIC',
    Skip: 'SKIP',
    Hourly: 'HOURLY',
    NoHourly: 'NO_HOURLY',
    Reoccurring: 'REOCCURRING'
} as const;

export type V0040ReservationInfoFlagsEnum = typeof V0040ReservationInfoFlagsEnum[keyof typeof V0040ReservationInfoFlagsEnum];

/**
 * 
 * @export
 * @interface V0040ReservationInfoPurgeCompleted
 */
export interface V0040ReservationInfoPurgeCompleted {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040ReservationInfoPurgeCompleted
     */
    'time'?: V0040Uint32NoVal;
}
/**
 * recorded rollup statistics
 * @export
 * @interface V0040RollupStatsInner
 */
export interface V0040RollupStatsInner {
    /**
     * type
     * @type {string}
     * @memberof V0040RollupStatsInner
     */
    'type'?: V0040RollupStatsInnerTypeEnum;
    /**
     * Last time rollup ran (UNIX timestamp)
     * @type {number}
     * @memberof V0040RollupStatsInner
     */
    'last run'?: number;
    /**
     * longest rollup time (seconds)
     * @type {number}
     * @memberof V0040RollupStatsInner
     */
    'max_cycle'?: number;
    /**
     * total time spent doing rollups (seconds)
     * @type {number}
     * @memberof V0040RollupStatsInner
     */
    'total_time'?: number;
    /**
     * number of rollups since last_run
     * @type {number}
     * @memberof V0040RollupStatsInner
     */
    'total_cycles'?: number;
    /**
     * average time for rollup (seconds)
     * @type {number}
     * @memberof V0040RollupStatsInner
     */
    'mean_cycles'?: number;
}

export const V0040RollupStatsInnerTypeEnum = {
    Internal: 'internal',
    User: 'user',
    Unknown: 'unknown'
} as const;

export type V0040RollupStatsInnerTypeEnum = typeof V0040RollupStatsInnerTypeEnum[keyof typeof V0040RollupStatsInnerTypeEnum];

/**
 * 
 * @export
 * @interface V0040ScheduleExitFields
 */
export interface V0040ScheduleExitFields {
    /**
     * Reached end of queue
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'end_job_queue'?: number;
    /**
     * Reached number of jobs allowed to be tested
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'default_queue_depth'?: number;
    /**
     * Reached number of jobs allowed to start
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'max_job_start'?: number;
    /**
     * Reached RPC limit
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'max_rpc_cnt'?: number;
    /**
     * Reached maximum allowed scheduler time
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'max_sched_time'?: number;
    /**
     * Blocked on licenses
     * @type {number}
     * @memberof V0040ScheduleExitFields
     */
    'licenses'?: number;
}
/**
 * 
 * @export
 * @interface V0040SharesFloat128Tres
 */
export interface V0040SharesFloat128Tres {
    /**
     * TRES name
     * @type {string}
     * @memberof V0040SharesFloat128Tres
     */
    'name'?: string;
    /**
     * TRES value
     * @type {number}
     * @memberof V0040SharesFloat128Tres
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface V0040SharesRespMsg
 */
export interface V0040SharesRespMsg {
    /**
     * 
     * @type {Array<V0040AssocSharesObjWrap>}
     * @memberof V0040SharesRespMsg
     */
    'shares'?: Array<V0040AssocSharesObjWrap>;
    /**
     * Total number of shares
     * @type {number}
     * @memberof V0040SharesRespMsg
     */
    'total_shares'?: number;
}
/**
 * 
 * @export
 * @interface V0040SharesUint64Tres
 */
export interface V0040SharesUint64Tres {
    /**
     * TRES name
     * @type {string}
     * @memberof V0040SharesUint64Tres
     */
    'name'?: string;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040SharesUint64Tres
     */
    'value'?: V0040Uint64NoVal;
}
/**
 * 
 * @export
 * @interface V0040StatsMsg
 */
export interface V0040StatsMsg {
    /**
     * Zero if only RPC statistic included
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'parts_packed'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StatsMsg
     */
    'req_time'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StatsMsg
     */
    'req_time_start'?: V0040Uint64NoVal;
    /**
     * Number of current active slurmctld threads
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'server_thread_count'?: number;
    /**
     * Number of enqueued outgoing RPC requests in an internal retry list
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'agent_queue_size'?: number;
    /**
     * Number of agent threads
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'agent_count'?: number;
    /**
     * Total number of active threads created by all agent threads
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'agent_thread_count'?: number;
    /**
     * Number of messages for SlurmDBD that are queued
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'dbd_agent_queue_size'?: number;
    /**
     * Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'gettimeofday_latency'?: number;
    /**
     * Max time of any scheduling cycle in microseconds since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_max'?: number;
    /**
     * Time in microseconds for last scheduling cycle
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_last'?: number;
    /**
     * Number of scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_total'?: number;
    /**
     * Mean time in microseconds for all scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_mean'?: number;
    /**
     * Mean of the number of jobs processed in a scheduling cycle
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_mean_depth'?: number;
    /**
     * Number of scheduling executions per minute
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_cycle_per_minute'?: number;
    /**
     * Number of jobs pending in queue
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'schedule_queue_length'?: number;
    /**
     * 
     * @type {V0040ScheduleExitFields}
     * @memberof V0040StatsMsg
     */
    'schedule_exit'?: V0040ScheduleExitFields;
    /**
     * Number of jobs submitted since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_submitted'?: number;
    /**
     * Number of jobs started since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_started'?: number;
    /**
     * Number of jobs completed since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_completed'?: number;
    /**
     * Number of jobs canceled since the last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_canceled'?: number;
    /**
     * Number of jobs failed due to slurmd or other internal issues since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_failed'?: number;
    /**
     * Number of jobs pending at the time of listed in job_state_ts
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_pending'?: number;
    /**
     * Number of jobs running at the time of listed in job_state_ts
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'jobs_running'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StatsMsg
     */
    'job_states_ts'?: V0040Uint64NoVal;
    /**
     * Number of jobs started through backfilling since last slurm start
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_backfilled_jobs'?: number;
    /**
     * Number of jobs started through backfilling since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_last_backfilled_jobs'?: number;
    /**
     * Number of heterogeneous job components started through backfilling since last Slurm start
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_backfilled_het_jobs'?: number;
    /**
     * Number of backfill scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_cycle_counter'?: number;
    /**
     * Mean time in microseconds of backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_cycle_mean'?: number;
    /**
     * Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_depth_mean'?: number;
    /**
     * The subset of Depth Mean that the backfill scheduler attempted to schedule
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_depth_mean_try'?: number;
    /**
     * Total time in microseconds of backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_cycle_sum'?: number;
    /**
     * Execution time in microseconds of last backfill scheduling cycle
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_cycle_last'?: number;
    /**
     * Number of processed jobs during last backfilling scheduling cycle
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_last_depth'?: number;
    /**
     * Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_last_depth_try'?: number;
    /**
     * Total number of jobs processed during all backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_depth_sum'?: number;
    /**
     * Subset of bf_depth_sum that the backfill scheduler attempted to schedule
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_depth_try_sum'?: number;
    /**
     * Number of jobs pending to be processed by backfilling algorithm
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_queue_len'?: number;
    /**
     * Mean number of jobs pending to be processed by backfilling algorithm
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_queue_len_mean'?: number;
    /**
     * Total number of jobs pending to be processed by backfilling algorithm since last reset
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_queue_len_sum'?: number;
    /**
     * Number of different time slots tested by the backfill scheduler in its last iteration
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_table_size'?: number;
    /**
     * Mean number of different time slots tested by the backfill scheduler
     * @type {number}
     * @memberof V0040StatsMsg
     */
    'bf_table_size_mean'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StatsMsg
     */
    'bf_when_last_cycle'?: V0040Uint64NoVal;
    /**
     * Backfill scheduler currently running
     * @type {boolean}
     * @memberof V0040StatsMsg
     */
    'bf_active'?: boolean;
    /**
     * 
     * @type {V0040BfExitFields}
     * @memberof V0040StatsMsg
     */
    'bf_exit'?: V0040BfExitFields;
    /**
     * RPCs by message type
     * @type {Array<V0040StatsMsgRpcsByTypeInner>}
     * @memberof V0040StatsMsg
     */
    'rpcs_by_message_type'?: Array<V0040StatsMsgRpcsByTypeInner>;
    /**
     * RPCs by user
     * @type {Array<V0040StatsMsgRpcsByUserInner>}
     * @memberof V0040StatsMsg
     */
    'rpcs_by_user'?: Array<V0040StatsMsgRpcsByUserInner>;
}
/**
 * RPC
 * @export
 * @interface V0040StatsMsgRpcsByTypeInner
 */
export interface V0040StatsMsgRpcsByTypeInner {
    /**
     * Message type as string
     * @type {string}
     * @memberof V0040StatsMsgRpcsByTypeInner
     */
    'message_type'?: string;
    /**
     * Message type as integer
     * @type {number}
     * @memberof V0040StatsMsgRpcsByTypeInner
     */
    'type_id'?: number;
    /**
     * Number of RPCs received
     * @type {number}
     * @memberof V0040StatsMsgRpcsByTypeInner
     */
    'count'?: number;
    /**
     * Average time spent processing RPC in seconds
     * @type {number}
     * @memberof V0040StatsMsgRpcsByTypeInner
     */
    'average_time'?: number;
    /**
     * Total time spent processing RPC in seconds
     * @type {number}
     * @memberof V0040StatsMsgRpcsByTypeInner
     */
    'total_time'?: number;
}
/**
 * user
 * @export
 * @interface V0040StatsMsgRpcsByUserInner
 */
export interface V0040StatsMsgRpcsByUserInner {
    /**
     * user name
     * @type {string}
     * @memberof V0040StatsMsgRpcsByUserInner
     */
    'user'?: string;
    /**
     * user id (numeric)
     * @type {number}
     * @memberof V0040StatsMsgRpcsByUserInner
     */
    'user_id'?: number;
    /**
     * Number of RPCs received
     * @type {number}
     * @memberof V0040StatsMsgRpcsByUserInner
     */
    'count'?: number;
    /**
     * Average time spent processing RPC in seconds
     * @type {number}
     * @memberof V0040StatsMsgRpcsByUserInner
     */
    'average_time'?: number;
    /**
     * Total time spent processing RPC in seconds
     * @type {number}
     * @memberof V0040StatsMsgRpcsByUserInner
     */
    'total_time'?: number;
}
/**
 * 
 * @export
 * @interface V0040StatsRec
 */
export interface V0040StatsRec {
    /**
     * When data collection started (UNIX timestamp)
     * @type {number}
     * @memberof V0040StatsRec
     */
    'time_start'?: number;
    /**
     * list of recorded rollup statistics
     * @type {Array<V0040RollupStatsInner>}
     * @memberof V0040StatsRec
     */
    'rollups'?: Array<V0040RollupStatsInner>;
    /**
     * 
     * @type {Array<V0040StatsRpc>}
     * @memberof V0040StatsRec
     */
    'RPCs'?: Array<V0040StatsRpc>;
    /**
     * 
     * @type {Array<V0040StatsUser>}
     * @memberof V0040StatsRec
     */
    'users'?: Array<V0040StatsUser>;
}
/**
 * 
 * @export
 * @interface V0040StatsRpc
 */
export interface V0040StatsRpc {
    /**
     * RPC type
     * @type {string}
     * @memberof V0040StatsRpc
     */
    'rpc'?: string;
    /**
     * Number of RPCs processed
     * @type {number}
     * @memberof V0040StatsRpc
     */
    'count'?: number;
    /**
     * 
     * @type {V0040StatsRpcTime}
     * @memberof V0040StatsRpc
     */
    'time'?: V0040StatsRpcTime;
}
/**
 * 
 * @export
 * @interface V0040StatsRpcTime
 */
export interface V0040StatsRpcTime {
    /**
     * Average RPC processing time in microseconds
     * @type {number}
     * @memberof V0040StatsRpcTime
     */
    'average'?: number;
    /**
     * Total RPC processing time in microseconds
     * @type {number}
     * @memberof V0040StatsRpcTime
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface V0040StatsUser
 */
export interface V0040StatsUser {
    /**
     * User ID
     * @type {string}
     * @memberof V0040StatsUser
     */
    'user'?: string;
    /**
     * Number of RPCs processed
     * @type {number}
     * @memberof V0040StatsUser
     */
    'count'?: number;
    /**
     * 
     * @type {V0040StatsRpcTime}
     * @memberof V0040StatsUser
     */
    'time'?: V0040StatsRpcTime;
}
/**
 * 
 * @export
 * @interface V0040Step
 */
export interface V0040Step {
    /**
     * 
     * @type {V0040StepTime}
     * @memberof V0040Step
     */
    'time'?: V0040StepTime;
    /**
     * 
     * @type {V0040ProcessExitCodeVerbose}
     * @memberof V0040Step
     */
    'exit_code'?: V0040ProcessExitCodeVerbose;
    /**
     * 
     * @type {V0040StepNodes}
     * @memberof V0040Step
     */
    'nodes'?: V0040StepNodes;
    /**
     * 
     * @type {V0040StepTasks}
     * @memberof V0040Step
     */
    'tasks'?: V0040StepTasks;
    /**
     * Process ID
     * @type {string}
     * @memberof V0040Step
     */
    'pid'?: string;
    /**
     * 
     * @type {V0040StepCPU}
     * @memberof V0040Step
     */
    'CPU'?: V0040StepCPU;
    /**
     * User ID that requested termination of the step
     * @type {string}
     * @memberof V0040Step
     */
    'kill_request_user'?: string;
    /**
     * Current state
     * @type {Array<string>}
     * @memberof V0040Step
     */
    'state'?: Array<V0040StepStateEnum>;
    /**
     * 
     * @type {V0040StepStatistics}
     * @memberof V0040Step
     */
    'statistics'?: V0040StepStatistics;
    /**
     * 
     * @type {V0040StepStep}
     * @memberof V0040Step
     */
    'step'?: V0040StepStep;
    /**
     * 
     * @type {V0040StepTask}
     * @memberof V0040Step
     */
    'task'?: V0040StepTask;
    /**
     * 
     * @type {V0040StepTres}
     * @memberof V0040Step
     */
    'tres'?: V0040StepTres;
}

export const V0040StepStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0040StepStateEnum = typeof V0040StepStateEnum[keyof typeof V0040StepStateEnum];

/**
 * 
 * @export
 * @interface V0040StepCPU
 */
export interface V0040StepCPU {
    /**
     * 
     * @type {V0040StepCPURequestedFrequency}
     * @memberof V0040StepCPU
     */
    'requested_frequency'?: V0040StepCPURequestedFrequency;
    /**
     * Requested CPU frequency governor in kHz
     * @type {string}
     * @memberof V0040StepCPU
     */
    'governor'?: string;
}
/**
 * 
 * @export
 * @interface V0040StepCPURequestedFrequency
 */
export interface V0040StepCPURequestedFrequency {
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040StepCPURequestedFrequency
     */
    'min'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040StepCPURequestedFrequency
     */
    'max'?: V0040Uint32NoVal;
}
/**
 * 
 * @export
 * @interface V0040StepNodes
 */
export interface V0040StepNodes {
    /**
     * Number of nodes in the job step
     * @type {number}
     * @memberof V0040StepNodes
     */
    'count'?: number;
    /**
     * Node(s) allocated to the job step
     * @type {string}
     * @memberof V0040StepNodes
     */
    'range'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040StepNodes
     */
    'list'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0040StepStatistics
 */
export interface V0040StepStatistics {
    /**
     * 
     * @type {V0040StepStatisticsCPU}
     * @memberof V0040StepStatistics
     */
    'CPU'?: V0040StepStatisticsCPU;
    /**
     * 
     * @type {V0040StepStatisticsEnergy}
     * @memberof V0040StepStatistics
     */
    'energy'?: V0040StepStatisticsEnergy;
}
/**
 * 
 * @export
 * @interface V0040StepStatisticsCPU
 */
export interface V0040StepStatisticsCPU {
    /**
     * Average weighted CPU frequency of all tasks in kHz
     * @type {number}
     * @memberof V0040StepStatisticsCPU
     */
    'actual_frequency'?: number;
}
/**
 * 
 * @export
 * @interface V0040StepStatisticsEnergy
 */
export interface V0040StepStatisticsEnergy {
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StepStatisticsEnergy
     */
    'consumed'?: V0040Uint64NoVal;
}
/**
 * 
 * @export
 * @interface V0040StepStep
 */
export interface V0040StepStep {
    /**
     * Slurm Job Step ID
     * @type {string}
     * @memberof V0040StepStep
     */
    'id'?: string;
    /**
     * Step name
     * @type {string}
     * @memberof V0040StepStep
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0040StepTask
 */
export interface V0040StepTask {
    /**
     * The layout of the step was when it was running
     * @type {string}
     * @memberof V0040StepTask
     */
    'distribution'?: string;
}
/**
 * 
 * @export
 * @interface V0040StepTasks
 */
export interface V0040StepTasks {
    /**
     * Total number of tasks
     * @type {number}
     * @memberof V0040StepTasks
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface V0040StepTime
 */
export interface V0040StepTime {
    /**
     * Elapsed time in seconds
     * @type {number}
     * @memberof V0040StepTime
     */
    'elapsed'?: number;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StepTime
     */
    'end'?: V0040Uint64NoVal;
    /**
     * 
     * @type {V0040Uint64NoVal}
     * @memberof V0040StepTime
     */
    'start'?: V0040Uint64NoVal;
    /**
     * Time in suspended state in seconds
     * @type {number}
     * @memberof V0040StepTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0040StepTimeSystem}
     * @memberof V0040StepTime
     */
    'system'?: V0040StepTimeSystem;
    /**
     * 
     * @type {V0040StepTimeTotal}
     * @memberof V0040StepTime
     */
    'total'?: V0040StepTimeTotal;
    /**
     * 
     * @type {V0040StepTimeUser}
     * @memberof V0040StepTime
     */
    'user'?: V0040StepTimeUser;
}
/**
 * 
 * @export
 * @interface V0040StepTimeSystem
 */
export interface V0040StepTimeSystem {
    /**
     * System CPU time used by the step in seconds
     * @type {number}
     * @memberof V0040StepTimeSystem
     */
    'seconds'?: number;
    /**
     * System CPU time used by the step in microseconds
     * @type {number}
     * @memberof V0040StepTimeSystem
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040StepTimeTotal
 */
export interface V0040StepTimeTotal {
    /**
     * Total CPU time used by the step in seconds
     * @type {number}
     * @memberof V0040StepTimeTotal
     */
    'seconds'?: number;
    /**
     * Total CPU time used by the step in microseconds
     * @type {number}
     * @memberof V0040StepTimeTotal
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040StepTimeUser
 */
export interface V0040StepTimeUser {
    /**
     * User CPU time used by the step in seconds
     * @type {number}
     * @memberof V0040StepTimeUser
     */
    'seconds'?: number;
    /**
     * User CPU time used by the step in microseconds
     * @type {number}
     * @memberof V0040StepTimeUser
     */
    'microseconds'?: number;
}
/**
 * 
 * @export
 * @interface V0040StepTres
 */
export interface V0040StepTres {
    /**
     * 
     * @type {V0040StepTresRequested}
     * @memberof V0040StepTres
     */
    'requested'?: V0040StepTresRequested;
    /**
     * 
     * @type {V0040StepTresConsumed}
     * @memberof V0040StepTres
     */
    'consumed'?: V0040StepTresConsumed;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTres
     */
    'allocated'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040StepTresConsumed
 */
export interface V0040StepTresConsumed {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresConsumed
     */
    'max'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresConsumed
     */
    'min'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresConsumed
     */
    'average'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresConsumed
     */
    'total'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040StepTresRequested
 */
export interface V0040StepTresRequested {
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresRequested
     */
    'max'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresRequested
     */
    'min'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresRequested
     */
    'average'?: Array<V0040Tres>;
    /**
     * 
     * @type {Array<V0040Tres>}
     * @memberof V0040StepTresRequested
     */
    'total'?: Array<V0040Tres>;
}
/**
 * 
 * @export
 * @interface V0040Tres
 */
export interface V0040Tres {
    /**
     * TRES type (CPU, MEM, etc)
     * @type {string}
     * @memberof V0040Tres
     */
    'type': string;
    /**
     * TRES name (if applicable)
     * @type {string}
     * @memberof V0040Tres
     */
    'name'?: string;
    /**
     * ID used in database
     * @type {number}
     * @memberof V0040Tres
     */
    'id'?: number;
    /**
     * TRES count (0 if listed generically)
     * @type {number}
     * @memberof V0040Tres
     */
    'count'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0040Uint16NoVal
 */
export interface V0040Uint16NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0040Uint16NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0040Uint16NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0040Uint16NoVal
     */
    'number'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0040Uint32NoVal
 */
export interface V0040Uint32NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0040Uint32NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0040Uint32NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0040Uint32NoVal
     */
    'number'?: number;
}
/**
 * Integer number with flags
 * @export
 * @interface V0040Uint64NoVal
 */
export interface V0040Uint64NoVal {
    /**
     * True if number has been set. False if number is unset
     * @type {boolean}
     * @memberof V0040Uint64NoVal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite. \"set\" and \"number\" will be ignored.
     * @type {boolean}
     * @memberof V0040Uint64NoVal
     */
    'infinite'?: boolean;
    /**
     * If set is True the number will be set with value. Otherwise ignore number contents.
     * @type {number}
     * @memberof V0040Uint64NoVal
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0040UpdateNodeMsg
 */
export interface V0040UpdateNodeMsg {
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0040UpdateNodeMsg
     */
    'comment'?: string;
    /**
     * Default method for binding tasks to allocated CPUs
     * @type {number}
     * @memberof V0040UpdateNodeMsg
     */
    'cpu_bind'?: number;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0040UpdateNodeMsg
     */
    'extra'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'features_act'?: Array<string>;
    /**
     * Generic resources
     * @type {string}
     * @memberof V0040UpdateNodeMsg
     */
    'gres'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'address'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'hostname'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'name'?: Array<string>;
    /**
     * New state to assign to the node
     * @type {Array<string>}
     * @memberof V0040UpdateNodeMsg
     */
    'state'?: Array<V0040UpdateNodeMsgStateEnum>;
    /**
     * Reason for node being DOWN or DRAINING
     * @type {string}
     * @memberof V0040UpdateNodeMsg
     */
    'reason'?: string;
    /**
     * User ID to associate with the reason (needed if user root is sending message)
     * @type {string}
     * @memberof V0040UpdateNodeMsg
     */
    'reason_uid'?: string;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040UpdateNodeMsg
     */
    'resume_after'?: V0040Uint32NoVal;
    /**
     * 
     * @type {V0040Uint32NoVal}
     * @memberof V0040UpdateNodeMsg
     */
    'weight'?: V0040Uint32NoVal;
}

export const V0040UpdateNodeMsgStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0040UpdateNodeMsgStateEnum = typeof V0040UpdateNodeMsgStateEnum[keyof typeof V0040UpdateNodeMsgStateEnum];

/**
 * 
 * @export
 * @interface V0040User
 */
export interface V0040User {
    /**
     * AdminLevel granted to the user
     * @type {Array<string>}
     * @memberof V0040User
     */
    'administrator_level'?: Array<V0040UserAdministratorLevelEnum>;
    /**
     * 
     * @type {Array<V0040AssocShort>}
     * @memberof V0040User
     */
    'associations'?: Array<V0040AssocShort>;
    /**
     * 
     * @type {Array<V0040Coord>}
     * @memberof V0040User
     */
    'coordinators'?: Array<V0040Coord>;
    /**
     * 
     * @type {V0040UserDefault}
     * @memberof V0040User
     */
    'default'?: V0040UserDefault;
    /**
     * Flags associated with user
     * @type {Array<string>}
     * @memberof V0040User
     */
    'flags'?: Array<V0040UserFlagsEnum>;
    /**
     * User name
     * @type {string}
     * @memberof V0040User
     */
    'name': string;
    /**
     * Previous user name
     * @type {string}
     * @memberof V0040User
     */
    'old_name'?: string;
    /**
     * 
     * @type {Array<V0040Wckey>}
     * @memberof V0040User
     */
    'wckeys'?: Array<V0040Wckey>;
}

export const V0040UserAdministratorLevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;

export type V0040UserAdministratorLevelEnum = typeof V0040UserAdministratorLevelEnum[keyof typeof V0040UserAdministratorLevelEnum];
export const V0040UserFlagsEnum = {
    None: 'NONE',
    Deleted: 'DELETED'
} as const;

export type V0040UserFlagsEnum = typeof V0040UserFlagsEnum[keyof typeof V0040UserFlagsEnum];

/**
 * 
 * @export
 * @interface V0040UserDefault
 */
export interface V0040UserDefault {
    /**
     * Default Account
     * @type {string}
     * @memberof V0040UserDefault
     */
    'account'?: string;
    /**
     * Default WCKey
     * @type {string}
     * @memberof V0040UserDefault
     */
    'wckey'?: string;
}
/**
 * 
 * @export
 * @interface V0040UserShort
 */
export interface V0040UserShort {
    /**
     * AdminLevel granted to the user
     * @type {Array<string>}
     * @memberof V0040UserShort
     */
    'adminlevel'?: Array<V0040UserShortAdminlevelEnum>;
    /**
     * Default account
     * @type {string}
     * @memberof V0040UserShort
     */
    'defaultaccount'?: string;
    /**
     * Default WCKey
     * @type {string}
     * @memberof V0040UserShort
     */
    'defaultwckey'?: string;
}

export const V0040UserShortAdminlevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;

export type V0040UserShortAdminlevelEnum = typeof V0040UserShortAdminlevelEnum[keyof typeof V0040UserShortAdminlevelEnum];

/**
 * 
 * @export
 * @interface V0040UsersAddCond
 */
export interface V0040UsersAddCond {
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UsersAddCond
     */
    'accounts'?: Array<string>;
    /**
     * 
     * @type {V0040AssocRecSet}
     * @memberof V0040UsersAddCond
     */
    'association'?: V0040AssocRecSet;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UsersAddCond
     */
    'clusters'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UsersAddCond
     */
    'partitions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UsersAddCond
     */
    'users': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0040UsersAddCond
     */
    'wckeys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0040Wckey
 */
export interface V0040Wckey {
    /**
     * 
     * @type {Array<V0040Accounting>}
     * @memberof V0040Wckey
     */
    'accounting'?: Array<V0040Accounting>;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0040Wckey
     */
    'cluster': string;
    /**
     * Unique ID for this user-cluster-wckey combination
     * @type {number}
     * @memberof V0040Wckey
     */
    'id'?: number;
    /**
     * WCKey name
     * @type {string}
     * @memberof V0040Wckey
     */
    'name': string;
    /**
     * User name
     * @type {string}
     * @memberof V0040Wckey
     */
    'user': string;
    /**
     * Flags associated with the WCKey
     * @type {Array<string>}
     * @memberof V0040Wckey
     */
    'flags'?: Array<V0040WckeyFlagsEnum>;
}

export const V0040WckeyFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0040WckeyFlagsEnum = typeof V0040WckeyFlagsEnum[keyof typeof V0040WckeyFlagsEnum];

/**
 * 
 * @export
 * @interface V0040WckeyTagStruct
 */
export interface V0040WckeyTagStruct {
    /**
     * WCKey name
     * @type {string}
     * @memberof V0040WckeyTagStruct
     */
    'wckey': string;
    /**
     * Active flags
     * @type {Array<string>}
     * @memberof V0040WckeyTagStruct
     */
    'flags': Array<V0040WckeyTagStructFlagsEnum>;
}

export const V0040WckeyTagStructFlagsEnum = {
    AssignedDefault: 'ASSIGNED_DEFAULT'
} as const;

export type V0040WckeyTagStructFlagsEnum = typeof V0040WckeyTagStructFlagsEnum[keyof typeof V0040WckeyTagStructFlagsEnum];

/**
 * 
 * @export
 * @interface V0041JobAllocReq
 */
export interface V0041JobAllocReq {
    /**
     * HetJob description
     * @type {Array<V0041JobDescMsg>}
     * @memberof V0041JobAllocReq
     */
    'hetjob'?: Array<V0041JobDescMsg>;
    /**
     * 
     * @type {V0041JobDescMsg}
     * @memberof V0041JobAllocReq
     */
    'job'?: V0041JobDescMsg;
}
/**
 * 
 * @export
 * @interface V0041JobDescMsg
 */
export interface V0041JobDescMsg {
    /**
     * Account associated with the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'account'?: string;
    /**
     * Job accounting and profiling sampling intervals in seconds
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'account_gather_frequency'?: string;
    /**
     * Arbitrary comment made by administrator
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'admin_comment'?: string;
    /**
     * Local node making the resource allocation
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'allocation_node_list'?: string;
    /**
     * Port to send allocation confirmation to
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'allocation_node_port'?: number;
    /**
     * Arguments to the script
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'argv'?: Array<string>;
    /**
     * Job array index value specification
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'array'?: string;
    /**
     * Features required for batch script\'s node
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'batch_features'?: string;
    /**
     * 
     * @type {V0041JobDescMsgBeginTime}
     * @memberof V0041JobDescMsg
     */
    'begin_time'?: V0041JobDescMsgBeginTime;
    /**
     * Job flags
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'flags'?: Array<V0041JobDescMsgFlagsEnum>;
    /**
     * Burst buffer specifications
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'burst_buffer'?: string;
    /**
     * Clusters that a federated job can run on
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'clusters'?: string;
    /**
     * Required features that a federated cluster must have to have a sibling job submitted to it
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'cluster_constraint'?: string;
    /**
     * Arbitrary comment made by user
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'comment'?: string;
    /**
     * True if job requires contiguous nodes
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'contiguous'?: boolean;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'container'?: string;
    /**
     * OCI container ID
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'container_id'?: string;
    /**
     * Specialized core count
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'core_specification'?: number;
    /**
     * Specialized thread count
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'thread_specification'?: number;
    /**
     * Method for binding tasks to allocated CPUs
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'cpu_binding'?: string;
    /**
     * Flags for CPU binding
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'cpu_binding_flags'?: Array<V0041JobDescMsgCpuBindingFlagsEnum>;
    /**
     * Requested CPU frequency range <p1>[-p2][:p3]
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'cpu_frequency'?: string;
    /**
     * Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'cpus_per_tres'?: string;
    /**
     * 
     * @type {V0041JobDescMsgCrontab}
     * @memberof V0041JobDescMsg
     */
    'crontab'?: V0041JobDescMsgCrontab;
    /**
     * Latest time that the job may start (UNIX timestamp)
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'deadline'?: number;
    /**
     * Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'delay_boot'?: number;
    /**
     * Other jobs that must meet certain criteria before this job can start
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'dependency'?: string;
    /**
     * Expected end time (UNIX timestamp)
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'end_time'?: number;
    /**
     * Environment variables to be set for the job
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'environment'?: Array<string>;
    /**
     * 
     * @type {V0041JobDescMsgRlimits}
     * @memberof V0041JobDescMsg
     */
    'rlimits'?: V0041JobDescMsgRlimits;
    /**
     * Comma separated list of nodes that may not be used
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'excluded_nodes'?: Array<string>;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'extra'?: string;
    /**
     * Comma separated list of features that are required
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'constraints'?: string;
    /**
     * Group ID of the user that owns the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'group_id'?: string;
    /**
     * Unique sequence number applied to this component of the heterogeneous job
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'hetjob_group'?: number;
    /**
     * If true, exit if resources are not available within the time period specified
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'immediate'?: boolean;
    /**
     * Job ID
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'job_id'?: number;
    /**
     * If true, kill job on node failure
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'kill_on_node_fail'?: boolean;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'licenses'?: string;
    /**
     * Mail event type(s)
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'mail_type'?: Array<V0041JobDescMsgMailTypeEnum>;
    /**
     * User to receive email notifications
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'mail_user'?: string;
    /**
     * Multi-Category Security label on the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'mcs_label'?: string;
    /**
     * Binding map for map/mask_cpu
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'memory_binding'?: string;
    /**
     * Method for binding tasks to memory
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'memory_binding_type'?: Array<V0041JobDescMsgMemoryBindingTypeEnum>;
    /**
     * Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'memory_per_tres'?: string;
    /**
     * Job name
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'name'?: string;
    /**
     * Network specs for job step
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'network'?: string;
    /**
     * Requested job priority change
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'nice'?: number;
    /**
     * Number of tasks
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'tasks'?: number;
    /**
     * Open mode used for stdout and stderr files
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'open_mode'?: Array<V0041JobDescMsgOpenModeEnum>;
    /**
     * Port to send various notification msg to
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'reserve_ports'?: number;
    /**
     * Overcommit resources
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'overcommit'?: boolean;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'partition'?: string;
    /**
     * 
     * @type {V0041JobDescMsgDistributionPlaneSize}
     * @memberof V0041JobDescMsg
     */
    'distribution_plane_size'?: V0041JobDescMsgDistributionPlaneSize;
    /**
     * 
     * @type {Array<any>}
     * @memberof V0041JobDescMsg
     * @deprecated
     */
    'power_flags'?: Array<any>;
    /**
     * Comma separated list of features that are preferred but not required
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'prefer'?: string;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0041JobDescMsgPriority}
     * @memberof V0041JobDescMsg
     */
    'priority'?: V0041JobDescMsgPriority;
    /**
     * Profile used by the acct_gather_profile plugin
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'profile'?: Array<V0041JobDescMsgProfileEnum>;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'qos'?: string;
    /**
     * Node reboot requested before start
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'reboot'?: boolean;
    /**
     * Comma separated list of required nodes
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'required_nodes'?: Array<string>;
    /**
     * Determines whether the job may be requeued
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'requeue'?: boolean;
    /**
     * Name of reservation to use
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'reservation'?: string;
    /**
     * Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'resv_mpi_ports'?: number;
    /**
     * Job batch script; only the first component in a HetJob is populated or honored
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'script'?: string;
    /**
     * How the job can share resources with other jobs, if at all
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'shared'?: Array<V0041JobDescMsgSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     * @deprecated
     */
    'exclusive'?: Array<V0041JobDescMsgExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0041JobDescMsg
     * @deprecated
     */
    'oversubscribe'?: boolean;
    /**
     * Site-specific priority factor
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'site_factor'?: number;
    /**
     * Environment variables for job prolog/epilog scripts as set by SPANK plugins
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'spank_environment'?: Array<string>;
    /**
     * Layout
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'distribution'?: string;
    /**
     * 
     * @type {V0041JobDescMsgTimeLimit}
     * @memberof V0041JobDescMsg
     */
    'time_limit'?: V0041JobDescMsgTimeLimit;
    /**
     * 
     * @type {V0041JobDescMsgTimeMinimum}
     * @memberof V0041JobDescMsg
     */
    'time_minimum'?: V0041JobDescMsgTimeMinimum;
    /**
     * Task to TRES binding directives
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_bind'?: string;
    /**
     * TRES frequency directives
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_freq'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_per_job'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every node
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_per_node'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every socket
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_per_socket'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated for every task
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'tres_per_task'?: string;
    /**
     * User ID that owns the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'user_id'?: string;
    /**
     * If true, wait to start until after all nodes have booted
     * @type {boolean}
     * @memberof V0041JobDescMsg
     */
    'wait_all_nodes'?: boolean;
    /**
     * Flags related to job signals
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'kill_warning_flags'?: Array<V0041JobDescMsgKillWarningFlagsEnum>;
    /**
     * Signal to send when approaching end time (e.g. \"10\" or \"USR1\")
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'kill_warning_signal'?: string;
    /**
     * 
     * @type {V0041JobDescMsgKillWarningDelay}
     * @memberof V0041JobDescMsg
     */
    'kill_warning_delay'?: V0041JobDescMsgKillWarningDelay;
    /**
     * Working directory to use for the job
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'current_working_directory'?: string;
    /**
     * Number of CPUs required by each task
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'cpus_per_task'?: number;
    /**
     * Minimum number of CPUs required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'minimum_cpus'?: number;
    /**
     * Maximum number of CPUs required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'maximum_cpus'?: number;
    /**
     * Node count range specification (e.g. 1-15:4)
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'nodes'?: string;
    /**
     * Minimum node count
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'minimum_nodes'?: number;
    /**
     * Maximum node count
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'maximum_nodes'?: number;
    /**
     * Boards per node required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'minimum_boards_per_node'?: number;
    /**
     * Sockets per board required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'minimum_sockets_per_board'?: number;
    /**
     * Sockets per node required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'sockets_per_node'?: number;
    /**
     * Threads per core required
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'threads_per_core'?: number;
    /**
     * Number of tasks to invoke on each node
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'tasks_per_node'?: number;
    /**
     * Number of tasks to invoke on each socket
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'tasks_per_socket'?: number;
    /**
     * Number of tasks to invoke on each core
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'tasks_per_core'?: number;
    /**
     * Number of tasks to invoke on each board
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'tasks_per_board'?: number;
    /**
     * Number of tasks that can access each GPU
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'ntasks_per_tres'?: number;
    /**
     * Minimum number of CPUs per node
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'minimum_cpus_per_node'?: number;
    /**
     * 
     * @type {V0041JobDescMsgMemoryPerCpu}
     * @memberof V0041JobDescMsg
     */
    'memory_per_cpu'?: V0041JobDescMsgMemoryPerCpu;
    /**
     * 
     * @type {V0041JobDescMsgMemoryPerCpu}
     * @memberof V0041JobDescMsg
     */
    'memory_per_node'?: V0041JobDescMsgMemoryPerCpu;
    /**
     * Minimum tmp disk space required per node
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'temporary_disk_per_node'?: number;
    /**
     * SELinux context
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'selinux_context'?: string;
    /**
     * 
     * @type {V0041JobDescMsgRequiredSwitches}
     * @memberof V0041JobDescMsg
     */
    'required_switches'?: V0041JobDescMsgRequiredSwitches;
    /**
     * 
     * @type {V0041JobDescMsgSegmentSize}
     * @memberof V0041JobDescMsg
     */
    'segment_size'?: V0041JobDescMsgSegmentSize;
    /**
     * Path to stderr file
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'standard_error'?: string;
    /**
     * Path to stdin file
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'standard_input'?: string;
    /**
     * Path to stdout file
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'standard_output'?: string;
    /**
     * Maximum time to wait for switches in seconds
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'wait_for_switch'?: number;
    /**
     * Workload characterization key
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'wckey'?: string;
    /**
     * X11 forwarding options
     * @type {Array<string>}
     * @memberof V0041JobDescMsg
     */
    'x11'?: Array<V0041JobDescMsgX11Enum>;
    /**
     * Magic cookie for X11 forwarding
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'x11_magic_cookie'?: string;
    /**
     * Hostname or UNIX socket if x11_target_port=0
     * @type {string}
     * @memberof V0041JobDescMsg
     */
    'x11_target_host'?: string;
    /**
     * TCP port
     * @type {number}
     * @memberof V0041JobDescMsg
     */
    'x11_target_port'?: number;
}

export const V0041JobDescMsgFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GresBindingDisabled: 'GRES_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    StepmgrEnabled: 'STEPMGR_ENABLED'
} as const;

export type V0041JobDescMsgFlagsEnum = typeof V0041JobDescMsgFlagsEnum[keyof typeof V0041JobDescMsgFlagsEnum];
export const V0041JobDescMsgCpuBindingFlagsEnum = {
    CpuBindToThreads: 'CPU_BIND_TO_THREADS',
    CpuBindToCores: 'CPU_BIND_TO_CORES',
    CpuBindToSockets: 'CPU_BIND_TO_SOCKETS',
    CpuBindToLdoms: 'CPU_BIND_TO_LDOMS',
    CpuBindNone: 'CPU_BIND_NONE',
    CpuBindRank: 'CPU_BIND_RANK',
    CpuBindMap: 'CPU_BIND_MAP',
    CpuBindMask: 'CPU_BIND_MASK',
    CpuBindLdrank: 'CPU_BIND_LDRANK',
    CpuBindLdmap: 'CPU_BIND_LDMAP',
    CpuBindLdmask: 'CPU_BIND_LDMASK',
    Verbose: 'VERBOSE',
    CpuBindOneThreadPerCore: 'CPU_BIND_ONE_THREAD_PER_CORE'
} as const;

export type V0041JobDescMsgCpuBindingFlagsEnum = typeof V0041JobDescMsgCpuBindingFlagsEnum[keyof typeof V0041JobDescMsgCpuBindingFlagsEnum];
export const V0041JobDescMsgMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0041JobDescMsgMailTypeEnum = typeof V0041JobDescMsgMailTypeEnum[keyof typeof V0041JobDescMsgMailTypeEnum];
export const V0041JobDescMsgMemoryBindingTypeEnum = {
    None: 'NONE',
    Rank: 'RANK',
    Map: 'MAP',
    Mask: 'MASK',
    Local: 'LOCAL',
    Verbose: 'VERBOSE',
    Sort: 'SORT',
    Prefer: 'PREFER'
} as const;

export type V0041JobDescMsgMemoryBindingTypeEnum = typeof V0041JobDescMsgMemoryBindingTypeEnum[keyof typeof V0041JobDescMsgMemoryBindingTypeEnum];
export const V0041JobDescMsgOpenModeEnum = {
    Append: 'APPEND',
    Truncate: 'TRUNCATE'
} as const;

export type V0041JobDescMsgOpenModeEnum = typeof V0041JobDescMsgOpenModeEnum[keyof typeof V0041JobDescMsgOpenModeEnum];
export const V0041JobDescMsgProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0041JobDescMsgProfileEnum = typeof V0041JobDescMsgProfileEnum[keyof typeof V0041JobDescMsgProfileEnum];
export const V0041JobDescMsgSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs',
    Topo: 'topo'
} as const;

export type V0041JobDescMsgSharedEnum = typeof V0041JobDescMsgSharedEnum[keyof typeof V0041JobDescMsgSharedEnum];
export const V0041JobDescMsgExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs',
    Topo: 'topo'
} as const;

export type V0041JobDescMsgExclusiveEnum = typeof V0041JobDescMsgExclusiveEnum[keyof typeof V0041JobDescMsgExclusiveEnum];
export const V0041JobDescMsgKillWarningFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;

export type V0041JobDescMsgKillWarningFlagsEnum = typeof V0041JobDescMsgKillWarningFlagsEnum[keyof typeof V0041JobDescMsgKillWarningFlagsEnum];
export const V0041JobDescMsgX11Enum = {
    ForwardAllNodes: 'FORWARD_ALL_NODES',
    BatchNode: 'BATCH_NODE',
    FirstNode: 'FIRST_NODE',
    LastNode: 'LAST_NODE'
} as const;

export type V0041JobDescMsgX11Enum = typeof V0041JobDescMsgX11Enum[keyof typeof V0041JobDescMsgX11Enum];

/**
 * Defer the allocation of the job until the specified time (UNIX timestamp)
 * @export
 * @interface V0041JobDescMsgBeginTime
 */
export interface V0041JobDescMsgBeginTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgBeginTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgBeginTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgBeginTime
     */
    'number'?: number;
}
/**
 * Specification for scrontab job
 * @export
 * @interface V0041JobDescMsgCrontab
 */
export interface V0041JobDescMsgCrontab {
    /**
     * Flags
     * @type {Array<string>}
     * @memberof V0041JobDescMsgCrontab
     */
    'flags'?: Array<V0041JobDescMsgCrontabFlagsEnum>;
    /**
     * Ranged string specifying eligible minute values (e.g. 0-10,50)
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'minute'?: string;
    /**
     * Ranged string specifying eligible hour values (e.g. 0-5,23)
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'hour'?: string;
    /**
     * Ranged string specifying eligible day of month values (e.g. 0-10,29)
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'day_of_month'?: string;
    /**
     * Ranged string specifying eligible month values (e.g. 0-5,12)
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'month'?: string;
    /**
     * Ranged string specifying eligible day of week values (e.g.0-3,7)
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'day_of_week'?: string;
    /**
     * Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'specification'?: string;
    /**
     * Command to run
     * @type {string}
     * @memberof V0041JobDescMsgCrontab
     */
    'command'?: string;
    /**
     * 
     * @type {V0040CronEntryLine}
     * @memberof V0041JobDescMsgCrontab
     */
    'line'?: V0040CronEntryLine;
}

export const V0041JobDescMsgCrontabFlagsEnum = {
    Minute: 'WILD_MINUTE',
    Hour: 'WILD_HOUR',
    DayOfMonth: 'WILD_DAY_OF_MONTH',
    Month: 'WILD_MONTH',
    DayOfWeek: 'WILD_DAY_OF_WEEK'
} as const;

export type V0041JobDescMsgCrontabFlagsEnum = typeof V0041JobDescMsgCrontabFlagsEnum[keyof typeof V0041JobDescMsgCrontabFlagsEnum];

/**
 * Plane size specification when distribution specifies plane
 * @export
 * @interface V0041JobDescMsgDistributionPlaneSize
 */
export interface V0041JobDescMsgDistributionPlaneSize {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgDistributionPlaneSize
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgDistributionPlaneSize
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgDistributionPlaneSize
     */
    'number'?: number;
}
/**
 * Number of seconds before end time to send the warning signal
 * @export
 * @interface V0041JobDescMsgKillWarningDelay
 */
export interface V0041JobDescMsgKillWarningDelay {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgKillWarningDelay
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgKillWarningDelay
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgKillWarningDelay
     */
    'number'?: number;
}
/**
 * Minimum memory in megabytes per allocated CPU
 * @export
 * @interface V0041JobDescMsgMemoryPerCpu
 */
export interface V0041JobDescMsgMemoryPerCpu {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgMemoryPerCpu
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgMemoryPerCpu
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgMemoryPerCpu
     */
    'number'?: number;
}
/**
 * Request specific job priority
 * @export
 * @interface V0041JobDescMsgPriority
 */
export interface V0041JobDescMsgPriority {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgPriority
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgPriority
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgPriority
     */
    'number'?: number;
}
/**
 * Maximum number of switches
 * @export
 * @interface V0041JobDescMsgRequiredSwitches
 */
export interface V0041JobDescMsgRequiredSwitches {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRequiredSwitches
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRequiredSwitches
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRequiredSwitches
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041JobDescMsgRlimits
 */
export interface V0041JobDescMsgRlimits {
    /**
     * 
     * @type {V0041JobDescMsgRlimitsCpu}
     * @memberof V0041JobDescMsgRlimits
     */
    'cpu'?: V0041JobDescMsgRlimitsCpu;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsFsize}
     * @memberof V0041JobDescMsgRlimits
     */
    'fsize'?: V0041JobDescMsgRlimitsFsize;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsData}
     * @memberof V0041JobDescMsgRlimits
     */
    'data'?: V0041JobDescMsgRlimitsData;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsStack}
     * @memberof V0041JobDescMsgRlimits
     */
    'stack'?: V0041JobDescMsgRlimitsStack;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsCore}
     * @memberof V0041JobDescMsgRlimits
     */
    'core'?: V0041JobDescMsgRlimitsCore;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsRss}
     * @memberof V0041JobDescMsgRlimits
     */
    'rss'?: V0041JobDescMsgRlimitsRss;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsNproc}
     * @memberof V0041JobDescMsgRlimits
     */
    'nproc'?: V0041JobDescMsgRlimitsNproc;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsNofile}
     * @memberof V0041JobDescMsgRlimits
     */
    'nofile'?: V0041JobDescMsgRlimitsNofile;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsMemlock}
     * @memberof V0041JobDescMsgRlimits
     */
    'memlock'?: V0041JobDescMsgRlimitsMemlock;
    /**
     * 
     * @type {V0041JobDescMsgRlimitsAs}
     * @memberof V0041JobDescMsgRlimits
     */
    'as'?: V0041JobDescMsgRlimitsAs;
}
/**
 * Address space limit.
 * @export
 * @interface V0041JobDescMsgRlimitsAs
 */
export interface V0041JobDescMsgRlimitsAs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsAs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsAs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsAs
     */
    'number'?: number;
}
/**
 * Largest core file that can be created, in bytes.
 * @export
 * @interface V0041JobDescMsgRlimitsCore
 */
export interface V0041JobDescMsgRlimitsCore {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsCore
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsCore
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsCore
     */
    'number'?: number;
}
/**
 * Per-process CPU limit, in seconds.
 * @export
 * @interface V0041JobDescMsgRlimitsCpu
 */
export interface V0041JobDescMsgRlimitsCpu {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsCpu
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsCpu
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsCpu
     */
    'number'?: number;
}
/**
 * Maximum size of data segment, in bytes. 
 * @export
 * @interface V0041JobDescMsgRlimitsData
 */
export interface V0041JobDescMsgRlimitsData {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsData
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsData
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsData
     */
    'number'?: number;
}
/**
 * Largest file that can be created, in bytes.
 * @export
 * @interface V0041JobDescMsgRlimitsFsize
 */
export interface V0041JobDescMsgRlimitsFsize {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsFsize
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsFsize
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsFsize
     */
    'number'?: number;
}
/**
 * Locked-in-memory address space
 * @export
 * @interface V0041JobDescMsgRlimitsMemlock
 */
export interface V0041JobDescMsgRlimitsMemlock {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsMemlock
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsMemlock
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsMemlock
     */
    'number'?: number;
}
/**
 * Number of open files.
 * @export
 * @interface V0041JobDescMsgRlimitsNofile
 */
export interface V0041JobDescMsgRlimitsNofile {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsNofile
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsNofile
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsNofile
     */
    'number'?: number;
}
/**
 * Number of processes.
 * @export
 * @interface V0041JobDescMsgRlimitsNproc
 */
export interface V0041JobDescMsgRlimitsNproc {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsNproc
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsNproc
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsNproc
     */
    'number'?: number;
}
/**
 * Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
 * @export
 * @interface V0041JobDescMsgRlimitsRss
 */
export interface V0041JobDescMsgRlimitsRss {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsRss
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsRss
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsRss
     */
    'number'?: number;
}
/**
 * Maximum size of stack segment, in bytes.
 * @export
 * @interface V0041JobDescMsgRlimitsStack
 */
export interface V0041JobDescMsgRlimitsStack {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsStack
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgRlimitsStack
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgRlimitsStack
     */
    'number'?: number;
}
/**
 * Segment size for topology/block
 * @export
 * @interface V0041JobDescMsgSegmentSize
 */
export interface V0041JobDescMsgSegmentSize {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgSegmentSize
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgSegmentSize
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgSegmentSize
     */
    'number'?: number;
}
/**
 * Maximum run time in minutes
 * @export
 * @interface V0041JobDescMsgTimeLimit
 */
export interface V0041JobDescMsgTimeLimit {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgTimeLimit
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgTimeLimit
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgTimeLimit
     */
    'number'?: number;
}
/**
 * Minimum run time in minutes
 * @export
 * @interface V0041JobDescMsgTimeMinimum
 */
export interface V0041JobDescMsgTimeMinimum {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041JobDescMsgTimeMinimum
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041JobDescMsgTimeMinimum
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041JobDescMsgTimeMinimum
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041JobSubmitReq
 */
export interface V0041JobSubmitReq {
    /**
     * Deprecated; Populate script field in jobs[0] or job
     * @type {string}
     * @memberof V0041JobSubmitReq
     * @deprecated
     */
    'script'?: string;
    /**
     * HetJob description
     * @type {Array<V0041JobDescMsg>}
     * @memberof V0041JobSubmitReq
     */
    'jobs'?: Array<V0041JobDescMsg>;
    /**
     * 
     * @type {V0041JobDescMsg}
     * @memberof V0041JobSubmitReq
     */
    'job'?: V0041JobDescMsg;
}
/**
 * 
 * @export
 * @interface V0041KillJobsMsg
 */
export interface V0041KillJobsMsg {
    /**
     * Filter jobs to a specific account
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'account'?: string;
    /**
     * Filter jobs according to flags
     * @type {Array<string>}
     * @memberof V0041KillJobsMsg
     */
    'flags'?: Array<V0041KillJobsMsgFlagsEnum>;
    /**
     * Filter jobs to a specific name
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'job_name'?: string;
    /**
     * List of jobs to signal
     * @type {Array<string>}
     * @memberof V0041KillJobsMsg
     */
    'jobs'?: Array<string>;
    /**
     * Filter jobs to a specific partition
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'partition'?: string;
    /**
     * Filter jobs to a specific QOS
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'qos'?: string;
    /**
     * Filter jobs to a specific reservation
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'reservation'?: string;
    /**
     * Signal to send to jobs
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'signal'?: string;
    /**
     * Filter jobs to a specific state
     * @type {Array<string>}
     * @memberof V0041KillJobsMsg
     */
    'job_state'?: Array<V0041KillJobsMsgJobStateEnum>;
    /**
     * Filter jobs to a specific numeric user id
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'user_id'?: string;
    /**
     * Filter jobs to a specific user name
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'user_name'?: string;
    /**
     * Filter jobs to a specific wckey
     * @type {string}
     * @memberof V0041KillJobsMsg
     */
    'wckey'?: string;
    /**
     * Filter jobs to a set of nodes
     * @type {Array<string>}
     * @memberof V0041KillJobsMsg
     */
    'nodes'?: Array<string>;
}

export const V0041KillJobsMsgFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;

export type V0041KillJobsMsgFlagsEnum = typeof V0041KillJobsMsgFlagsEnum[keyof typeof V0041KillJobsMsgFlagsEnum];
export const V0041KillJobsMsgJobStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0041KillJobsMsgJobStateEnum = typeof V0041KillJobsMsgJobStateEnum[keyof typeof V0041KillJobsMsgJobStateEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiAccountsAddCondResp
 */
export interface V0041OpenapiAccountsAddCondResp {
    /**
     * 
     * @type {V0041OpenapiAccountsAddCondRespAssociationCondition}
     * @memberof V0041OpenapiAccountsAddCondResp
     */
    'association_condition'?: V0041OpenapiAccountsAddCondRespAssociationCondition;
    /**
     * 
     * @type {V0041OpenapiAccountsAddCondRespAccount}
     * @memberof V0041OpenapiAccountsAddCondResp
     */
    'account'?: V0041OpenapiAccountsAddCondRespAccount;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAccountsAddCondResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAccountsAddCondResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAccountsAddCondResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Account organization and description
 * @export
 * @interface V0041OpenapiAccountsAddCondRespAccount
 */
export interface V0041OpenapiAccountsAddCondRespAccount {
    /**
     * Arbitrary string describing the account
     * @type {string}
     * @memberof V0041OpenapiAccountsAddCondRespAccount
     */
    'description'?: string;
    /**
     * Organization to which the account belongs
     * @type {string}
     * @memberof V0041OpenapiAccountsAddCondRespAccount
     */
    'organization'?: string;
}
/**
 * CSV list of accounts, association limits and options, CSV list of clusters
 * @export
 * @interface V0041OpenapiAccountsAddCondRespAssociationCondition
 */
export interface V0041OpenapiAccountsAddCondRespAssociationCondition {
    /**
     * CSV accounts list
     * @type {Array<string>}
     * @memberof V0041OpenapiAccountsAddCondRespAssociationCondition
     */
    'accounts': Array<string>;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociation}
     * @memberof V0041OpenapiAccountsAddCondRespAssociationCondition
     */
    'association'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociation;
    /**
     * CSV clusters list
     * @type {Array<string>}
     * @memberof V0041OpenapiAccountsAddCondRespAssociationCondition
     */
    'clusters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiAccountsAddCondRespStr
 */
export interface V0041OpenapiAccountsAddCondRespStr {
    /**
     * added_accounts
     * @type {string}
     * @memberof V0041OpenapiAccountsAddCondRespStr
     */
    'added_accounts': string;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAccountsAddCondRespStr
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAccountsAddCondRespStr
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAccountsAddCondRespStr
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiAccountsRemovedResp
 */
export interface V0041OpenapiAccountsRemovedResp {
    /**
     * removed_accounts
     * @type {Array<string>}
     * @memberof V0041OpenapiAccountsRemovedResp
     */
    'removed_accounts': Array<string>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAccountsRemovedResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAccountsRemovedResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAccountsRemovedResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiAccountsResp
 */
export interface V0041OpenapiAccountsResp {
    /**
     * accounts
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInner>}
     * @memberof V0041OpenapiAccountsResp
     */
    'accounts': Array<V0041OpenapiSlurmdbdConfigRespAccountsInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAccountsResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAccountsResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAccountsResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiAssocsRemovedResp
 */
export interface V0041OpenapiAssocsRemovedResp {
    /**
     * removed_associations
     * @type {Array<string>}
     * @memberof V0041OpenapiAssocsRemovedResp
     */
    'removed_associations': Array<string>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAssocsRemovedResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAssocsRemovedResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAssocsRemovedResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiAssocsResp
 */
export interface V0041OpenapiAssocsResp {
    /**
     * associations
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAssociationsInner>}
     * @memberof V0041OpenapiAssocsResp
     */
    'associations': Array<V0041OpenapiSlurmdbdConfigRespAssociationsInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiAssocsResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiAssocsResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiAssocsResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiClustersRemovedResp
 */
export interface V0041OpenapiClustersRemovedResp {
    /**
     * deleted_clusters
     * @type {Array<string>}
     * @memberof V0041OpenapiClustersRemovedResp
     */
    'deleted_clusters': Array<string>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiClustersRemovedResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiClustersRemovedResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiClustersRemovedResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiClustersResp
 */
export interface V0041OpenapiClustersResp {
    /**
     * clusters
     * @type {Array<V0041OpenapiSlurmdbdConfigRespClustersInner>}
     * @memberof V0041OpenapiClustersResp
     */
    'clusters': Array<V0041OpenapiSlurmdbdConfigRespClustersInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiClustersResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiClustersResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiClustersResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiDiagResp
 */
export interface V0041OpenapiDiagResp {
    /**
     * 
     * @type {V0041OpenapiDiagRespStatistics}
     * @memberof V0041OpenapiDiagResp
     */
    'statistics': V0041OpenapiDiagRespStatistics;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiDiagResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiDiagResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiDiagResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * statistics
 * @export
 * @interface V0041OpenapiDiagRespStatistics
 */
export interface V0041OpenapiDiagRespStatistics {
    /**
     * Zero if only RPC statistic included
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'parts_packed'?: number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsReqTime}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'req_time'?: V0041OpenapiDiagRespStatisticsReqTime;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsReqTimeStart}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'req_time_start'?: V0041OpenapiDiagRespStatisticsReqTimeStart;
    /**
     * Number of current active slurmctld threads
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'server_thread_count'?: number;
    /**
     * Number of enqueued outgoing RPC requests in an internal retry list
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'agent_queue_size'?: number;
    /**
     * Number of agent threads
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'agent_count'?: number;
    /**
     * Total number of active threads created by all agent threads
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'agent_thread_count'?: number;
    /**
     * Number of messages for SlurmDBD that are queued
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'dbd_agent_queue_size'?: number;
    /**
     * Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'gettimeofday_latency'?: number;
    /**
     * Max time of any scheduling cycle in microseconds since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_max'?: number;
    /**
     * Time in microseconds for last scheduling cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_last'?: number;
    /**
     * Total run time in microseconds for all scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_sum'?: number;
    /**
     * Number of scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_total'?: number;
    /**
     * Mean time in microseconds for all scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_mean'?: number;
    /**
     * Mean of the number of jobs processed in a scheduling cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_mean_depth'?: number;
    /**
     * Number of scheduling executions per minute
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_per_minute'?: number;
    /**
     * Total number of jobs processed in scheduling cycles
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_cycle_depth'?: number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsScheduleExit}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_exit'?: V0041OpenapiDiagRespStatisticsScheduleExit;
    /**
     * Number of jobs pending in queue
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'schedule_queue_length'?: number;
    /**
     * Number of jobs submitted since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_submitted'?: number;
    /**
     * Number of jobs started since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_started'?: number;
    /**
     * Number of jobs completed since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_completed'?: number;
    /**
     * Number of jobs canceled since the last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_canceled'?: number;
    /**
     * Number of jobs failed due to slurmd or other internal issues since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_failed'?: number;
    /**
     * Number of jobs pending at the time of listed in job_state_ts
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_pending'?: number;
    /**
     * Number of jobs running at the time of listed in job_state_ts
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'jobs_running'?: number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsJobStatesTs}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'job_states_ts'?: V0041OpenapiDiagRespStatisticsJobStatesTs;
    /**
     * Number of jobs started through backfilling since last slurm start
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_backfilled_jobs'?: number;
    /**
     * Number of jobs started through backfilling since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_last_backfilled_jobs'?: number;
    /**
     * Number of heterogeneous job components started through backfilling since last Slurm start
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_backfilled_het_jobs'?: number;
    /**
     * Number of backfill scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_cycle_counter'?: number;
    /**
     * Mean time in microseconds of backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_cycle_mean'?: number;
    /**
     * Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_depth_mean'?: number;
    /**
     * The subset of Depth Mean that the backfill scheduler attempted to schedule
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_depth_mean_try'?: number;
    /**
     * Total time in microseconds of backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_cycle_sum'?: number;
    /**
     * Execution time in microseconds of last backfill scheduling cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_cycle_last'?: number;
    /**
     * Execution time in microseconds of longest backfill scheduling cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_cycle_max'?: number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsBfExit}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_exit'?: V0041OpenapiDiagRespStatisticsBfExit;
    /**
     * Number of processed jobs during last backfilling scheduling cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_last_depth'?: number;
    /**
     * Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_last_depth_try'?: number;
    /**
     * Total number of jobs processed during all backfilling scheduling cycles since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_depth_sum'?: number;
    /**
     * Subset of bf_depth_sum that the backfill scheduler attempted to schedule
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_depth_try_sum'?: number;
    /**
     * Number of jobs pending to be processed by backfilling algorithm
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_queue_len'?: number;
    /**
     * Mean number of jobs pending to be processed by backfilling algorithm
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_queue_len_mean'?: number;
    /**
     * Total number of jobs pending to be processed by backfilling algorithm since last reset
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_queue_len_sum'?: number;
    /**
     * Number of different time slots tested by the backfill scheduler in its last iteration
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_table_size'?: number;
    /**
     * Total number of different time slots tested by the backfill scheduler
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_table_size_sum'?: number;
    /**
     * Mean number of different time slots tested by the backfill scheduler
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_table_size_mean'?: number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsBfWhenLastCycle}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_when_last_cycle'?: V0041OpenapiDiagRespStatisticsBfWhenLastCycle;
    /**
     * Backfill scheduler currently running
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'bf_active'?: boolean;
    /**
     * Most frequently issued remote procedure calls (RPCs)
     * @type {Array<V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner>}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'rpcs_by_message_type'?: Array<V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner>;
    /**
     * RPCs issued by user ID
     * @type {Array<V0041OpenapiDiagRespStatisticsRpcsByUserInner>}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'rpcs_by_user'?: Array<V0041OpenapiDiagRespStatisticsRpcsByUserInner>;
    /**
     * Pending RPC statistics
     * @type {Array<V0041OpenapiDiagRespStatisticsPendingRpcsInner>}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'pending_rpcs'?: Array<V0041OpenapiDiagRespStatisticsPendingRpcsInner>;
    /**
     * Pending RPCs hostlists
     * @type {Array<V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner>}
     * @memberof V0041OpenapiDiagRespStatistics
     */
    'pending_rpcs_by_hostlist'?: Array<V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner>;
}
/**
 * Reasons for which the backfill scheduling cycle exited since last reset
 * @export
 * @interface V0041OpenapiDiagRespStatisticsBfExit
 */
export interface V0041OpenapiDiagRespStatisticsBfExit {
    /**
     * Reached end of queue
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'end_job_queue'?: number;
    /**
     * Reached number of jobs allowed to start
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'bf_max_job_start'?: number;
    /**
     * Reached number of jobs allowed to be tested
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'bf_max_job_test'?: number;
    /**
     * Reached maximum allowed scheduler time
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'bf_max_time'?: number;
    /**
     * Reached table size limit
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'bf_node_space_size'?: number;
    /**
     * System state changed
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfExit
     */
    'state_changed'?: number;
}
/**
 * When the last backfill scheduling cycle happened (UNIX timestamp)
 * @export
 * @interface V0041OpenapiDiagRespStatisticsBfWhenLastCycle
 */
export interface V0041OpenapiDiagRespStatisticsBfWhenLastCycle {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsBfWhenLastCycle
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsBfWhenLastCycle
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsBfWhenLastCycle
     */
    'number'?: number;
}
/**
 * When the job state counts were gathered (UNIX timestamp)
 * @export
 * @interface V0041OpenapiDiagRespStatisticsJobStatesTs
 */
export interface V0041OpenapiDiagRespStatisticsJobStatesTs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsJobStatesTs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsJobStatesTs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsJobStatesTs
     */
    'number'?: number;
}
/**
 * Pending RPCs by hostlist
 * @export
 * @interface V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner
 */
export interface V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner {
    /**
     * Message type as integer
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner
     */
    'type_id': number;
    /**
     * Message type as string
     * @type {string}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner
     */
    'message_type': string;
    /**
     * Number of RPCs received
     * @type {Array<string>}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsByHostlistInner
     */
    'count': Array<string>;
}
/**
 * Pending RPCs
 * @export
 * @interface V0041OpenapiDiagRespStatisticsPendingRpcsInner
 */
export interface V0041OpenapiDiagRespStatisticsPendingRpcsInner {
    /**
     * Message type as integer
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsInner
     */
    'type_id': number;
    /**
     * Message type as string
     * @type {string}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsInner
     */
    'message_type': string;
    /**
     * Number of pending RPCs queued
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsPendingRpcsInner
     */
    'count': number;
}
/**
 * When the request was made (UNIX timestamp)
 * @export
 * @interface V0041OpenapiDiagRespStatisticsReqTime
 */
export interface V0041OpenapiDiagRespStatisticsReqTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsReqTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsReqTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsReqTime
     */
    'number'?: number;
}
/**
 * When the data in the report started (UNIX timestamp)
 * @export
 * @interface V0041OpenapiDiagRespStatisticsReqTimeStart
 */
export interface V0041OpenapiDiagRespStatisticsReqTimeStart {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsReqTimeStart
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsReqTimeStart
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsReqTimeStart
     */
    'number'?: number;
}
/**
 * RPCs by type
 * @export
 * @interface V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
 */
export interface V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner {
    /**
     * Message type as integer
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'type_id': number;
    /**
     * Message type as string
     * @type {string}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'message_type': string;
    /**
     * Number of RPCs received
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'count': number;
    /**
     * Number of RPCs queued
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'queued': number;
    /**
     * Number of RPCs dropped
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'dropped': number;
    /**
     * Number of RPCs processed within the last RPC queue cycle
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'cycle_last': number;
    /**
     * Maximum number of RPCs processed within a RPC queue cycle since start
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'cycle_max': number;
    /**
     * Total time spent processing RPC in seconds
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'total_time': number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInner
     */
    'average_time': V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime;
}
/**
 * Average time spent processing RPC in seconds
 * @export
 * @interface V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime
 */
export interface V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime
     */
    'number'?: number;
}
/**
 * RPCs by user
 * @export
 * @interface V0041OpenapiDiagRespStatisticsRpcsByUserInner
 */
export interface V0041OpenapiDiagRespStatisticsRpcsByUserInner {
    /**
     * User ID (numeric)
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByUserInner
     */
    'user_id': number;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByUserInner
     */
    'user': string;
    /**
     * Number of RPCs received
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByUserInner
     */
    'count': number;
    /**
     * Total time spent processing RPC in seconds
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByUserInner
     */
    'total_time': number;
    /**
     * 
     * @type {V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime}
     * @memberof V0041OpenapiDiagRespStatisticsRpcsByUserInner
     */
    'average_time': V0041OpenapiDiagRespStatisticsRpcsByMessageTypeInnerAverageTime;
}
/**
 * Reasons for which the scheduling cycle exited since last reset
 * @export
 * @interface V0041OpenapiDiagRespStatisticsScheduleExit
 */
export interface V0041OpenapiDiagRespStatisticsScheduleExit {
    /**
     * Reached end of queue
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'end_job_queue'?: number;
    /**
     * Reached number of jobs allowed to be tested
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'default_queue_depth'?: number;
    /**
     * Reached number of jobs allowed to start
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'max_job_start'?: number;
    /**
     * Reached RPC limit
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'max_rpc_cnt'?: number;
    /**
     * Reached maximum allowed scheduler time
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'max_sched_time'?: number;
    /**
     * Blocked on licenses
     * @type {number}
     * @memberof V0041OpenapiDiagRespStatisticsScheduleExit
     */
    'licenses'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiInstancesResp
 */
export interface V0041OpenapiInstancesResp {
    /**
     * instances
     * @type {Array<V0041OpenapiSlurmdbdConfigRespInstancesInner>}
     * @memberof V0041OpenapiInstancesResp
     */
    'instances': Array<V0041OpenapiSlurmdbdConfigRespInstancesInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiInstancesResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiInstancesResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiInstancesResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobAllocResp
 */
export interface V0041OpenapiJobAllocResp {
    /**
     * Submitted Job ID
     * @type {number}
     * @memberof V0041OpenapiJobAllocResp
     */
    'job_id'?: number;
    /**
     * Job submission user message
     * @type {string}
     * @memberof V0041OpenapiJobAllocResp
     */
    'job_submit_user_msg'?: string;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiJobAllocResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiJobAllocResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiJobAllocResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoResp
 */
export interface V0041OpenapiJobInfoResp {
    /**
     * List of jobs
     * @type {Array<V0041OpenapiJobInfoRespJobsInner>}
     * @memberof V0041OpenapiJobInfoResp
     */
    'jobs': Array<V0041OpenapiJobInfoRespJobsInner>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespLastBackfill}
     * @memberof V0041OpenapiJobInfoResp
     */
    'last_backfill': V0041OpenapiJobInfoRespLastBackfill;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespLastUpdate}
     * @memberof V0041OpenapiJobInfoResp
     */
    'last_update': V0041OpenapiJobInfoRespLastUpdate;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiJobInfoResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiJobInfoResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiJobInfoResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInner
 */
export interface V0041OpenapiJobInfoRespJobsInner {
    /**
     * Account associated with the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'account'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerAccrueTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'accrue_time'?: V0041OpenapiJobInfoRespJobsInnerAccrueTime;
    /**
     * Arbitrary comment made by administrator
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'admin_comment'?: string;
    /**
     * Local node making the resource allocation
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'allocating_node'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerArrayJobId}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'array_job_id'?: V0041OpenapiJobInfoRespJobsInnerArrayJobId;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerArrayTaskId}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'array_task_id'?: V0041OpenapiJobInfoRespJobsInnerArrayTaskId;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'array_max_tasks'?: V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks;
    /**
     * String expression of task IDs in this record
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'array_task_string'?: string;
    /**
     * Unique identifier for the association
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'association_id'?: number;
    /**
     * Features required for batch script\'s node
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'batch_features'?: string;
    /**
     * True if batch job
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'batch_flag'?: boolean;
    /**
     * Name of host running batch script
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'batch_host'?: string;
    /**
     * Job flags
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'flags'?: Array<V0041OpenapiJobInfoRespJobsInnerFlagsEnum>;
    /**
     * Burst buffer specifications
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'burst_buffer'?: string;
    /**
     * Burst buffer state details
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'burst_buffer_state'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cluster'?: string;
    /**
     * List of required cluster features
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cluster_features'?: string;
    /**
     * Executed command
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'command'?: string;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'comment'?: string;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'container'?: string;
    /**
     * OCI container ID
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'container_id'?: string;
    /**
     * True if job requires contiguous nodes
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'contiguous'?: boolean;
    /**
     * Specialized core count
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'core_spec'?: number;
    /**
     * Specialized thread count
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'thread_spec'?: number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCoresPerSocket}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cores_per_socket'?: V0041OpenapiJobInfoRespJobsInnerCoresPerSocket;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerBillableTres}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'billable_tres'?: V0041OpenapiJobInfoRespJobsInnerBillableTres;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCpusPerTask}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpus_per_task'?: V0041OpenapiJobInfoRespJobsInnerCpusPerTask;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpu_frequency_minimum'?: V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpu_frequency_maximum'?: V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpu_frequency_governor'?: V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor;
    /**
     * Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpus_per_tres'?: string;
    /**
     * Time specification for scrontab job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cron'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDeadline}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'deadline'?: V0041OpenapiJobInfoRespJobsInnerDeadline;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDelayBoot}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'delay_boot'?: V0041OpenapiJobInfoRespJobsInnerDelayBoot;
    /**
     * Other jobs that must meet certain criteria before this job can start
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'dependency'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'derived_exit_code'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerEligibleTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'eligible_time'?: V0041OpenapiJobInfoRespJobsInnerEligibleTime;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerEndTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'end_time'?: V0041OpenapiJobInfoRespJobsInnerEndTime;
    /**
     * Comma separated list of nodes that may not be used
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'excluded_nodes'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerExitCode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'exit_code'?: V0041OpenapiJobInfoRespJobsInnerExitCode;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'extra'?: string;
    /**
     * Name of node that caused job failure
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'failed_node'?: string;
    /**
     * Comma separated list of features that are required
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'features'?: string;
    /**
     * Origin cluster\'s name (when using federation)
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'federation_origin'?: string;
    /**
     * Active sibling job names
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'federation_siblings_active'?: string;
    /**
     * Viable sibling job names
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'federation_siblings_viable'?: string;
    /**
     * List of GRES index and counts allocated per node
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'gres_detail'?: Array<string>;
    /**
     * Group ID of the user that owns the job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'group_id'?: number;
    /**
     * Group name of the user that owns the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'group_name'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerHetJobId}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'het_job_id'?: V0041OpenapiJobInfoRespJobsInnerHetJobId;
    /**
     * Job ID range for all heterogeneous job components
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'het_job_id_set'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerHetJobOffset}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'het_job_offset'?: V0041OpenapiJobInfoRespJobsInnerHetJobOffset;
    /**
     * Job ID
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerJobResources}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'job_resources'?: V0041OpenapiJobInfoRespJobsInnerJobResources;
    /**
     * Number of nodes (in a range) required for this job
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'job_size_str'?: Array<string>;
    /**
     * Current state
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'job_state'?: Array<V0041OpenapiJobInfoRespJobsInnerJobStateEnum>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'last_sched_evaluation'?: V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'licenses'?: string;
    /**
     * Mail event type(s)
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'mail_type'?: Array<V0041OpenapiJobInfoRespJobsInnerMailTypeEnum>;
    /**
     * User to receive email notifications
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'mail_user'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMaxCpus}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'max_cpus'?: V0041OpenapiJobInfoRespJobsInnerMaxCpus;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMaxNodes}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'max_nodes'?: V0041OpenapiJobInfoRespJobsInnerMaxNodes;
    /**
     * Multi-Category Security label on the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'mcs_label'?: string;
    /**
     * Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'memory_per_tres'?: string;
    /**
     * Job name
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'name'?: string;
    /**
     * Network specs for the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'network'?: string;
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'nodes'?: string;
    /**
     * Requested job priority change
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'nice'?: number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasksPerCore}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks_per_core'?: V0041OpenapiJobInfoRespJobsInnerTasksPerCore;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasksPerTres}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks_per_tres'?: V0041OpenapiJobInfoRespJobsInnerTasksPerTres;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasksPerNode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks_per_node'?: V0041OpenapiJobInfoRespJobsInnerTasksPerNode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasksPerSocket}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks_per_socket'?: V0041OpenapiJobInfoRespJobsInnerTasksPerSocket;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasksPerBoard}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks_per_board'?: V0041OpenapiJobInfoRespJobsInnerTasksPerBoard;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerCpus}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'cpus'?: V0041OpenapiJobInfoRespJobsInnerCpus;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerNodeCount}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'node_count'?: V0041OpenapiJobInfoRespJobsInnerNodeCount;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerTasks}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tasks'?: V0041OpenapiJobInfoRespJobsInnerTasks;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'partition'?: string;
    /**
     * Feature(s) the job requested but that are not required
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'prefer'?: string;
    /**
     * 
     * @type {V0041JobDescMsgMemoryPerCpu}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'memory_per_cpu'?: V0041JobDescMsgMemoryPerCpu;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMemoryPerNode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'memory_per_node'?: V0041OpenapiJobInfoRespJobsInnerMemoryPerNode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'minimum_cpus_per_node'?: V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'minimum_tmp_disk_per_node'?: V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerPower}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'power'?: V0041OpenapiJobInfoRespJobsInnerPower;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerPreemptTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'preempt_time'?: V0041OpenapiJobInfoRespJobsInnerPreemptTime;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerPreemptableTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'preemptable_time'?: V0041OpenapiJobInfoRespJobsInnerPreemptableTime;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerPreSusTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'pre_sus_time'?: V0041OpenapiJobInfoRespJobsInnerPreSusTime;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0041JobDescMsgPriority}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'priority'?: V0041JobDescMsgPriority;
    /**
     * Profile used by the acct_gather_profile plugin
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'profile'?: Array<V0041OpenapiJobInfoRespJobsInnerProfileEnum>;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'qos'?: string;
    /**
     * Node reboot requested before start
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'reboot'?: boolean;
    /**
     * Comma separated list of required nodes
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'required_nodes'?: string;
    /**
     * Maximum number of switches (the \'minimum\' in the key is incorrect)
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'minimum_switches'?: number;
    /**
     * Determines whether the job may be requeued
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'requeue'?: boolean;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerResizeTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'resize_time'?: V0041OpenapiJobInfoRespJobsInnerResizeTime;
    /**
     * Number of job restarts
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'restart_cnt'?: number;
    /**
     * Name of reservation to use
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'resv_name'?: string;
    /**
     * List of nodes scheduled to be used for the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'scheduled_nodes'?: string;
    /**
     * SELinux context
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'selinux_context'?: string;
    /**
     * How the job can share resources with other jobs, if at all
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'shared'?: Array<V0041OpenapiJobInfoRespJobsInnerSharedEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     * @deprecated
     */
    'exclusive'?: Array<V0041OpenapiJobInfoRespJobsInnerExclusiveEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     * @deprecated
     */
    'oversubscribe'?: boolean;
    /**
     * Job details shown in this response
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'show_flags'?: Array<V0041OpenapiJobInfoRespJobsInnerShowFlagsEnum>;
    /**
     * Number of sockets per board required
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'sockets_per_board'?: number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerSocketsPerNode}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'sockets_per_node'?: V0041OpenapiJobInfoRespJobsInnerSocketsPerNode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerStartTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'start_time'?: V0041OpenapiJobInfoRespJobsInnerStartTime;
    /**
     * Optional details for state_reason
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'state_description'?: string;
    /**
     * Reason for current Pending or Failed state
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'state_reason'?: string;
    /**
     * Path to stderr file
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'standard_error'?: string;
    /**
     * Path to stdin file
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'standard_input'?: string;
    /**
     * Path to stdout file
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'standard_output'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerSubmitTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'submit_time'?: V0041OpenapiJobInfoRespJobsInnerSubmitTime;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerSuspendTime}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'suspend_time'?: V0041OpenapiJobInfoRespJobsInnerSuspendTime;
    /**
     * Arbitrary comment from slurmctld
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'system_comment'?: string;
    /**
     * 
     * @type {V0041JobDescMsgTimeLimit}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'time_limit'?: V0041JobDescMsgTimeLimit;
    /**
     * 
     * @type {V0041JobDescMsgTimeMinimum}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'time_minimum'?: V0041JobDescMsgTimeMinimum;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerThreadsPerCore}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'threads_per_core'?: V0041OpenapiJobInfoRespJobsInnerThreadsPerCore;
    /**
     * Task to TRES binding directives
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_bind'?: string;
    /**
     * TRES frequency directives
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_freq'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_per_job'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per node
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_per_node'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per socket
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_per_socket'?: string;
    /**
     * Comma separated list of TRES=# values to be allocated per task
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_per_task'?: string;
    /**
     * TRES requested by the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_req_str'?: string;
    /**
     * TRES used by the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'tres_alloc_str'?: string;
    /**
     * User ID that owns the job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'user_id'?: number;
    /**
     * User name that owns the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'user_name'?: string;
    /**
     * Maximum time to wait for switches in seconds
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'maximum_switch_wait_time'?: number;
    /**
     * Workload characterization key
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'wckey'?: string;
    /**
     * Working directory to use for the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInner
     */
    'current_working_directory'?: string;
}

export const V0041OpenapiJobInfoRespJobsInnerFlagsEnum = {
    KillInvalidDependency: 'KILL_INVALID_DEPENDENCY',
    NoKillInvalidDependency: 'NO_KILL_INVALID_DEPENDENCY',
    HasStateDirectory: 'HAS_STATE_DIRECTORY',
    TestingBackfill: 'TESTING_BACKFILL',
    GresBindingEnforced: 'GRES_BINDING_ENFORCED',
    TestNowOnly: 'TEST_NOW_ONLY',
    SendJobEnvironment: 'SEND_JOB_ENVIRONMENT',
    SpreadJob: 'SPREAD_JOB',
    PreferMinimumNodeCount: 'PREFER_MINIMUM_NODE_COUNT',
    JobKillHurry: 'JOB_KILL_HURRY',
    SkipTresStringAccounting: 'SKIP_TRES_STRING_ACCOUNTING',
    SiblingClusterUpdateOnly: 'SIBLING_CLUSTER_UPDATE_ONLY',
    HeterogeneousJob: 'HETEROGENEOUS_JOB',
    ExactTaskCountRequested: 'EXACT_TASK_COUNT_REQUESTED',
    ExactCpuCountRequested: 'EXACT_CPU_COUNT_REQUESTED',
    TestingWholeNodeBackfill: 'TESTING_WHOLE_NODE_BACKFILL',
    TopPriorityJob: 'TOP_PRIORITY_JOB',
    AccrueCountCleared: 'ACCRUE_COUNT_CLEARED',
    GresBindingDisabled: 'GRES_BINDING_DISABLED',
    JobWasRunning: 'JOB_WAS_RUNNING',
    JobAccrueTimeReset: 'JOB_ACCRUE_TIME_RESET',
    CronJob: 'CRON_JOB',
    ExactMemoryRequested: 'EXACT_MEMORY_REQUESTED',
    UsingDefaultAccount: 'USING_DEFAULT_ACCOUNT',
    UsingDefaultPartition: 'USING_DEFAULT_PARTITION',
    UsingDefaultQos: 'USING_DEFAULT_QOS',
    UsingDefaultWckey: 'USING_DEFAULT_WCKEY',
    Dependent: 'DEPENDENT',
    Magnetic: 'MAGNETIC',
    PartitionAssigned: 'PARTITION_ASSIGNED',
    BackfillAttempted: 'BACKFILL_ATTEMPTED',
    SchedulingAttempted: 'SCHEDULING_ATTEMPTED',
    StepmgrEnabled: 'STEPMGR_ENABLED'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerFlagsEnum = typeof V0041OpenapiJobInfoRespJobsInnerFlagsEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerFlagsEnum];
export const V0041OpenapiJobInfoRespJobsInnerJobStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerJobStateEnum = typeof V0041OpenapiJobInfoRespJobsInnerJobStateEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerJobStateEnum];
export const V0041OpenapiJobInfoRespJobsInnerMailTypeEnum = {
    Begin: 'BEGIN',
    End: 'END',
    Fail: 'FAIL',
    Requeue: 'REQUEUE',
    Time100: 'TIME=100%',
    Time90: 'TIME=90%',
    Time80: 'TIME=80%',
    Time50: 'TIME=50%',
    StageOut: 'STAGE_OUT',
    ArrayTasks: 'ARRAY_TASKS',
    InvalidDependency: 'INVALID_DEPENDENCY'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerMailTypeEnum = typeof V0041OpenapiJobInfoRespJobsInnerMailTypeEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerMailTypeEnum];
export const V0041OpenapiJobInfoRespJobsInnerProfileEnum = {
    NotSet: 'NOT_SET',
    None: 'NONE',
    Energy: 'ENERGY',
    Lustre: 'LUSTRE',
    Network: 'NETWORK',
    Task: 'TASK'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerProfileEnum = typeof V0041OpenapiJobInfoRespJobsInnerProfileEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerProfileEnum];
export const V0041OpenapiJobInfoRespJobsInnerSharedEnum = {
    None: 'none',
    Oversubscribe: 'oversubscribe',
    User: 'user',
    Mcs: 'mcs',
    Topo: 'topo'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerSharedEnum = typeof V0041OpenapiJobInfoRespJobsInnerSharedEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerSharedEnum];
export const V0041OpenapiJobInfoRespJobsInnerExclusiveEnum = {
    True: 'true',
    False: 'false',
    User: 'user',
    Mcs: 'mcs',
    Topo: 'topo'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerExclusiveEnum = typeof V0041OpenapiJobInfoRespJobsInnerExclusiveEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerExclusiveEnum];
export const V0041OpenapiJobInfoRespJobsInnerShowFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerShowFlagsEnum = typeof V0041OpenapiJobInfoRespJobsInnerShowFlagsEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerShowFlagsEnum];

/**
 * When the job started accruing age priority (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerAccrueTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerAccrueTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerAccrueTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerAccrueTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerAccrueTime
     */
    'number'?: number;
}
/**
 * Job ID of job array, or 0 if N/A
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerArrayJobId
 */
export interface V0041OpenapiJobInfoRespJobsInnerArrayJobId {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayJobId
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayJobId
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayJobId
     */
    'number'?: number;
}
/**
 * Maximum number of simultaneously running array tasks, 0 if no limit
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks
 */
export interface V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayMaxTasks
     */
    'number'?: number;
}
/**
 * Task ID of this task in job array
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerArrayTaskId
 */
export interface V0041OpenapiJobInfoRespJobsInnerArrayTaskId {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayTaskId
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayTaskId
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerArrayTaskId
     */
    'number'?: number;
}
/**
 * Billable TRES
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerBillableTres
 */
export interface V0041OpenapiJobInfoRespJobsInnerBillableTres {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerBillableTres
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerBillableTres
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerBillableTres
     */
    'number'?: number;
}
/**
 * Cores per socket required
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCoresPerSocket
 */
export interface V0041OpenapiJobInfoRespJobsInnerCoresPerSocket {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCoresPerSocket
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCoresPerSocket
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCoresPerSocket
     */
    'number'?: number;
}
/**
 * CPU frequency governor
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor
 */
export interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyGovernor
     */
    'number'?: number;
}
/**
 * Maximum CPU frequency
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum
 */
export interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMaximum
     */
    'number'?: number;
}
/**
 * Minimum CPU frequency
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum
 */
export interface V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpuFrequencyMinimum
     */
    'number'?: number;
}
/**
 * Minimum number of CPUs required
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCpus
 */
export interface V0041OpenapiJobInfoRespJobsInnerCpus {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpus
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpus
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpus
     */
    'number'?: number;
}
/**
 * Number of CPUs required by each task
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerCpusPerTask
 */
export interface V0041OpenapiJobInfoRespJobsInnerCpusPerTask {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpusPerTask
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpusPerTask
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerCpusPerTask
     */
    'number'?: number;
}
/**
 * Latest time that the job may start (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDeadline
 */
export interface V0041OpenapiJobInfoRespJobsInnerDeadline {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDeadline
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDeadline
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDeadline
     */
    'number'?: number;
}
/**
 * Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDelayBoot
 */
export interface V0041OpenapiJobInfoRespJobsInnerDelayBoot {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDelayBoot
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDelayBoot
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDelayBoot
     */
    'number'?: number;
}
/**
 * Highest exit code of all job steps
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCode
 */
export interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCode {
    /**
     * Status given by return code
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCode
     */
    'status'?: Array<V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeStatusEnum>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCode
     */
    'return_code'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCode
     */
    'signal'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal;
}

export const V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeStatusEnum = {
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR',
    Signaled: 'SIGNALED',
    CoreDumped: 'CORE_DUMPED'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeStatusEnum = typeof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeStatusEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeStatusEnum];

/**
 * Process return code (numeric)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode
 */
export interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal
 */
export interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal {
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal
     */
    'id'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId;
    /**
     * Signal sent to process
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal
     */
    'name'?: string;
}
/**
 * Signal sent to process (numeric)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId
 */
export interface V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignalId
     */
    'number'?: number;
}
/**
 * Time when the job became eligible to run (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerEligibleTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerEligibleTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEligibleTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEligibleTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEligibleTime
     */
    'number'?: number;
}
/**
 * End time, real or expected (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerEndTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerEndTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEndTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEndTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerEndTime
     */
    'number'?: number;
}
/**
 * Exit code of the job
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerExitCode
 */
export interface V0041OpenapiJobInfoRespJobsInnerExitCode {
    /**
     * Status given by return code
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerExitCode
     */
    'status'?: Array<V0041OpenapiJobInfoRespJobsInnerExitCodeStatusEnum>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode}
     * @memberof V0041OpenapiJobInfoRespJobsInnerExitCode
     */
    'return_code'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal}
     * @memberof V0041OpenapiJobInfoRespJobsInnerExitCode
     */
    'signal'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal;
}

export const V0041OpenapiJobInfoRespJobsInnerExitCodeStatusEnum = {
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR',
    Signaled: 'SIGNALED',
    CoreDumped: 'CORE_DUMPED'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerExitCodeStatusEnum = typeof V0041OpenapiJobInfoRespJobsInnerExitCodeStatusEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerExitCodeStatusEnum];

/**
 * Heterogeneous job ID, if applicable
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerHetJobId
 */
export interface V0041OpenapiJobInfoRespJobsInnerHetJobId {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobId
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobId
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobId
     */
    'number'?: number;
}
/**
 * Unique sequence number applied to this component of the heterogeneous job
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerHetJobOffset
 */
export interface V0041OpenapiJobInfoRespJobsInnerHetJobOffset {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobOffset
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobOffset
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerHetJobOffset
     */
    'number'?: number;
}
/**
 * Resources used by the job
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResources
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResources {
    /**
     * Scheduler consumable resource selection type
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResources
     */
    'select_type': Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesSelectTypeEnum>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResources
     */
    'nodes'?: V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes;
    /**
     * Number of allocated CPUs
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResources
     */
    'cpus': number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResources
     */
    'threads_per_core': V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore;
}

export const V0041OpenapiJobInfoRespJobsInnerJobResourcesSelectTypeEnum = {
    Cpu: 'CPU',
    Socket: 'SOCKET',
    Core: 'CORE',
    Board: 'BOARD',
    Memory: 'MEMORY',
    OneTaskPerCore: 'ONE_TASK_PER_CORE',
    PackNodes: 'PACK_NODES',
    CoreDefaultDistBlock: 'CORE_DEFAULT_DIST_BLOCK',
    Lln: 'LLN',
    Linear: 'LINEAR'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerJobResourcesSelectTypeEnum = typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesSelectTypeEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesSelectTypeEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes {
    /**
     * Number of allocated nodes
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
     */
    'count'?: number;
    /**
     * Node scheduling selection method
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
     */
    'select_type'?: Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesSelectTypeEnum>;
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
     */
    'list'?: string;
    /**
     * Whether whole nodes were allocated
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
     */
    'whole'?: boolean;
    /**
     * Allocated node resources
     * @type {Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodes
     */
    'allocation'?: Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner>;
}

export const V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesSelectTypeEnum = {
    Available: 'AVAILABLE',
    OneRow: 'ONE_ROW',
    Reserved: 'RESERVED'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesSelectTypeEnum = typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesSelectTypeEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesSelectTypeEnum];

/**
 * Job resources for a node
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner {
    /**
     * Node index
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
     */
    'index': number;
    /**
     * Node name
     * @type {string}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
     */
    'name': string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
     */
    'cpus'?: V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
     */
    'memory'?: V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory;
    /**
     * Socket allocations in node
     * @type {Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInner
     */
    'sockets': Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus {
    /**
     * Total number of CPUs assigned to job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus
     */
    'count'?: number;
    /**
     * Total number of CPUs used by job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerCpus
     */
    'used'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory {
    /**
     * Total memory (MiB) used by job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory
     */
    'used'?: number;
    /**
     * Total memory (MiB) allocated to job
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerMemory
     */
    'allocated'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner {
    /**
     * Core index
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner
     */
    'index': number;
    /**
     * Core in socket
     * @type {Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInner
     */
    'cores': Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner {
    /**
     * Core index
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner
     */
    'index': number;
    /**
     * Core status
     * @type {Array<string>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInner
     */
    'status': Array<V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInnerStatusEnum>;
}

export const V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInnerStatusEnum = {
    Invalid: 'INVALID',
    Unallocated: 'UNALLOCATED',
    Allocated: 'ALLOCATED',
    InUse: 'IN_USE'
} as const;

export type V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInnerStatusEnum = typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInnerStatusEnum[keyof typeof V0041OpenapiJobInfoRespJobsInnerJobResourcesNodesAllocationInnerSocketsInnerCoresInnerStatusEnum];

/**
 * Number of processor threads per CPU core
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore
 */
export interface V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerJobResourcesThreadsPerCore
     */
    'number'?: number;
}
/**
 * Last time job was evaluated for scheduling (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation
 */
export interface V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerLastSchedEvaluation
     */
    'number'?: number;
}
/**
 * Maximum number of CPUs usable by the job
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerMaxCpus
 */
export interface V0041OpenapiJobInfoRespJobsInnerMaxCpus {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxCpus
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxCpus
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxCpus
     */
    'number'?: number;
}
/**
 * Maximum number of nodes usable by the job
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerMaxNodes
 */
export interface V0041OpenapiJobInfoRespJobsInnerMaxNodes {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxNodes
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxNodes
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMaxNodes
     */
    'number'?: number;
}
/**
 * Minimum memory in megabytes per allocated node
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerMemoryPerNode
 */
export interface V0041OpenapiJobInfoRespJobsInnerMemoryPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMemoryPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMemoryPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMemoryPerNode
     */
    'number'?: number;
}
/**
 * Minimum number of CPUs per node
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode
 */
export interface V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumCpusPerNode
     */
    'number'?: number;
}
/**
 * Minimum tmp disk space required per node
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode
 */
export interface V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerMinimumTmpDiskPerNode
     */
    'number'?: number;
}
/**
 * Minimum number of nodes required
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerNodeCount
 */
export interface V0041OpenapiJobInfoRespJobsInnerNodeCount {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerNodeCount
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerNodeCount
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerNodeCount
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerPower
 */
export interface V0041OpenapiJobInfoRespJobsInnerPower {
    /**
     * 
     * @type {Array<any>}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPower
     * @deprecated
     */
    'flags'?: Array<any>;
}
/**
 * Total run time prior to last suspend in seconds
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerPreSusTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerPreSusTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreSusTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreSusTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreSusTime
     */
    'number'?: number;
}
/**
 * Time job received preemption signal (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerPreemptTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerPreemptTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptTime
     */
    'number'?: number;
}
/**
 * Time job becomes eligible for preemption (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerPreemptableTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerPreemptableTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptableTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptableTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerPreemptableTime
     */
    'number'?: number;
}
/**
 * Time of last size change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerResizeTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerResizeTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerResizeTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerResizeTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerResizeTime
     */
    'number'?: number;
}
/**
 * Number of sockets per node required
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerSocketsPerNode
 */
export interface V0041OpenapiJobInfoRespJobsInnerSocketsPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSocketsPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSocketsPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSocketsPerNode
     */
    'number'?: number;
}
/**
 * Time execution began, or is expected to begin (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerStartTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerStartTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerStartTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerStartTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerStartTime
     */
    'number'?: number;
}
/**
 * Time when the job was submitted (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerSubmitTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerSubmitTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSubmitTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSubmitTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSubmitTime
     */
    'number'?: number;
}
/**
 * Time the job was last suspended or resumed (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerSuspendTime
 */
export interface V0041OpenapiJobInfoRespJobsInnerSuspendTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSuspendTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSuspendTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerSuspendTime
     */
    'number'?: number;
}
/**
 * Number of tasks
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasks
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasks {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasks
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasks
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasks
     */
    'number'?: number;
}
/**
 * Number of tasks invoked on each board
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasksPerBoard
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasksPerBoard {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerBoard
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerBoard
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerBoard
     */
    'number'?: number;
}
/**
 * Number of tasks invoked on each core
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasksPerCore
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasksPerCore {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerCore
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerCore
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerCore
     */
    'number'?: number;
}
/**
 * Number of tasks invoked on each node
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasksPerNode
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasksPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerNode
     */
    'number'?: number;
}
/**
 * Number of tasks invoked on each socket
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasksPerSocket
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasksPerSocket {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerSocket
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerSocket
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerSocket
     */
    'number'?: number;
}
/**
 * Number of tasks that can assess each GPU
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerTasksPerTres
 */
export interface V0041OpenapiJobInfoRespJobsInnerTasksPerTres {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerTres
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerTres
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerTasksPerTres
     */
    'number'?: number;
}
/**
 * Number of processor threads per CPU core required
 * @export
 * @interface V0041OpenapiJobInfoRespJobsInnerThreadsPerCore
 */
export interface V0041OpenapiJobInfoRespJobsInnerThreadsPerCore {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerThreadsPerCore
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespJobsInnerThreadsPerCore
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespJobsInnerThreadsPerCore
     */
    'number'?: number;
}
/**
 * Time of last backfill scheduler run (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespLastBackfill
 */
export interface V0041OpenapiJobInfoRespLastBackfill {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespLastBackfill
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespLastBackfill
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespLastBackfill
     */
    'number'?: number;
}
/**
 * Time of last job change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiJobInfoRespLastUpdate
 */
export interface V0041OpenapiJobInfoRespLastUpdate {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespLastUpdate
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiJobInfoRespLastUpdate
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiJobInfoRespLastUpdate
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobPostResponse
 */
export interface V0041OpenapiJobPostResponse {
    /**
     * Job update results
     * @type {Array<V0041OpenapiJobPostResponseResultsInner>}
     * @memberof V0041OpenapiJobPostResponse
     */
    'results'?: Array<V0041OpenapiJobPostResponseResultsInner>;
    /**
     * First updated Job ID - Use results instead
     * @type {string}
     * @memberof V0041OpenapiJobPostResponse
     * @deprecated
     */
    'job_id'?: string;
    /**
     * First updated Step ID - Use results instead
     * @type {string}
     * @memberof V0041OpenapiJobPostResponse
     * @deprecated
     */
    'step_id'?: string;
    /**
     * First updated Job submission user message - Use results instead
     * @type {string}
     * @memberof V0041OpenapiJobPostResponse
     * @deprecated
     */
    'job_submit_user_msg'?: string;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiJobPostResponse
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiJobPostResponse
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiJobPostResponse
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobPostResponseResultsInner
 */
export interface V0041OpenapiJobPostResponseResultsInner {
    /**
     * Job ID for updated job
     * @type {number}
     * @memberof V0041OpenapiJobPostResponseResultsInner
     */
    'job_id'?: number;
    /**
     * Step ID for updated job
     * @type {string}
     * @memberof V0041OpenapiJobPostResponseResultsInner
     */
    'step_id'?: string;
    /**
     * Verbose update status or error
     * @type {string}
     * @memberof V0041OpenapiJobPostResponseResultsInner
     */
    'error'?: string;
    /**
     * Verbose update status or error
     * @type {number}
     * @memberof V0041OpenapiJobPostResponseResultsInner
     */
    'error_code'?: number;
    /**
     * Update response message
     * @type {string}
     * @memberof V0041OpenapiJobPostResponseResultsInner
     */
    'why'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiJobSubmitResponse
 */
export interface V0041OpenapiJobSubmitResponse {
    /**
     * 
     * @type {V0041OpenapiJobSubmitResponseResult}
     * @memberof V0041OpenapiJobSubmitResponse
     * @deprecated
     */
    'result'?: V0041OpenapiJobSubmitResponseResult;
    /**
     * Submitted Job ID
     * @type {number}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'job_id'?: number;
    /**
     * Submitted Step ID
     * @type {string}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'step_id'?: string;
    /**
     * Job submission user message
     * @type {string}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'job_submit_user_msg'?: string;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiJobSubmitResponse
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Job submission
 * @export
 * @interface V0041OpenapiJobSubmitResponseResult
 */
export interface V0041OpenapiJobSubmitResponseResult {
    /**
     * New job ID
     * @type {number}
     * @memberof V0041OpenapiJobSubmitResponseResult
     */
    'job_id'?: number;
    /**
     * New job step ID
     * @type {string}
     * @memberof V0041OpenapiJobSubmitResponseResult
     */
    'step_id'?: string;
    /**
     * Error code
     * @type {number}
     * @memberof V0041OpenapiJobSubmitResponseResult
     */
    'error_code'?: number;
    /**
     * Error message
     * @type {string}
     * @memberof V0041OpenapiJobSubmitResponseResult
     */
    'error'?: string;
    /**
     * Message to user from job_submit plugin
     * @type {string}
     * @memberof V0041OpenapiJobSubmitResponseResult
     */
    'job_submit_user_msg'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiKillJobsResp
 */
export interface V0041OpenapiKillJobsResp {
    /**
     * resultant status of signal request
     * @type {Array<V0041OpenapiKillJobsRespStatusInner>}
     * @memberof V0041OpenapiKillJobsResp
     */
    'status': Array<V0041OpenapiKillJobsRespStatusInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiKillJobsResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiKillJobsResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiKillJobsResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * List of jobs signal responses
 * @export
 * @interface V0041OpenapiKillJobsRespStatusInner
 */
export interface V0041OpenapiKillJobsRespStatusInner {
    /**
     * 
     * @type {V0040KillJobsRespJobError}
     * @memberof V0041OpenapiKillJobsRespStatusInner
     */
    'error'?: V0040KillJobsRespJobError;
    /**
     * Job or Step ID that signaling failed
     * @type {string}
     * @memberof V0041OpenapiKillJobsRespStatusInner
     */
    'step_id': string;
    /**
     * 
     * @type {V0041OpenapiKillJobsRespStatusInnerJobId}
     * @memberof V0041OpenapiKillJobsRespStatusInner
     */
    'job_id': V0041OpenapiKillJobsRespStatusInnerJobId;
    /**
     * 
     * @type {V0040KillJobsRespJobFederation}
     * @memberof V0041OpenapiKillJobsRespStatusInner
     */
    'federation'?: V0040KillJobsRespJobFederation;
}
/**
 * Job ID that signaling failed
 * @export
 * @interface V0041OpenapiKillJobsRespStatusInnerJobId
 */
export interface V0041OpenapiKillJobsRespStatusInnerJobId {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiKillJobsRespStatusInnerJobId
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiKillJobsRespStatusInnerJobId
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiKillJobsRespStatusInnerJobId
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiLicensesResp
 */
export interface V0041OpenapiLicensesResp {
    /**
     * List of licenses
     * @type {Array<V0041OpenapiLicensesRespLicensesInner>}
     * @memberof V0041OpenapiLicensesResp
     */
    'licenses': Array<V0041OpenapiLicensesRespLicensesInner>;
    /**
     * 
     * @type {V0041OpenapiLicensesRespLastUpdate}
     * @memberof V0041OpenapiLicensesResp
     */
    'last_update': V0041OpenapiLicensesRespLastUpdate;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiLicensesResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiLicensesResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiLicensesResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Time of last licenses change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiLicensesRespLastUpdate
 */
export interface V0041OpenapiLicensesRespLastUpdate {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiLicensesRespLastUpdate
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiLicensesRespLastUpdate
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLastUpdate
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiLicensesRespLicensesInner
 */
export interface V0041OpenapiLicensesRespLicensesInner {
    /**
     * Name of the license
     * @type {string}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'LicenseName'?: string;
    /**
     * Total number of licenses present
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'Total'?: number;
    /**
     * Number of licenses in use
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'Used'?: number;
    /**
     * Number of licenses currently available
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'Free'?: number;
    /**
     * Indicates whether licenses are served by the database
     * @type {boolean}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'Remote'?: boolean;
    /**
     * Number of licenses reserved
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'Reserved'?: number;
    /**
     * Last known number of licenses that were consumed in the license manager (Remote Only)
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'LastConsumed'?: number;
    /**
     * Number of \"missing licenses\" from the cluster\'s perspective
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'LastDeficit'?: number;
    /**
     * When the license information was last updated (UNIX Timestamp)
     * @type {number}
     * @memberof V0041OpenapiLicensesRespLicensesInner
     */
    'LastUpdate'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiNodesResp
 */
export interface V0041OpenapiNodesResp {
    /**
     * List of nodes
     * @type {Array<V0041OpenapiNodesRespNodesInner>}
     * @memberof V0041OpenapiNodesResp
     */
    'nodes': Array<V0041OpenapiNodesRespNodesInner>;
    /**
     * 
     * @type {V0041OpenapiNodesRespLastUpdate}
     * @memberof V0041OpenapiNodesResp
     */
    'last_update': V0041OpenapiNodesRespLastUpdate;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiNodesResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiNodesResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiNodesResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Time of last node change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiNodesRespLastUpdate
 */
export interface V0041OpenapiNodesRespLastUpdate {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespLastUpdate
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespLastUpdate
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespLastUpdate
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiNodesRespNodesInner
 */
export interface V0041OpenapiNodesRespNodesInner {
    /**
     * Computer architecture
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'architecture'?: string;
    /**
     * Alternate network path to be used for sbcast network traffic
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'burstbuffer_network_address'?: string;
    /**
     * Number of Baseboards in nodes with a baseboard controller
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'boards'?: number;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerBootTime}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'boot_time'?: V0041OpenapiNodesRespNodesInnerBootTime;
    /**
     * Cluster name (only set in federated environments)
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'cluster_name'?: string;
    /**
     * Number of cores in a single physical processor socket
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'cores'?: number;
    /**
     * Number of cores reserved for system use
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'specialized_cores'?: number;
    /**
     * Default method for binding tasks to allocated CPUs
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'cpu_binding'?: number;
    /**
     * CPU load as reported by the OS
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'cpu_load'?: number;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerFreeMem}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'free_mem'?: V0041OpenapiNodesRespNodesInnerFreeMem;
    /**
     * Total CPUs, including cores and threads
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'cpus'?: number;
    /**
     * Number of effective CPUs (excluding specialized CPUs)
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'effective_cpus'?: number;
    /**
     * Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'specialized_cpus'?: string;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerEnergy}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'energy'?: V0041OpenapiNodesRespNodesInnerEnergy;
    /**
     * 
     * @type {object}
     * @memberof V0041OpenapiNodesRespNodesInner
     * @deprecated
     */
    'external_sensors'?: object;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'extra'?: string;
    /**
     * 
     * @type {object}
     * @memberof V0041OpenapiNodesRespNodesInner
     * @deprecated
     */
    'power'?: object;
    /**
     * Available features
     * @type {Array<string>}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'features'?: Array<string>;
    /**
     * Currently active features
     * @type {Array<string>}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'active_features'?: Array<string>;
    /**
     * CPU cores reserved for jobs that also use a GPU
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'gpu_spec'?: string;
    /**
     * Generic resources
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'gres'?: string;
    /**
     * Drained generic resources
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'gres_drained'?: string;
    /**
     * Generic resources currently in use
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'gres_used'?: string;
    /**
     * Cloud instance ID
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'instance_id'?: string;
    /**
     * Cloud instance type
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'instance_type'?: string;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerLastBusy}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'last_busy'?: V0041OpenapiNodesRespNodesInnerLastBusy;
    /**
     * Multi-Category Security label
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'mcs_label'?: string;
    /**
     * Combined memory limit, in MB, for Slurm compute node daemons
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'specialized_memory'?: number;
    /**
     * NodeName
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'name'?: string;
    /**
     * The state the node will be assigned after rebooting
     * @type {Array<string>}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'next_state_after_reboot'?: Array<V0041OpenapiNodesRespNodesInnerNextStateAfterRebootEnum>;
    /**
     * NodeAddr, used to establish a communication path
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'address'?: string;
    /**
     * NodeHostname
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'hostname'?: string;
    /**
     * Node state(s) applicable to this node
     * @type {Array<string>}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'state'?: Array<V0041OpenapiNodesRespNodesInnerStateEnum>;
    /**
     * Operating system reported by the node
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'operating_system'?: string;
    /**
     * User allowed to run jobs on this node (unset if no restriction)
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'owner'?: string;
    /**
     * Partitions containing this node
     * @type {Array<string>}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'partitions'?: Array<string>;
    /**
     * TCP port number of the slurmd
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'port'?: number;
    /**
     * Total memory in MB on the node
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'real_memory'?: number;
    /**
     * Number of CPU cores per GPU restricted to GPU jobs
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'res_cores_per_gpu'?: number;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'comment'?: string;
    /**
     * Describes why the node is in a \"DOWN\", \"DRAINED\", \"DRAINING\", \"FAILING\" or \"FAIL\" state
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'reason'?: string;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerReasonChangedAt}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'reason_changed_at'?: V0041OpenapiNodesRespNodesInnerReasonChangedAt;
    /**
     * User who set the reason
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'reason_set_by_user'?: string;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerResumeAfter}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'resume_after'?: V0041OpenapiNodesRespNodesInnerResumeAfter;
    /**
     * Name of reservation containing this node
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'reservation'?: string;
    /**
     * Total memory in MB currently allocated for jobs
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'alloc_memory'?: number;
    /**
     * Total number of CPUs currently allocated for jobs
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'alloc_cpus'?: number;
    /**
     * Total number of idle CPUs
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'alloc_idle_cpus'?: number;
    /**
     * Trackable resources currently allocated for jobs
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'tres_used'?: string;
    /**
     * Weighted number of billable trackable resources allocated
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'tres_weighted'?: number;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerSlurmdStartTime}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'slurmd_start_time'?: V0041OpenapiNodesRespNodesInnerSlurmdStartTime;
    /**
     * Number of physical processor sockets/chips on the node
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'sockets'?: number;
    /**
     * Number of logical threads in a single physical core
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'threads'?: number;
    /**
     * Total size in MB of temporary disk storage in TmpFS
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'temporary_disk'?: number;
    /**
     * Weight of the node for scheduling purposes
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'weight'?: number;
    /**
     * Configured trackable resources
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'tres'?: string;
    /**
     * Slurmd version
     * @type {string}
     * @memberof V0041OpenapiNodesRespNodesInner
     */
    'version'?: string;
}

export const V0041OpenapiNodesRespNodesInnerNextStateAfterRebootEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0041OpenapiNodesRespNodesInnerNextStateAfterRebootEnum = typeof V0041OpenapiNodesRespNodesInnerNextStateAfterRebootEnum[keyof typeof V0041OpenapiNodesRespNodesInnerNextStateAfterRebootEnum];
export const V0041OpenapiNodesRespNodesInnerStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0041OpenapiNodesRespNodesInnerStateEnum = typeof V0041OpenapiNodesRespNodesInnerStateEnum[keyof typeof V0041OpenapiNodesRespNodesInnerStateEnum];

/**
 * Time when the node booted (UNIX timestamp)
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerBootTime
 */
export interface V0041OpenapiNodesRespNodesInnerBootTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerBootTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerBootTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerBootTime
     */
    'number'?: number;
}
/**
 * Energy usage data
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerEnergy
 */
export interface V0041OpenapiNodesRespNodesInnerEnergy {
    /**
     * Average power consumption, in watts
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'average_watts'?: number;
    /**
     * The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'base_consumed_energy'?: number;
    /**
     * The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'consumed_energy'?: number;
    /**
     * 
     * @type {V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'current_watts'?: V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts;
    /**
     * Previous value of consumed_energy
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'previous_consumed_energy'?: number;
    /**
     * Time when energy data was last retrieved (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergy
     */
    'last_collected'?: number;
}
/**
 * The instantaneous power consumption at the time of the last node energy accounting sample, in watts
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts
 */
export interface V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerEnergyCurrentWatts
     */
    'number'?: number;
}
/**
 * Total memory in MB currently free as reported by the OS
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerFreeMem
 */
export interface V0041OpenapiNodesRespNodesInnerFreeMem {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerFreeMem
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerFreeMem
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerFreeMem
     */
    'number'?: number;
}
/**
 * Time when the node was last busy (UNIX timestamp)
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerLastBusy
 */
export interface V0041OpenapiNodesRespNodesInnerLastBusy {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerLastBusy
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerLastBusy
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerLastBusy
     */
    'number'?: number;
}
/**
 * When the reason changed (UNIX timestamp)
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerReasonChangedAt
 */
export interface V0041OpenapiNodesRespNodesInnerReasonChangedAt {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerReasonChangedAt
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerReasonChangedAt
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerReasonChangedAt
     */
    'number'?: number;
}
/**
 * Number of seconds after the node\'s state is updated to \"DOWN\" or \"DRAIN\" before scheduling a node state resume
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerResumeAfter
 */
export interface V0041OpenapiNodesRespNodesInnerResumeAfter {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerResumeAfter
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerResumeAfter
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerResumeAfter
     */
    'number'?: number;
}
/**
 * Time when the slurmd started (UNIX timestamp)
 * @export
 * @interface V0041OpenapiNodesRespNodesInnerSlurmdStartTime
 */
export interface V0041OpenapiNodesRespNodesInnerSlurmdStartTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerSlurmdStartTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiNodesRespNodesInnerSlurmdStartTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiNodesRespNodesInnerSlurmdStartTime
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPartitionResp
 */
export interface V0041OpenapiPartitionResp {
    /**
     * List of partitions
     * @type {Array<V0041OpenapiPartitionRespPartitionsInner>}
     * @memberof V0041OpenapiPartitionResp
     */
    'partitions': Array<V0041OpenapiPartitionRespPartitionsInner>;
    /**
     * 
     * @type {V0041OpenapiPartitionRespLastUpdate}
     * @memberof V0041OpenapiPartitionResp
     */
    'last_update': V0041OpenapiPartitionRespLastUpdate;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiPartitionResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiPartitionResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiPartitionResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Time of last partition change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiPartitionRespLastUpdate
 */
export interface V0041OpenapiPartitionRespLastUpdate {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespLastUpdate
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespLastUpdate
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespLastUpdate
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInner
 */
export interface V0041OpenapiPartitionRespPartitionsInner {
    /**
     * 
     * @type {V0040PartitionInfoNodes}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'nodes'?: V0040PartitionInfoNodes;
    /**
     * 
     * @type {V0040PartitionInfoAccounts}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'accounts'?: V0040PartitionInfoAccounts;
    /**
     * 
     * @type {V0040PartitionInfoGroups}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'groups'?: V0040PartitionInfoGroups;
    /**
     * 
     * @type {V0040PartitionInfoQos}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'qos'?: V0040PartitionInfoQos;
    /**
     * Alternate
     * @type {string}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'alternate'?: string;
    /**
     * 
     * @type {V0040PartitionInfoTres}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'tres'?: V0040PartitionInfoTres;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'cluster'?: string;
    /**
     * Scheduler consumable resource selection type
     * @type {Array<string>}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'select_type'?: Array<V0041OpenapiPartitionRespPartitionsInnerSelectTypeEnum>;
    /**
     * 
     * @type {V0040PartitionInfoCpus}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'cpus'?: V0040PartitionInfoCpus;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerDefaults}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'defaults'?: V0041OpenapiPartitionRespPartitionsInnerDefaults;
    /**
     * GraceTime
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'grace_time'?: number;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximums}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'maximums'?: V0041OpenapiPartitionRespPartitionsInnerMaximums;
    /**
     * 
     * @type {V0040PartitionInfoMinimums}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'minimums'?: V0040PartitionInfoMinimums;
    /**
     * PartitionName
     * @type {string}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'name'?: string;
    /**
     * NodeSets
     * @type {string}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'node_sets'?: string;
    /**
     * 
     * @type {V0040PartitionInfoPriority}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'priority'?: V0040PartitionInfoPriority;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerTimeouts}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'timeouts'?: V0041OpenapiPartitionRespPartitionsInnerTimeouts;
    /**
     * 
     * @type {V0040PartitionInfoPartition}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'partition'?: V0040PartitionInfoPartition;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerSuspendTime}
     * @memberof V0041OpenapiPartitionRespPartitionsInner
     */
    'suspend_time'?: V0041OpenapiPartitionRespPartitionsInnerSuspendTime;
}

export const V0041OpenapiPartitionRespPartitionsInnerSelectTypeEnum = {
    Cpu: 'CPU',
    Socket: 'SOCKET',
    Core: 'CORE',
    Board: 'BOARD',
    Memory: 'MEMORY',
    OneTaskPerCore: 'ONE_TASK_PER_CORE',
    PackNodes: 'PACK_NODES',
    CoreDefaultDistBlock: 'CORE_DEFAULT_DIST_BLOCK',
    Lln: 'LLN',
    Linear: 'LINEAR'
} as const;

export type V0041OpenapiPartitionRespPartitionsInnerSelectTypeEnum = typeof V0041OpenapiPartitionRespPartitionsInnerSelectTypeEnum[keyof typeof V0041OpenapiPartitionRespPartitionsInnerSelectTypeEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerDefaults
 */
export interface V0041OpenapiPartitionRespPartitionsInnerDefaults {
    /**
     * DefMemPerCPU or DefMemPerNode
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaults
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaults
     */
    'partition_memory_per_cpu'?: V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaults
     */
    'partition_memory_per_node'?: V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerDefaultsTime}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaults
     */
    'time'?: V0041OpenapiPartitionRespPartitionsInnerDefaultsTime;
    /**
     * JobDefaults
     * @type {string}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaults
     */
    'job'?: string;
}
/**
 * DefMemPerCPU
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu
 */
export interface V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerCpu
     */
    'number'?: number;
}
/**
 * DefMemPerNode
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode
 */
export interface V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsPartitionMemoryPerNode
     */
    'number'?: number;
}
/**
 * DefaultTime in minutes
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerDefaultsTime
 */
export interface V0041OpenapiPartitionRespPartitionsInnerDefaultsTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerDefaultsTime
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximums
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximums {
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'cpus_per_node'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'cpus_per_socket'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket;
    /**
     * MaxMemPerCPU or MaxMemPerNode
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'memory_per_cpu'?: number;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'partition_memory_per_cpu'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'partition_memory_per_node'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'nodes'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes;
    /**
     * OverSubscribe
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'shares'?: number;
    /**
     * 
     * @type {V0040PartitionInfoMaximumsOversubscribe}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'oversubscribe'?: V0040PartitionInfoMaximumsOversubscribe;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsTime}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'time'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsTime;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximums
     */
    'over_time_limit'?: V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit;
}
/**
 * MaxCPUsPerNode
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerNode
     */
    'number'?: number;
}
/**
 * MaxCPUsPerSocket
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsCpusPerSocket
     */
    'number'?: number;
}
/**
 * MaxNodes
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsNodes
     */
    'number'?: number;
}
/**
 * OverTimeLimit
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsOverTimeLimit
     */
    'number'?: number;
}
/**
 * MaxMemPerCPU
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerCpu
     */
    'number'?: number;
}
/**
 * MaxMemPerNode
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsPartitionMemoryPerNode
     */
    'number'?: number;
}
/**
 * MaxTime
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerMaximumsTime
 */
export interface V0041OpenapiPartitionRespPartitionsInnerMaximumsTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerMaximumsTime
     */
    'number'?: number;
}
/**
 * SuspendTime (GLOBAL if both set and infinite are false)
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerSuspendTime
 */
export interface V0041OpenapiPartitionRespPartitionsInnerSuspendTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerSuspendTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerSuspendTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerSuspendTime
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerTimeouts
 */
export interface V0041OpenapiPartitionRespPartitionsInnerTimeouts {
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeouts
     */
    'resume'?: V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume;
    /**
     * 
     * @type {V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeouts
     */
    'suspend'?: V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend;
}
/**
 * ResumeTimeout (GLOBAL if both set and infinite are false)
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume
 */
export interface V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsResume
     */
    'number'?: number;
}
/**
 * SuspendTimeout (GLOBAL if both set and infinite are false)
 * @export
 * @interface V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend
 */
export interface V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiPartitionRespPartitionsInnerTimeoutsSuspend
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPingArrayResp
 */
export interface V0041OpenapiPingArrayResp {
    /**
     * pings
     * @type {Array<V0041OpenapiPingArrayRespPingsInner>}
     * @memberof V0041OpenapiPingArrayResp
     */
    'pings': Array<V0041OpenapiPingArrayRespPingsInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiPingArrayResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiPingArrayResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiPingArrayResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiPingArrayRespPingsInner
 */
export interface V0041OpenapiPingArrayRespPingsInner {
    /**
     * Target for ping
     * @type {string}
     * @memberof V0041OpenapiPingArrayRespPingsInner
     */
    'hostname'?: string;
    /**
     * Ping result
     * @type {string}
     * @memberof V0041OpenapiPingArrayRespPingsInner
     */
    'pinged'?: string;
    /**
     * Number of microseconds it took to successfully ping or timeout
     * @type {number}
     * @memberof V0041OpenapiPingArrayRespPingsInner
     */
    'latency'?: number;
    /**
     * The operating mode of the responding slurmctld
     * @type {string}
     * @memberof V0041OpenapiPingArrayRespPingsInner
     */
    'mode'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiReservationResp
 */
export interface V0041OpenapiReservationResp {
    /**
     * List of reservations
     * @type {Array<V0041OpenapiReservationRespReservationsInner>}
     * @memberof V0041OpenapiReservationResp
     */
    'reservations': Array<V0041OpenapiReservationRespReservationsInner>;
    /**
     * 
     * @type {V0041OpenapiReservationRespLastUpdate}
     * @memberof V0041OpenapiReservationResp
     */
    'last_update': V0041OpenapiReservationRespLastUpdate;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiReservationResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiReservationResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiReservationResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Time of last reservation change (UNIX timestamp)
 * @export
 * @interface V0041OpenapiReservationRespLastUpdate
 */
export interface V0041OpenapiReservationRespLastUpdate {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespLastUpdate
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespLastUpdate
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiReservationRespLastUpdate
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiReservationRespReservationsInner
 */
export interface V0041OpenapiReservationRespReservationsInner {
    /**
     * Comma separated list of permitted accounts
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'accounts'?: string;
    /**
     * BurstBuffer
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'burst_buffer'?: string;
    /**
     * CoreCnt
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'core_count'?: number;
    /**
     * Reserved cores specification
     * @type {Array<V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner>}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'core_specializations'?: Array<V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner>;
    /**
     * 
     * @type {V0041OpenapiReservationRespReservationsInnerEndTime}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'end_time'?: V0041OpenapiReservationRespReservationsInnerEndTime;
    /**
     * Features
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'features'?: string;
    /**
     * Flags associated with the reservation
     * @type {Array<string>}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'flags'?: Array<V0041OpenapiReservationRespReservationsInnerFlagsEnum>;
    /**
     * Groups
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'groups'?: string;
    /**
     * Licenses
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'licenses'?: string;
    /**
     * MaxStartDelay in seconds
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'max_start_delay'?: number;
    /**
     * ReservationName
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'name'?: string;
    /**
     * NodeCnt
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'node_count'?: number;
    /**
     * Nodes
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'node_list'?: string;
    /**
     * PartitionName
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'partition'?: string;
    /**
     * 
     * @type {V0041OpenapiReservationRespReservationsInnerPurgeCompleted}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'purge_completed'?: V0041OpenapiReservationRespReservationsInnerPurgeCompleted;
    /**
     * 
     * @type {V0041OpenapiReservationRespReservationsInnerStartTime}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'start_time'?: V0041OpenapiReservationRespReservationsInnerStartTime;
    /**
     * 
     * @type {V0041OpenapiReservationRespReservationsInnerWatts}
     * @memberof V0041OpenapiReservationRespReservationsInner
     * @deprecated
     */
    'watts'?: V0041OpenapiReservationRespReservationsInnerWatts;
    /**
     * Comma separated list of required TRES
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'tres'?: string;
    /**
     * Comma separated list of permitted users
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInner
     */
    'users'?: string;
}

export const V0041OpenapiReservationRespReservationsInnerFlagsEnum = {
    Maint: 'MAINT',
    NoMaint: 'NO_MAINT',
    Daily: 'DAILY',
    NoDaily: 'NO_DAILY',
    Weekly: 'WEEKLY',
    NoWeekly: 'NO_WEEKLY',
    IgnoreJobs: 'IGNORE_JOBS',
    NoIgnoreJobs: 'NO_IGNORE_JOBS',
    AnyNodes: 'ANY_NODES',
    Static: 'STATIC',
    NoStatic: 'NO_STATIC',
    PartNodes: 'PART_NODES',
    NoPartNodes: 'NO_PART_NODES',
    Overlap: 'OVERLAP',
    SpecNodes: 'SPEC_NODES',
    TimeFloat: 'TIME_FLOAT',
    Replace: 'REPLACE',
    AllNodes: 'ALL_NODES',
    PurgeComp: 'PURGE_COMP',
    Weekday: 'WEEKDAY',
    NoWeekday: 'NO_WEEKDAY',
    Weekend: 'WEEKEND',
    NoWeekend: 'NO_WEEKEND',
    Flex: 'FLEX',
    NoFlex: 'NO_FLEX',
    DurationPlus: 'DURATION_PLUS',
    DurationMinus: 'DURATION_MINUS',
    NoHoldJobsAfterEnd: 'NO_HOLD_JOBS_AFTER_END',
    NoPurgeComp: 'NO_PURGE_COMP',
    Magnetic: 'MAGNETIC',
    Skip: 'SKIP',
    Hourly: 'HOURLY',
    NoHourly: 'NO_HOURLY',
    UserDelete: 'USER_DELETE',
    NoUserDelete: 'NO_USER_DELETE',
    Reoccurring: 'REOCCURRING'
} as const;

export type V0041OpenapiReservationRespReservationsInnerFlagsEnum = typeof V0041OpenapiReservationRespReservationsInnerFlagsEnum[keyof typeof V0041OpenapiReservationRespReservationsInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner
 */
export interface V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner {
    /**
     * Name of reserved node
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner
     */
    'node'?: string;
    /**
     * IDs of reserved cores
     * @type {string}
     * @memberof V0041OpenapiReservationRespReservationsInnerCoreSpecializationsInner
     */
    'core'?: string;
}
/**
 * EndTime (UNIX timestamp)
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerEndTime
 */
export interface V0041OpenapiReservationRespReservationsInnerEndTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerEndTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerEndTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInnerEndTime
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerPurgeCompleted
 */
export interface V0041OpenapiReservationRespReservationsInnerPurgeCompleted {
    /**
     * 
     * @type {V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime}
     * @memberof V0041OpenapiReservationRespReservationsInnerPurgeCompleted
     */
    'time'?: V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime;
}
/**
 * If PURGE_COMP flag is set, the number of seconds this reservation will sit idle until it is revoked
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime
 */
export interface V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInnerPurgeCompletedTime
     */
    'number'?: number;
}
/**
 * StartTime (UNIX timestamp)
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerStartTime
 */
export interface V0041OpenapiReservationRespReservationsInnerStartTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerStartTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerStartTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInnerStartTime
     */
    'number'?: number;
}
/**
 * 32 bit integer number with flags
 * @export
 * @interface V0041OpenapiReservationRespReservationsInnerWatts
 */
export interface V0041OpenapiReservationRespReservationsInnerWatts {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerWatts
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiReservationRespReservationsInnerWatts
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiReservationRespReservationsInnerWatts
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiResp
 */
export interface V0041OpenapiResp {
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesResp
 */
export interface V0041OpenapiSharesResp {
    /**
     * 
     * @type {V0041OpenapiSharesRespShares}
     * @memberof V0041OpenapiSharesResp
     */
    'shares': V0041OpenapiSharesRespShares;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSharesResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSharesResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSharesResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespErrorsInner
 */
export interface V0041OpenapiSharesRespErrorsInner {
    /**
     * Long form error description
     * @type {string}
     * @memberof V0041OpenapiSharesRespErrorsInner
     */
    'description'?: string;
    /**
     * Slurm numeric error identifier
     * @type {number}
     * @memberof V0041OpenapiSharesRespErrorsInner
     */
    'error_number'?: number;
    /**
     * Short form error description
     * @type {string}
     * @memberof V0041OpenapiSharesRespErrorsInner
     */
    'error'?: string;
    /**
     * Source of error or where error was first detected
     * @type {string}
     * @memberof V0041OpenapiSharesRespErrorsInner
     */
    'source'?: string;
}
/**
 * Slurm meta values
 * @export
 * @interface V0041OpenapiSharesRespMeta
 */
export interface V0041OpenapiSharesRespMeta {
    /**
     * 
     * @type {V0040OpenapiMetaPlugin}
     * @memberof V0041OpenapiSharesRespMeta
     */
    'plugin'?: V0040OpenapiMetaPlugin;
    /**
     * 
     * @type {V0040OpenapiMetaClient}
     * @memberof V0041OpenapiSharesRespMeta
     */
    'client'?: V0040OpenapiMetaClient;
    /**
     * CLI command (if applicable)
     * @type {Array<string>}
     * @memberof V0041OpenapiSharesRespMeta
     */
    'command'?: Array<string>;
    /**
     * 
     * @type {V0040OpenapiMetaSlurm}
     * @memberof V0041OpenapiSharesRespMeta
     */
    'slurm'?: V0040OpenapiMetaSlurm;
}
/**
 * fairshare info
 * @export
 * @interface V0041OpenapiSharesRespShares
 */
export interface V0041OpenapiSharesRespShares {
    /**
     * Association shares
     * @type {Array<V0041OpenapiSharesRespSharesSharesInner>}
     * @memberof V0041OpenapiSharesRespShares
     */
    'shares'?: Array<V0041OpenapiSharesRespSharesSharesInner>;
    /**
     * Total number of shares
     * @type {number}
     * @memberof V0041OpenapiSharesRespShares
     */
    'total_shares'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInner
 */
export interface V0041OpenapiSharesRespSharesSharesInner {
    /**
     * Association ID
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'id'?: number;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'cluster'?: string;
    /**
     * Share name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'name'?: string;
    /**
     * Parent name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'parent'?: string;
    /**
     * Partition name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'partition'?: string;
    /**
     * 
     * @type {V0041OpenapiSharesRespSharesSharesInnerSharesNormalized}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'shares_normalized'?: V0041OpenapiSharesRespSharesSharesInnerSharesNormalized;
    /**
     * 
     * @type {V0041OpenapiSharesRespSharesSharesInnerShares}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'shares'?: V0041OpenapiSharesRespSharesSharesInnerShares;
    /**
     * 
     * @type {V0041OpenapiSharesRespSharesSharesInnerTres}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'tres'?: V0041OpenapiSharesRespSharesSharesInnerTres;
    /**
     * Effective, normalized usage
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'effective_usage'?: number;
    /**
     * 
     * @type {V0041OpenapiSharesRespSharesSharesInnerUsageNormalized}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'usage_normalized'?: V0041OpenapiSharesRespSharesSharesInnerUsageNormalized;
    /**
     * Measure of tresbillableunits usage
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'usage'?: number;
    /**
     * 
     * @type {V0040AssocSharesObjWrapFairshare}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'fairshare'?: V0040AssocSharesObjWrapFairshare;
    /**
     * User or account association
     * @type {Array<string>}
     * @memberof V0041OpenapiSharesRespSharesSharesInner
     */
    'type'?: Array<V0041OpenapiSharesRespSharesSharesInnerTypeEnum>;
}

export const V0041OpenapiSharesRespSharesSharesInnerTypeEnum = {
    User: 'USER',
    Association: 'ASSOCIATION'
} as const;

export type V0041OpenapiSharesRespSharesSharesInnerTypeEnum = typeof V0041OpenapiSharesRespSharesSharesInnerTypeEnum[keyof typeof V0041OpenapiSharesRespSharesSharesInnerTypeEnum];

/**
 * Number of shares allocated
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerShares
 */
export interface V0041OpenapiSharesRespSharesSharesInnerShares {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerShares
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerShares
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerShares
     */
    'number'?: number;
}
/**
 * Normalized shares
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerSharesNormalized
 */
export interface V0041OpenapiSharesRespSharesSharesInnerSharesNormalized {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerSharesNormalized
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerSharesNormalized
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerSharesNormalized
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerTres
 */
export interface V0041OpenapiSharesRespSharesSharesInnerTres {
    /**
     * Currently running tres-secs = grp_used_tres_run_secs
     * @type {Array<V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner>}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTres
     */
    'run_seconds'?: Array<V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner>;
    /**
     * TRES-minute limit
     * @type {Array<V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner>}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTres
     */
    'group_minutes'?: Array<V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner>;
    /**
     * Measure of each TRES usage
     * @type {Array<V0041OpenapiSharesRespSharesSharesInnerTresUsageInner>}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTres
     */
    'usage'?: Array<V0041OpenapiSharesRespSharesSharesInnerTresUsageInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner
 */
export interface V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner {
    /**
     * TRES name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner
     */
    'name'?: string;
    /**
     * 
     * @type {V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInner
     */
    'value'?: V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue;
}
/**
 * TRES value
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue
 */
export interface V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresRunSecondsInnerValue
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerTresUsageInner
 */
export interface V0041OpenapiSharesRespSharesSharesInnerTresUsageInner {
    /**
     * TRES name
     * @type {string}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresUsageInner
     */
    'name'?: string;
    /**
     * TRES value
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerTresUsageInner
     */
    'value'?: number;
}
/**
 * Normalized usage
 * @export
 * @interface V0041OpenapiSharesRespSharesSharesInnerUsageNormalized
 */
export interface V0041OpenapiSharesRespSharesSharesInnerUsageNormalized {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerUsageNormalized
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerUsageNormalized
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSharesRespSharesSharesInnerUsageNormalized
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSharesRespWarningsInner
 */
export interface V0041OpenapiSharesRespWarningsInner {
    /**
     * Long form warning description
     * @type {string}
     * @memberof V0041OpenapiSharesRespWarningsInner
     */
    'description'?: string;
    /**
     * Source of warning or where warning was first detected
     * @type {string}
     * @memberof V0041OpenapiSharesRespWarningsInner
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigResp
 */
export interface V0041OpenapiSlurmdbdConfigResp {
    /**
     * Clusters
     * @type {Array<V0041OpenapiSlurmdbdConfigRespClustersInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'clusters'?: Array<V0041OpenapiSlurmdbdConfigRespClustersInner>;
    /**
     * TRES
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'tres'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Accounts
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'accounts'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInner>;
    /**
     * Users
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'users'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInner>;
    /**
     * QOS
     * @type {Array<V0041OpenapiSlurmdbdConfigRespQosInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'qos'?: Array<V0041OpenapiSlurmdbdConfigRespQosInner>;
    /**
     * WCKeys
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'wckeys'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>;
    /**
     * Associations
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAssociationsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'associations'?: Array<V0041OpenapiSlurmdbdConfigRespAssociationsInner>;
    /**
     * Instances
     * @type {Array<V0041OpenapiSlurmdbdConfigRespInstancesInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'instances'?: Array<V0041OpenapiSlurmdbdConfigRespInstancesInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAccountsInner
 */
export interface V0041OpenapiSlurmdbdConfigRespAccountsInner {
    /**
     * Associations involving this account (only populated if requested)
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'associations'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner>;
    /**
     * List of users that are a coordinator of this account (only populated if requested)
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'coordinators'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner>;
    /**
     * Arbitrary string describing the account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'description': string;
    /**
     * Account name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'name': string;
    /**
     * Organization to which the account belongs
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'organization': string;
    /**
     * Flags associated with the account
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerFlagsEnum>;
}

export const V0041OpenapiSlurmdbdConfigRespAccountsInnerFlagsEnum = {
    Deleted: 'DELETED',
    WithAssociations: 'WithAssociations',
    WithCoordinators: 'WithCoordinators',
    NoUsersAreCoords: 'NoUsersAreCoords',
    UsersAreCoords: 'UsersAreCoords'
} as const;

export type V0041OpenapiSlurmdbdConfigRespAccountsInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespAccountsInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespAccountsInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
 */
export interface V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner {
    /**
     * Account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
     */
    'account'?: string;
    /**
     * Cluster
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
     */
    'cluster'?: string;
    /**
     * Partition
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
     */
    'partition'?: string;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
     */
    'user': string;
    /**
     * Numeric association ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner
 */
export interface V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner {
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner
     */
    'name': string;
    /**
     * Indicates whether the coordinator was directly assigned to this account
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner
     */
    'direct'?: boolean;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInner
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInner {
    /**
     * Accounting records containing related resource usage
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'accounting'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner>;
    /**
     * Account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'account'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'cluster'?: string;
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'comment'?: string;
    /**
     * 
     * @type {V0040AssocDefault}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'default'?: V0040AssocDefault;
    /**
     * Flags on the association
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespAssociationsInnerFlagsEnum>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'max'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax;
    /**
     * Unique ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'id'?: number;
    /**
     * Is default association for user
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'is_default'?: boolean;
    /**
     * Complete path up the hierarchy to the root association
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'lineage'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMin}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'min'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMin;
    /**
     * Name of parent account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'parent_account'?: string;
    /**
     * Partition name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'partition'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'priority'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority;
    /**
     * List of available QOS names
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'qos'?: Array<string>;
    /**
     * Allocated shares used for fairshare calculation
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'shares_raw'?: number;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInner
     */
    'user': string;
}

export const V0041OpenapiSlurmdbdConfigRespAssociationsInnerFlagsEnum = {
    Deleted: 'DELETED',
    NoUpdate: 'NoUpdate',
    Exact: 'Exact',
    NoUsersAreCoords: 'NoUsersAreCoords',
    UsersAreCoords: 'UsersAreCoords'
} as const;

export type V0041OpenapiSlurmdbdConfigRespAssociationsInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespAssociationsInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespAssociationsInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax
     */
    'jobs'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax
     */
    'tres'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMax
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs
     */
    'active'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs
     */
    'accruing'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobs
     */
    'total'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal;
}
/**
 * MaxJobsAccrue
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsAccruing
     */
    'number'?: number;
}
/**
 * MaxJobs
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsActive
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer
     */
    'count'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer
     */
    'accruing'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer
     */
    'submitted'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPer
     */
    'wall_clock'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob;
}
/**
 * GrpSubmitJobs
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsPerSubmitted
     */
    'number'?: number;
}
/**
 * MaxSubmitJobs
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxJobsTotal
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPer
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPerAccount}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPer
     */
    'account'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPerAccount;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPerAccount
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPerAccount {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxPerAccount
     */
    'wall_clock'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres {
    /**
     * GrpTRES
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres
     */
    'total'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres
     */
    'group'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres
     */
    'minutes'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTres
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup {
    /**
     * GrpTRESMins
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup
     */
    'minutes'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * GrpTRESRunMins
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresGroup
     */
    'active'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes {
    /**
     * MaxTRESMinsPerJob
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes
     */
    'total'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutesPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutes
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutesPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutesPer
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutesPer {
    /**
     * MaxTRESMinsPerJob
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresMinutesPer
     */
    'job'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer {
    /**
     * MaxTRESPerJob
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer
     */
    'job'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESPerNode
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMaxTresPer
     */
    'node'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMin
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerMin {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerMin
     */
    'priority_threshold'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold;
}
/**
 * Association priority factor
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority
 */
export interface V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespClustersInner
 */
export interface V0041OpenapiSlurmdbdConfigRespClustersInner {
    /**
     * 
     * @type {V0040ClusterRecController}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'controller'?: V0040ClusterRecController;
    /**
     * Flags
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespClustersInnerFlagsEnum>;
    /**
     * ClusterName
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'name'?: string;
    /**
     * Node names
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'nodes'?: string;
    /**
     * 
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     * @deprecated
     */
    'select_plugin'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespClustersInnerAssociations}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'associations'?: V0041OpenapiSlurmdbdConfigRespClustersInnerAssociations;
    /**
     * RPC version used in the cluster
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'rpc_version'?: number;
    /**
     * Trackable resources
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInner
     */
    'tres'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}

export const V0041OpenapiSlurmdbdConfigRespClustersInnerFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;

export type V0041OpenapiSlurmdbdConfigRespClustersInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespClustersInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespClustersInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespClustersInnerAssociations
 */
export interface V0041OpenapiSlurmdbdConfigRespClustersInnerAssociations {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociations
     */
    'root'?: V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot;
}
/**
 * Root association information
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
 */
export interface V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot {
    /**
     * Account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
     */
    'account'?: string;
    /**
     * Cluster
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
     */
    'cluster'?: string;
    /**
     * Partition
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
     */
    'partition'?: string;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
     */
    'user': string;
    /**
     * Numeric association ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespClustersInnerAssociationsRoot
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespInstancesInner
 */
export interface V0041OpenapiSlurmdbdConfigRespInstancesInner {
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'cluster'?: string;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'extra'?: string;
    /**
     * Cloud instance ID
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'instance_id'?: string;
    /**
     * Cloud instance type
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'instance_type'?: string;
    /**
     * NodeName
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'node_name'?: string;
    /**
     * 
     * @type {V0040InstanceTime}
     * @memberof V0041OpenapiSlurmdbdConfigRespInstancesInner
     */
    'time'?: V0040InstanceTime;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInner
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInner {
    /**
     * Arbitrary description
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'description'?: string;
    /**
     * Flags, to avoid modifying current values specify NOT_SET
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespQosInnerFlagsEnum>;
    /**
     * Unique ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'id'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimits}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'limits'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimits;
    /**
     * Name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'name'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerPreempt}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'preempt'?: V0041OpenapiSlurmdbdConfigRespQosInnerPreempt;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerPriority}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'priority'?: V0041OpenapiSlurmdbdConfigRespQosInnerPriority;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'usage_factor'?: V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInner
     */
    'usage_threshold'?: V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold;
}

export const V0041OpenapiSlurmdbdConfigRespQosInnerFlagsEnum = {
    NotSet: 'NOT_SET',
    Add: 'ADD',
    Remove: 'REMOVE',
    PartitionMinimumNode: 'PARTITION_MINIMUM_NODE',
    PartitionMaximumNode: 'PARTITION_MAXIMUM_NODE',
    PartitionTimeLimit: 'PARTITION_TIME_LIMIT',
    EnforceUsageThreshold: 'ENFORCE_USAGE_THRESHOLD',
    NoReserve: 'NO_RESERVE',
    RequiredReservation: 'REQUIRED_RESERVATION',
    DenyLimit: 'DENY_LIMIT',
    OverridePartitionQos: 'OVERRIDE_PARTITION_QOS',
    NoDecay: 'NO_DECAY',
    UsageFactorSafe: 'USAGE_FACTOR_SAFE',
    Relative: 'RELATIVE'
} as const;

export type V0041OpenapiSlurmdbdConfigRespQosInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespQosInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespQosInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimits
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimits {
    /**
     * GraceTime
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimits
     */
    'grace_time'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimits
     */
    'max'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimits
     */
    'factor'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimits
     */
    'min'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin;
}
/**
 * LimitFactor
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsFactor
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
     */
    'active_jobs'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
     */
    'tres'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClock}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
     */
    'wall_clock'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClock;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
     */
    'jobs'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruing}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMax
     */
    'accruing'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruing;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruing
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruing {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruing
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer
     */
    'account'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPer
     */
    'user'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser;
}
/**
 * MaxJobsAccruePerAccount
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerAccount
     */
    'number'?: number;
}
/**
 * MaxJobsAccruePerUser
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxAccruingPerUser
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs
     */
    'accruing'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobs
     */
    'count'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount;
}
/**
 * GrpJobsAccrue
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsAccruing
     */
    'number'?: number;
}
/**
 * GrpJobs
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxActiveJobsCount
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobs}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs
     */
    'active_jobs'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobs;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobs
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobs
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobs {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobs
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer
     */
    'account'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPer
     */
    'user'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser;
}
/**
 * MaxJobsPerAccount
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerAccount
     */
    'number'?: number;
}
/**
 * MaxJobsPerUser
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsActiveJobsPerUser
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer
     */
    'account'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPer
     */
    'user'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser;
}
/**
 * MaxSubmitJobsPerAccount
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerAccount
     */
    'number'?: number;
}
/**
 * MaxSubmitJobsPerUser
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxJobsPerUser
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres {
    /**
     * GrpTRES
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres
     */
    'total'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutes}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres
     */
    'minutes'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutes;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTres
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutes
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutes {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutes
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer {
    /**
     * GrpTRESRunMins
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer
     */
    'qos'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESMinsPerJob
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer
     */
    'job'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESRunMinsPerAccount
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer
     */
    'account'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESRunMinsPerUser
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresMinutesPer
     */
    'user'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer {
    /**
     * MaxTRESPerAccount
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer
     */
    'account'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESPerJob
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer
     */
    'job'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESPerNode
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer
     */
    'node'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * MaxTRESPerUser
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxTresPer
     */
    'user'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClock
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClock {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClock
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer
     */
    'qos'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPer
     */
    'job'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob;
}
/**
 * MaxWallDurationPerJob
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerJob
     */
    'number'?: number;
}
/**
 * GrpWall
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMaxWallClockPerQos
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin
     */
    'priority_threshold'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTres}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMin
     */
    'tres'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTres;
}
/**
 * MinPrioThreshold
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinPriorityThreshold
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTres
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTres {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTresPer}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTres
     */
    'per'?: V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTresPer;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTresPer
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTresPer {
    /**
     * MinTRES
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerLimitsMinTresPer
     */
    'job'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerPreempt
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerPreempt {
    /**
     * Other QOS\'s this QOS can preempt
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreempt
     */
    'list'?: Array<string>;
    /**
     * PreemptMode
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreempt
     */
    'mode'?: Array<V0041OpenapiSlurmdbdConfigRespQosInnerPreemptModeEnum>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreempt
     */
    'exempt_time'?: V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime;
}

export const V0041OpenapiSlurmdbdConfigRespQosInnerPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;

export type V0041OpenapiSlurmdbdConfigRespQosInnerPreemptModeEnum = typeof V0041OpenapiSlurmdbdConfigRespQosInnerPreemptModeEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespQosInnerPreemptModeEnum];

/**
 * PreemptExemptTime
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPreemptExemptTime
     */
    'number'?: number;
}
/**
 * Priority
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerPriority
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerPriority {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPriority
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPriority
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerPriority
     */
    'number'?: number;
}
/**
 * UsageFactor
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageFactor
     */
    'number'?: number;
}
/**
 * UsageThreshold
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold
 */
export interface V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespQosInnerUsageThreshold
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespUsersInner
 */
export interface V0041OpenapiSlurmdbdConfigRespUsersInner {
    /**
     * AdminLevel granted to the user
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'administrator_level'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerAdministratorLevelEnum>;
    /**
     * Associations created for this user
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'associations'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerAssociationsInner>;
    /**
     * Accounts this user is a coordinator for
     * @type {Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'coordinators'?: Array<V0041OpenapiSlurmdbdConfigRespAccountsInnerCoordinatorsInner>;
    /**
     * 
     * @type {V0040UserDefault}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'default'?: V0040UserDefault;
    /**
     * Flags associated with user
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerFlagsEnum>;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'name': string;
    /**
     * Previous user name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'old_name'?: string;
    /**
     * List of available WCKeys
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInner
     */
    'wckeys'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>;
}

export const V0041OpenapiSlurmdbdConfigRespUsersInnerAdministratorLevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;

export type V0041OpenapiSlurmdbdConfigRespUsersInnerAdministratorLevelEnum = typeof V0041OpenapiSlurmdbdConfigRespUsersInnerAdministratorLevelEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespUsersInnerAdministratorLevelEnum];
export const V0041OpenapiSlurmdbdConfigRespUsersInnerFlagsEnum = {
    None: 'NONE',
    Deleted: 'DELETED'
} as const;

export type V0041OpenapiSlurmdbdConfigRespUsersInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespUsersInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespUsersInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
 */
export interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner {
    /**
     * Accounting records containing related resource usage
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'accounting'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner>;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'cluster': string;
    /**
     * Unique ID for this user-cluster-wckey combination
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'id'?: number;
    /**
     * WCKey name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'name': string;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'user': string;
    /**
     * Flags associated with the WCKey
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerFlagsEnum>;
}

export const V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerFlagsEnum = {
    Deleted: 'DELETED'
} as const;

export type V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerFlagsEnum = typeof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner
 */
export interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner {
    /**
     * 
     * @type {V0040AccountingAllocated}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner
     */
    'allocated'?: V0040AccountingAllocated;
    /**
     * Association ID or Workload characterization key ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner
     */
    'id'?: number;
    /**
     * When the record was started
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner
     */
    'start'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInner
     */
    'TRES'?: V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES;
}
/**
 * Trackable resources
 * @export
 * @interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES
 */
export interface V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES {
    /**
     * TRES type (CPU, MEM, etc)
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES
     */
    'type': string;
    /**
     * TRES name (if applicable)
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES
     */
    'name'?: string;
    /**
     * ID used in database
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES
     */
    'id'?: number;
    /**
     * TRES count (0 if listed generically)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInnerAccountingInnerTRES
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsResp
 */
export interface V0041OpenapiSlurmdbdJobsResp {
    /**
     * jobs
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInner>}
     * @memberof V0041OpenapiSlurmdbdJobsResp
     */
    'jobs': Array<V0041OpenapiSlurmdbdJobsRespJobsInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSlurmdbdJobsResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSlurmdbdJobsResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSlurmdbdJobsResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInner
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInner {
    /**
     * Account the job ran under
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'account'?: string;
    /**
     * 
     * @type {V0040JobComment}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'comment'?: V0040JobComment;
    /**
     * List of nodes allocated to the job
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'allocation_nodes'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerArray}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'array'?: V0041OpenapiSlurmdbdJobsRespJobsInnerArray;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'association'?: V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation;
    /**
     * The name of the block to be used (used with Blue Gene systems)
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'block'?: string;
    /**
     * Cluster name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'cluster'?: string;
    /**
     * Feature(s) the job requested as a constraint
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'constraints'?: string;
    /**
     * Absolute path to OCI container bundle
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'container'?: string;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCode}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'derived_exit_code'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCode;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerTime}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'time'?: V0041OpenapiSlurmdbdJobsRespJobsInnerTime;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'exit_code'?: V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'extra'?: string;
    /**
     * Name of node that caused job failure
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'failed_node'?: string;
    /**
     * Flags associated with the job
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'flags'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerFlagsEnum>;
    /**
     * Group ID of the user that owns the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'group'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerHet}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'het'?: V0041OpenapiSlurmdbdJobsRespJobsInnerHet;
    /**
     * Job ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'job_id'?: number;
    /**
     * Job name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'name'?: string;
    /**
     * License(s) required by the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'licenses'?: string;
    /**
     * 
     * @type {V0040JobMcs}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'mcs'?: V0040JobMcs;
    /**
     * Node(s) allocated to the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'nodes'?: string;
    /**
     * Partition assigned to the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'partition'?: string;
    /**
     * Hold (true) or release (false) job
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'hold'?: boolean;
    /**
     * 
     * @type {V0041JobDescMsgPriority}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'priority'?: V0041JobDescMsgPriority;
    /**
     * Quality of Service assigned to the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'qos'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerRequired}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'required'?: V0041OpenapiSlurmdbdJobsRespJobsInnerRequired;
    /**
     * User ID that requested termination of the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'kill_request_user'?: string;
    /**
     * 
     * @type {V0040JobReservation}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'reservation'?: V0040JobReservation;
    /**
     * Job batch script; only the first component in a HetJob is populated or honored
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'script'?: string;
    /**
     * Job stdin with expanded fields
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stdin_expanded'?: string;
    /**
     * Job stdout with expanded fields
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stdout_expanded'?: string;
    /**
     * Job stderr with expanded fields
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stderr_expanded'?: string;
    /**
     * Path to stdout file
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stdout'?: string;
    /**
     * Path to stderr file
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stderr'?: string;
    /**
     * Path to stdin file
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'stdin'?: string;
    /**
     * 
     * @type {V0040JobState}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'state'?: V0040JobState;
    /**
     * Individual steps in the job
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'steps'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner>;
    /**
     * Command used to submit the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'submit_line'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerTres}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'tres'?: V0041OpenapiSlurmdbdJobsRespJobsInnerTres;
    /**
     * Generic resources used by job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'used_gres'?: string;
    /**
     * User that owns the job
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'user'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerWckey}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'wckey'?: V0041OpenapiSlurmdbdJobsRespJobsInnerWckey;
    /**
     * Path to current working directory
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInner
     */
    'working_directory'?: string;
}

export const V0041OpenapiSlurmdbdJobsRespJobsInnerFlagsEnum = {
    None: 'NONE',
    ClearScheduling: 'CLEAR_SCHEDULING',
    NotSet: 'NOT_SET',
    StartedOnSubmit: 'STARTED_ON_SUBMIT',
    StartedOnSchedule: 'STARTED_ON_SCHEDULE',
    StartedOnBackfill: 'STARTED_ON_BACKFILL',
    StartReceived: 'START_RECEIVED'
} as const;

export type V0041OpenapiSlurmdbdJobsRespJobsInnerFlagsEnum = typeof V0041OpenapiSlurmdbdJobsRespJobsInnerFlagsEnum[keyof typeof V0041OpenapiSlurmdbdJobsRespJobsInnerFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerArray
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerArray {
    /**
     * Job ID of job array, or 0 if N/A
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerArray
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0040JobArrayLimits}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerArray
     */
    'limits'?: V0040JobArrayLimits;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerArrayTaskId}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerArray
     */
    'task_id'?: V0041OpenapiJobInfoRespJobsInnerArrayTaskId;
    /**
     * String expression of task IDs in this record
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerArray
     */
    'task'?: string;
}
/**
 * Unique identifier for the association
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation {
    /**
     * Account
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
     */
    'account'?: string;
    /**
     * Cluster
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
     */
    'cluster'?: string;
    /**
     * Partition
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
     */
    'partition'?: string;
    /**
     * User name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
     */
    'user': string;
    /**
     * Numeric association ID
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerAssociation
     */
    'id'?: number;
}
/**
 * Exit code
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode {
    /**
     * Status given by return code
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode
     */
    'status'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerExitCodeStatusEnum>;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode
     */
    'return_code'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeReturnCode;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode
     */
    'signal'?: V0041OpenapiJobInfoRespJobsInnerDerivedExitCodeSignal;
}

export const V0041OpenapiSlurmdbdJobsRespJobsInnerExitCodeStatusEnum = {
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Error: 'ERROR',
    Signaled: 'SIGNALED',
    CoreDumped: 'CORE_DUMPED'
} as const;

export type V0041OpenapiSlurmdbdJobsRespJobsInnerExitCodeStatusEnum = typeof V0041OpenapiSlurmdbdJobsRespJobsInnerExitCodeStatusEnum[keyof typeof V0041OpenapiSlurmdbdJobsRespJobsInnerExitCodeStatusEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerHet
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerHet {
    /**
     * Heterogeneous job ID, if applicable
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerHet
     */
    'job_id'?: number;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerHetJobOffset}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerHet
     */
    'job_offset'?: V0041OpenapiJobInfoRespJobsInnerHetJobOffset;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerRequired
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerRequired {
    /**
     * Minimum number of CPUs required
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerRequired
     */
    'CPUs'?: number;
    /**
     * 
     * @type {V0041JobDescMsgMemoryPerCpu}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerRequired
     */
    'memory_per_cpu'?: V0041JobDescMsgMemoryPerCpu;
    /**
     * 
     * @type {V0041OpenapiJobInfoRespJobsInnerMemoryPerNode}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerRequired
     */
    'memory_per_node'?: V0041OpenapiJobInfoRespJobsInnerMemoryPerNode;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'time'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'exit_code'?: V0041OpenapiSlurmdbdJobsRespJobsInnerExitCode;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'nodes'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes;
    /**
     * 
     * @type {V0040StepTasks}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'tasks'?: V0040StepTasks;
    /**
     * Process ID
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'pid'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'CPU'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU;
    /**
     * User ID that requested termination of the step
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'kill_request_user'?: string;
    /**
     * Current state
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'state'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStateEnum>;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'statistics'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'step'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep;
    /**
     * 
     * @type {V0040StepTask}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'task'?: V0040StepTask;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInner
     */
    'tres'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres;
}

export const V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStateEnum = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Suspended: 'SUSPENDED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    NodeFail: 'NODE_FAIL',
    Preempted: 'PREEMPTED',
    BootFail: 'BOOT_FAIL',
    Deadline: 'DEADLINE',
    OutOfMemory: 'OUT_OF_MEMORY',
    LaunchFailed: 'LAUNCH_FAILED',
    UpdateDb: 'UPDATE_DB',
    Requeued: 'REQUEUED',
    RequeueHold: 'REQUEUE_HOLD',
    SpecialExit: 'SPECIAL_EXIT',
    Resizing: 'RESIZING',
    Configuring: 'CONFIGURING',
    Completing: 'COMPLETING',
    Stopped: 'STOPPED',
    ReconfigFail: 'RECONFIG_FAIL',
    PowerUpNode: 'POWER_UP_NODE',
    Revoked: 'REVOKED',
    RequeueFed: 'REQUEUE_FED',
    ResvDelHold: 'RESV_DEL_HOLD',
    Signaling: 'SIGNALING',
    StageOut: 'STAGE_OUT'
} as const;

export type V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStateEnum = typeof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStateEnum[keyof typeof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStateEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU
     */
    'requested_frequency'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency;
    /**
     * Requested CPU frequency governor in kHz
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPU
     */
    'governor'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency
     */
    'min'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequency
     */
    'max'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax;
}
/**
 * Maximum requested CPU frequency in kHz
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMax
     */
    'number'?: number;
}
/**
 * Minimum requested CPU frequency in kHz
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerCPURequestedFrequencyMin
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes {
    /**
     * Number of nodes in the job step
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes
     */
    'count'?: number;
    /**
     * Node(s) allocated to the job step
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes
     */
    'range'?: string;
    /**
     * List of nodes used by the step
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerNodes
     */
    'list'?: Array<string>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics {
    /**
     * 
     * @type {V0040StepStatisticsCPU}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics
     */
    'CPU'?: V0040StepStatisticsCPU;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergy}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatistics
     */
    'energy'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergy;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergy
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergy {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergy
     */
    'consumed'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed;
}
/**
 * Total energy consumed by all tasks in a job in joules
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStatisticsEnergyConsumed
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep {
    /**
     * Step ID
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep
     */
    'id'?: string;
    /**
     * Step name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerStep
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime {
    /**
     * Elapsed time in seconds
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'elapsed'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'end'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'start'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart;
    /**
     * Time in suspended state in seconds
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0040StepTimeSystem}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'system'?: V0040StepTimeSystem;
    /**
     * 
     * @type {V0040StepTimeTotal}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'total'?: V0040StepTimeTotal;
    /**
     * 
     * @type {V0040StepTimeUser}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTime
     */
    'user'?: V0040StepTimeUser;
}
/**
 * End time (UNIX timestamp)
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeEnd
     */
    'number'?: number;
}
/**
 * Time execution began (UNIX timestamp)
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTimeStart
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres
     */
    'requested'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres
     */
    'consumed'?: V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed;
    /**
     * Trackable resources allocated to the step
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTres
     */
    'allocated'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed {
    /**
     * Maximum TRES usage consumed among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed
     */
    'max'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Minimum TRES usage consumed among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed
     */
    'min'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Average TRES usage consumed among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed
     */
    'average'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Total TRES usage consumed among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresConsumed
     */
    'total'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested {
    /**
     * Maximum TRES usage requested among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested
     */
    'max'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Minimum TRES usage requested among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested
     */
    'min'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Average TRES usage requested among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested
     */
    'average'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Total TRES usage requested among all tasks
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequested
     */
    'total'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner {
    /**
     * TRES type (CPU, MEM, etc)
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner
     */
    'type': string;
    /**
     * TRES name (if applicable)
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner
     */
    'name'?: string;
    /**
     * ID used in database
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner
     */
    'id'?: number;
    /**
     * TRES count (0 if listed generically)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerTime
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerTime {
    /**
     * Elapsed time in seconds
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'elapsed'?: number;
    /**
     * Time when the job became eligible to run (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'eligible'?: number;
    /**
     * End time (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'end'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'planned'?: V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned;
    /**
     * Time execution began (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'start'?: number;
    /**
     * Time when the job was submitted (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'submission'?: number;
    /**
     * Total time in suspended state in seconds
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'suspended'?: number;
    /**
     * 
     * @type {V0040JobTimeSystem}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'system'?: V0040JobTimeSystem;
    /**
     * 
     * @type {V0041JobDescMsgTimeLimit}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'limit'?: V0041JobDescMsgTimeLimit;
    /**
     * 
     * @type {V0040JobTimeTotal}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'total'?: V0040JobTimeTotal;
    /**
     * 
     * @type {V0040JobTimeUser}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTime
     */
    'user'?: V0040JobTimeUser;
}
/**
 * Time required to start job after becoming eligible to run in seconds
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTimePlanned
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerTres
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerTres {
    /**
     * Trackable resources allocated to the job
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTres
     */
    'allocated'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Trackable resources requested by job
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerTres
     */
    'requested'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
}
/**
 * Workload characterization key
 * @export
 * @interface V0041OpenapiSlurmdbdJobsRespJobsInnerWckey
 */
export interface V0041OpenapiSlurmdbdJobsRespJobsInnerWckey {
    /**
     * WCKey name
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerWckey
     */
    'wckey': string;
    /**
     * Active flags
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdJobsRespJobsInnerWckey
     */
    'flags': Array<V0041OpenapiSlurmdbdJobsRespJobsInnerWckeyFlagsEnum>;
}

export const V0041OpenapiSlurmdbdJobsRespJobsInnerWckeyFlagsEnum = {
    AssignedDefault: 'ASSIGNED_DEFAULT'
} as const;

export type V0041OpenapiSlurmdbdJobsRespJobsInnerWckeyFlagsEnum = typeof V0041OpenapiSlurmdbdJobsRespJobsInnerWckeyFlagsEnum[keyof typeof V0041OpenapiSlurmdbdJobsRespJobsInnerWckeyFlagsEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdQosRemovedResp
 */
export interface V0041OpenapiSlurmdbdQosRemovedResp {
    /**
     * removed QOS
     * @type {Array<string>}
     * @memberof V0041OpenapiSlurmdbdQosRemovedResp
     */
    'removed_qos': Array<string>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSlurmdbdQosRemovedResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSlurmdbdQosRemovedResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSlurmdbdQosRemovedResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdQosResp
 */
export interface V0041OpenapiSlurmdbdQosResp {
    /**
     * List of QOS
     * @type {Array<V0041OpenapiSlurmdbdConfigRespQosInner>}
     * @memberof V0041OpenapiSlurmdbdQosResp
     */
    'qos': Array<V0041OpenapiSlurmdbdConfigRespQosInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSlurmdbdQosResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSlurmdbdQosResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSlurmdbdQosResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsResp
 */
export interface V0041OpenapiSlurmdbdStatsResp {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatistics}
     * @memberof V0041OpenapiSlurmdbdStatsResp
     */
    'statistics': V0041OpenapiSlurmdbdStatsRespStatistics;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiSlurmdbdStatsResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiSlurmdbdStatsResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiSlurmdbdStatsResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * statistics
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatistics
 */
export interface V0041OpenapiSlurmdbdStatsRespStatistics {
    /**
     * When data collection started (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatistics
     */
    'time_start'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollups}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatistics
     */
    'rollups'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollups;
    /**
     * List of RPCs sent to the slurmdbd
     * @type {Array<V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner>}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatistics
     */
    'RPCs'?: Array<V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner>;
    /**
     * List of users that issued RPCs
     * @type {Array<V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner>}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatistics
     */
    'users'?: Array<V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner {
    /**
     * RPC type
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner
     */
    'rpc'?: string;
    /**
     * Number of RPCs processed
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner
     */
    'count'?: number;
    /**
     * 
     * @type {V0040StatsRpcTime}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRPCsInner
     */
    'time'?: V0040StatsRpcTime;
}
/**
 * Rollup statistics
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollups
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollups {
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollups
     */
    'hourly'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollups
     */
    'daily'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollups
     */
    'monthly'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily {
    /**
     * Number of daily rollups since last_run
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily
     */
    'count'?: number;
    /**
     * Last time daily rollup ran (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily
     */
    'last_run'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDaily
     */
    'duration'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration {
    /**
     * Total time spent doing daily daily rollup (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration
     */
    'last'?: number;
    /**
     * Longest daily rollup time (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration
     */
    'max'?: number;
    /**
     * Total time spent doing daily rollups (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsDailyDuration
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly {
    /**
     * Number of hourly rollups since last_run
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly
     */
    'count'?: number;
    /**
     * Last time hourly rollup ran (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly
     */
    'last_run'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourly
     */
    'duration'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration {
    /**
     * Total time spent doing last daily rollup (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration
     */
    'last'?: number;
    /**
     * Longest hourly rollup time (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration
     */
    'max'?: number;
    /**
     * Total time spent doing hourly rollups (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsHourlyDuration
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly {
    /**
     * Number of monthly rollups since last_run
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly
     */
    'count'?: number;
    /**
     * Last time monthly rollup ran (UNIX timestamp)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly
     */
    'last_run'?: number;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthly
     */
    'duration'?: V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration {
    /**
     * Total time spent doing monthly daily rollup (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration
     */
    'last'?: number;
    /**
     * Longest monthly rollup time (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration
     */
    'max'?: number;
    /**
     * Total time spent doing monthly rollups (seconds)
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsRollupsMonthlyDuration
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner
 */
export interface V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner {
    /**
     * User ID
     * @type {string}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner
     */
    'user'?: string;
    /**
     * Number of RPCs processed
     * @type {number}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner
     */
    'count'?: number;
    /**
     * 
     * @type {V0040StatsRpcTime}
     * @memberof V0041OpenapiSlurmdbdStatsRespStatisticsUsersInner
     */
    'time'?: V0040StatsRpcTime;
}
/**
 * 
 * @export
 * @interface V0041OpenapiTresResp
 */
export interface V0041OpenapiTresResp {
    /**
     * TRES
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiTresResp
     */
    'TRES': Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiTresResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiTresResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiTresResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiUsersAddCondResp
 */
export interface V0041OpenapiUsersAddCondResp {
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationCondition}
     * @memberof V0041OpenapiUsersAddCondResp
     */
    'association_condition': V0041OpenapiUsersAddCondRespAssociationCondition;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespUser}
     * @memberof V0041OpenapiUsersAddCondResp
     */
    'user': V0041OpenapiUsersAddCondRespUser;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiUsersAddCondResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiUsersAddCondResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiUsersAddCondResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Filters to select associations for users
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationCondition
 */
export interface V0041OpenapiUsersAddCondRespAssociationCondition {
    /**
     * CSV accounts list
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'accounts'?: Array<string>;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociation}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'association'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociation;
    /**
     * CSV clusters list
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'clusters'?: Array<string>;
    /**
     * CSV partitions list
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'partitions'?: Array<string>;
    /**
     * CSV users list
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'users': Array<string>;
    /**
     * CSV WCKeys list
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationCondition
     */
    'wckeys'?: Array<string>;
}
/**
 * Association limits and options
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociation
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociation {
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'comment'?: string;
    /**
     * Default QOS
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'defaultqos'?: string;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grpjobs'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grpjobsaccrue'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grpsubmitjobs'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs;
    /**
     * Maximum number of TRES able to be allocated by running jobs in this association and its children
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grptres'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grptresmins'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grptresrunmins'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'grpwall'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxjobs'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxjobsaccrue'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxsubmitjobs'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs;
    /**
     * Maximum number of TRES minutes each job is able to use in this association
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxtresminsperjob'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Maximum number of TRES minutes able to be allocated by running jobs in this association
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxtresrunmins'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Maximum number of TRES each job is able to use in this association
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxtresperjob'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * Maximum number of TRES each node is able to use
     * @type {Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxtrespernode'?: Array<V0041OpenapiSlurmdbdJobsRespJobsInnerStepsInnerTresRequestedMaxInner>;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'maxwalldurationperjob'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob;
    /**
     * 
     * @type {V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'minpriothresh'?: V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh;
    /**
     * Name of parent account
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'parent'?: string;
    /**
     * 
     * @type {V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'priority'?: V0041OpenapiSlurmdbdConfigRespAssociationsInnerPriority;
    /**
     * List of available QOS names
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'qoslevel'?: Array<string>;
    /**
     * Allocated shares used for fairshare calculation
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociation
     */
    'fairshare'?: number;
}
/**
 * Maximum number of running jobs in this association and its children
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobs
     */
    'number'?: number;
}
/**
 * Maximum number of pending jobs able to accrue age priority in this association and its children
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpjobsaccrue
     */
    'number'?: number;
}
/**
 * Maximum number of jobs which can be in a pending or running state at any time in this association and its children
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpsubmitjobs
     */
    'number'?: number;
}
/**
 * Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationGrpwall
     */
    'number'?: number;
}
/**
 * Maximum number of running jobs per user in this association
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobs
     */
    'number'?: number;
}
/**
 * Maximum number of pending jobs able to accrue age priority at any given time in this association
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxjobsaccrue
     */
    'number'?: number;
}
/**
 * Maximum number of jobs which can be in a pending or running state at any time in this association
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxsubmitjobs
     */
    'number'?: number;
}
/**
 * Maximum wall clock time each job is able to use in this association
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMaxwalldurationperjob
     */
    'number'?: number;
}
/**
 * Minimum priority required to reserve resources when scheduling
 * @export
 * @interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh
 */
export interface V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041OpenapiUsersAddCondRespAssociationConditionAssociationMinpriothresh
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface V0041OpenapiUsersAddCondRespStr
 */
export interface V0041OpenapiUsersAddCondRespStr {
    /**
     * added_users
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespStr
     */
    'added_users': string;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiUsersAddCondRespStr
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiUsersAddCondRespStr
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiUsersAddCondRespStr
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * Admin level of user, DefaultAccount, DefaultWCKey
 * @export
 * @interface V0041OpenapiUsersAddCondRespUser
 */
export interface V0041OpenapiUsersAddCondRespUser {
    /**
     * AdminLevel granted to the user
     * @type {Array<string>}
     * @memberof V0041OpenapiUsersAddCondRespUser
     */
    'adminlevel'?: Array<V0041OpenapiUsersAddCondRespUserAdminlevelEnum>;
    /**
     * Default account
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespUser
     */
    'defaultaccount'?: string;
    /**
     * Default WCKey
     * @type {string}
     * @memberof V0041OpenapiUsersAddCondRespUser
     */
    'defaultwckey'?: string;
}

export const V0041OpenapiUsersAddCondRespUserAdminlevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;

export type V0041OpenapiUsersAddCondRespUserAdminlevelEnum = typeof V0041OpenapiUsersAddCondRespUserAdminlevelEnum[keyof typeof V0041OpenapiUsersAddCondRespUserAdminlevelEnum];

/**
 * 
 * @export
 * @interface V0041OpenapiUsersResp
 */
export interface V0041OpenapiUsersResp {
    /**
     * users
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInner>}
     * @memberof V0041OpenapiUsersResp
     */
    'users': Array<V0041OpenapiSlurmdbdConfigRespUsersInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiUsersResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiUsersResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiUsersResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiWckeyRemovedResp
 */
export interface V0041OpenapiWckeyRemovedResp {
    /**
     * deleted wckeys
     * @type {Array<string>}
     * @memberof V0041OpenapiWckeyRemovedResp
     */
    'deleted_wckeys': Array<string>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiWckeyRemovedResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiWckeyRemovedResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiWckeyRemovedResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041OpenapiWckeyResp
 */
export interface V0041OpenapiWckeyResp {
    /**
     * wckeys
     * @type {Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>}
     * @memberof V0041OpenapiWckeyResp
     */
    'wckeys': Array<V0041OpenapiSlurmdbdConfigRespUsersInnerWckeysInner>;
    /**
     * 
     * @type {V0041OpenapiSharesRespMeta}
     * @memberof V0041OpenapiWckeyResp
     */
    'meta'?: V0041OpenapiSharesRespMeta;
    /**
     * Query errors
     * @type {Array<V0041OpenapiSharesRespErrorsInner>}
     * @memberof V0041OpenapiWckeyResp
     */
    'errors'?: Array<V0041OpenapiSharesRespErrorsInner>;
    /**
     * Query warnings
     * @type {Array<V0041OpenapiSharesRespWarningsInner>}
     * @memberof V0041OpenapiWckeyResp
     */
    'warnings'?: Array<V0041OpenapiSharesRespWarningsInner>;
}
/**
 * 
 * @export
 * @interface V0041UpdateNodeMsg
 */
export interface V0041UpdateNodeMsg {
    /**
     * Arbitrary comment
     * @type {string}
     * @memberof V0041UpdateNodeMsg
     */
    'comment'?: string;
    /**
     * Default method for binding tasks to allocated CPUs
     * @type {number}
     * @memberof V0041UpdateNodeMsg
     */
    'cpu_bind'?: number;
    /**
     * Arbitrary string used for node filtering if extra constraints are enabled
     * @type {string}
     * @memberof V0041UpdateNodeMsg
     */
    'extra'?: string;
    /**
     * Available features
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'features'?: Array<string>;
    /**
     * Currently active features
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'features_act'?: Array<string>;
    /**
     * Generic resources
     * @type {string}
     * @memberof V0041UpdateNodeMsg
     */
    'gres'?: string;
    /**
     * NodeAddr, used to establish a communication path
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'address'?: Array<string>;
    /**
     * NodeHostname
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'hostname'?: Array<string>;
    /**
     * NodeName
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'name'?: Array<string>;
    /**
     * New state to assign to the node
     * @type {Array<string>}
     * @memberof V0041UpdateNodeMsg
     */
    'state'?: Array<V0041UpdateNodeMsgStateEnum>;
    /**
     * Reason for node being DOWN or DRAINING
     * @type {string}
     * @memberof V0041UpdateNodeMsg
     */
    'reason'?: string;
    /**
     * User ID to associate with the reason (needed if user root is sending message)
     * @type {string}
     * @memberof V0041UpdateNodeMsg
     */
    'reason_uid'?: string;
    /**
     * 
     * @type {V0041UpdateNodeMsgResumeAfter}
     * @memberof V0041UpdateNodeMsg
     */
    'resume_after'?: V0041UpdateNodeMsgResumeAfter;
    /**
     * 
     * @type {V0041UpdateNodeMsgWeight}
     * @memberof V0041UpdateNodeMsg
     */
    'weight'?: V0041UpdateNodeMsgWeight;
}

export const V0041UpdateNodeMsgStateEnum = {
    Invalid: 'INVALID',
    Unknown: 'UNKNOWN',
    Down: 'DOWN',
    Idle: 'IDLE',
    Allocated: 'ALLOCATED',
    Error: 'ERROR',
    Mixed: 'MIXED',
    Future: 'FUTURE',
    Reserved: 'RESERVED',
    Undrain: 'UNDRAIN',
    Cloud: 'CLOUD',
    Resume: 'RESUME',
    Drain: 'DRAIN',
    Completing: 'COMPLETING',
    NotResponding: 'NOT_RESPONDING',
    PoweredDown: 'POWERED_DOWN',
    Fail: 'FAIL',
    PoweringUp: 'POWERING_UP',
    Maintenance: 'MAINTENANCE',
    RebootRequested: 'REBOOT_REQUESTED',
    RebootCanceled: 'REBOOT_CANCELED',
    PoweringDown: 'POWERING_DOWN',
    DynamicFuture: 'DYNAMIC_FUTURE',
    RebootIssued: 'REBOOT_ISSUED',
    Planned: 'PLANNED',
    InvalidReg: 'INVALID_REG',
    PowerDown: 'POWER_DOWN',
    PowerUp: 'POWER_UP',
    PowerDrain: 'POWER_DRAIN',
    DynamicNorm: 'DYNAMIC_NORM'
} as const;

export type V0041UpdateNodeMsgStateEnum = typeof V0041UpdateNodeMsgStateEnum[keyof typeof V0041UpdateNodeMsgStateEnum];

/**
 * Number of seconds after which to automatically resume DOWN or DRAINED node
 * @export
 * @interface V0041UpdateNodeMsgResumeAfter
 */
export interface V0041UpdateNodeMsgResumeAfter {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041UpdateNodeMsgResumeAfter
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041UpdateNodeMsgResumeAfter
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041UpdateNodeMsgResumeAfter
     */
    'number'?: number;
}
/**
 * Weight of the node for scheduling purposes
 * @export
 * @interface V0041UpdateNodeMsgWeight
 */
export interface V0041UpdateNodeMsgWeight {
    /**
     * True if number has been set; False if number is unset
     * @type {boolean}
     * @memberof V0041UpdateNodeMsgWeight
     */
    'set'?: boolean;
    /**
     * True if number has been set to infinite; \"set\" and \"number\" will be ignored
     * @type {boolean}
     * @memberof V0041UpdateNodeMsgWeight
     */
    'infinite'?: boolean;
    /**
     * If \"set\" is True the number will be set with value; otherwise ignore number contents
     * @type {number}
     * @memberof V0041UpdateNodeMsgWeight
     */
    'number'?: number;
}

/**
 * SlurmApi - axios parameter creator
 * @export
 */
export const SlurmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Slurm Job ID
         * @param {SlurmV0039CancelJobSignalEnum} [signal] signal to send to job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039CancelJob: async (jobId: string, signal?: SlurmV0039CancelJobSignalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0039CancelJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.39/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (signal !== undefined) {
                localVarQueryParameter['signal'] = signal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039DeleteNode: async (nodeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0039DeleteNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.39/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039Diag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/diag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0039GetJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.39/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get list of jobs
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetJobs: async (updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetNode: async (nodeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0039GetNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.39/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all node info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetNodes: async (updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Slurm Partition Name
         * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetPartition: async (partitionName: string, updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionName' is not null or undefined
            assertParamExists('slurmV0039GetPartition', 'partitionName', partitionName)
            const localVarPath = `/slurm/v0.0.39/partition/{partition_name}`
                .replace(`{${"partition_name"}}`, encodeURIComponent(String(partitionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all partition info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetPartitions: async (updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/partitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Slurm Reservation Name
         * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetReservation: async (reservationName: string, updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationName' is not null or undefined
            assertParamExists('slurmV0039GetReservation', 'reservationName', reservationName)
            const localVarPath = `/slurm/v0.0.39/reservation/{reservation_name}`
                .replace(`{${"reservation_name"}}`, encodeURIComponent(String(reservationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all reservation info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetReservations: async (updateTime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/reservations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039Ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039SlurmctldGetLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.39/licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit new job
         * @param {V0039JobSubmission} v0039JobSubmission submit new job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039SubmitJob: async (v0039JobSubmission: V0039JobSubmission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'v0039JobSubmission' is not null or undefined
            assertParamExists('slurmV0039SubmitJob', 'v0039JobSubmission', v0039JobSubmission)
            const localVarPath = `/slurm/v0.0.39/job/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0039JobSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Slurm Job ID
         * @param {V0039JobDescMsg} v0039JobDescMsg update job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039UpdateJob: async (jobId: string, v0039JobDescMsg: V0039JobDescMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0039UpdateJob', 'jobId', jobId)
            // verify required parameter 'v0039JobDescMsg' is not null or undefined
            assertParamExists('slurmV0039UpdateJob', 'v0039JobDescMsg', v0039JobDescMsg)
            const localVarPath = `/slurm/v0.0.39/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0039JobDescMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Slurm Node Name
         * @param {V0039UpdateNodeMsg} v0039UpdateNodeMsg update node
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039UpdateNode: async (nodeName: string, v0039UpdateNodeMsg: V0039UpdateNodeMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0039UpdateNode', 'nodeName', nodeName)
            // verify required parameter 'v0039UpdateNodeMsg' is not null or undefined
            assertParamExists('slurmV0039UpdateNode', 'v0039UpdateNodeMsg', v0039UpdateNodeMsg)
            const localVarPath = `/slurm/v0.0.39/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0039UpdateNodeMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0040DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteJob: async (jobId: string, signal?: string, flags?: SlurmV0040DeleteJobFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0040DeleteJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.40/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (signal !== undefined) {
                localVarQueryParameter['signal'] = signal;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0040KillJobsMsg} [v0040KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteJobs: async (v0040KillJobsMsg?: V0040KillJobsMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040KillJobsMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteNode: async (nodeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0040DeleteNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.40/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetDiag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/diag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJob: async (jobId: string, updateTime?: string, flags?: SlurmV0040GetJobFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0040GetJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.40/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJobs: async (updateTime?: string, flags?: SlurmV0040GetJobsFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJobsState: async (updateTime?: string, flags?: SlurmV0040GetJobsStateFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/jobs/state/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/licenses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetNode: async (nodeName: string, updateTime?: string, flags?: SlurmV0040GetNodeFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0040GetNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.40/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetNodes: async (updateTime?: string, flags?: SlurmV0040GetNodesFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/nodes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPartition: async (partitionName: string, updateTime?: string, flags?: SlurmV0040GetPartitionFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionName' is not null or undefined
            assertParamExists('slurmV0040GetPartition', 'partitionName', partitionName)
            const localVarPath = `/slurm/v0.0.40/partition/{partition_name}`
                .replace(`{${"partition_name"}}`, encodeURIComponent(String(partitionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPartitions: async (updateTime?: string, flags?: SlurmV0040GetPartitionsFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/partitions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/ping/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReconfigure: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/reconfigure/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReservation: async (reservationName: string, updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationName' is not null or undefined
            assertParamExists('slurmV0040GetReservation', 'reservationName', reservationName)
            const localVarPath = `/slurm/v0.0.40/reservation/{reservation_name}`
                .replace(`{${"reservation_name"}}`, encodeURIComponent(String(reservationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReservations: async (updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetShares: async (accounts?: string, users?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/shares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (users !== undefined) {
                localVarQueryParameter['users'] = users;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0040JobDescMsg} [v0040JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostJob: async (jobId: string, v0040JobDescMsg?: V0040JobDescMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0040PostJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.40/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040JobDescMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit new job
         * @param {V0040JobSubmitReq} [v0040JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostJobSubmit: async (v0040JobSubmitReq?: V0040JobSubmitReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.40/job/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040JobSubmitReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0040UpdateNodeMsg} [v0040UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostNode: async (nodeName: string, v0040UpdateNodeMsg?: V0040UpdateNodeMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0040PostNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.40/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040UpdateNodeMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0041DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteJob: async (jobId: string, signal?: string, flags?: SlurmV0041DeleteJobFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0041DeleteJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.41/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (signal !== undefined) {
                localVarQueryParameter['signal'] = signal;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0041KillJobsMsg} [v0041KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteJobs: async (v0041KillJobsMsg?: V0041KillJobsMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041KillJobsMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteNode: async (nodeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0041DeleteNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.41/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetDiag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/diag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJob: async (jobId: string, updateTime?: string, flags?: SlurmV0041GetJobFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0041GetJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.41/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJobs: async (updateTime?: string, flags?: SlurmV0041GetJobsFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJobsState: async (updateTime?: string, flags?: SlurmV0041GetJobsStateFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/jobs/state/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/licenses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetNode: async (nodeName: string, updateTime?: string, flags?: SlurmV0041GetNodeFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0041GetNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.41/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetNodes: async (updateTime?: string, flags?: SlurmV0041GetNodesFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/nodes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPartition: async (partitionName: string, updateTime?: string, flags?: SlurmV0041GetPartitionFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partitionName' is not null or undefined
            assertParamExists('slurmV0041GetPartition', 'partitionName', partitionName)
            const localVarPath = `/slurm/v0.0.41/partition/{partition_name}`
                .replace(`{${"partition_name"}}`, encodeURIComponent(String(partitionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPartitions: async (updateTime?: string, flags?: SlurmV0041GetPartitionsFlagsEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/partitions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/ping/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReconfigure: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/reconfigure/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReservation: async (reservationName: string, updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reservationName' is not null or undefined
            assertParamExists('slurmV0041GetReservation', 'reservationName', reservationName)
            const localVarPath = `/slurm/v0.0.41/reservation/{reservation_name}`
                .replace(`{${"reservation_name"}}`, encodeURIComponent(String(reservationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReservations: async (updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetShares: async (accounts?: string, users?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/shares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (users !== undefined) {
                localVarQueryParameter['users'] = users;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0041JobDescMsg} [v0041JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJob: async (jobId: string, v0041JobDescMsg?: V0041JobDescMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmV0041PostJob', 'jobId', jobId)
            const localVarPath = `/slurm/v0.0.41/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041JobDescMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit new job allocation without any steps that must be signaled to stop
         * @param {V0041JobAllocReq} [v0041JobAllocReq] Job allocation description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJobAllocate: async (v0041JobAllocReq?: V0041JobAllocReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/job/allocate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041JobAllocReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit new job
         * @param {V0041JobSubmitReq} [v0041JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJobSubmit: async (v0041JobSubmitReq?: V0041JobSubmitReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurm/v0.0.41/job/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041JobSubmitReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0041UpdateNodeMsg} [v0041UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostNode: async (nodeName: string, v0041UpdateNodeMsg?: V0041UpdateNodeMsg, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeName' is not null or undefined
            assertParamExists('slurmV0041PostNode', 'nodeName', nodeName)
            const localVarPath = `/slurm/v0.0.41/node/{node_name}`
                .replace(`{${"node_name"}}`, encodeURIComponent(String(nodeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041UpdateNodeMsg, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add clusters
         * @param {Dbv0039ClustersInfo} dbv0039ClustersInfo Add or update clusters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039AddClusters: async (dbv0039ClustersInfo: Dbv0039ClustersInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039ClustersInfo' is not null or undefined
            assertParamExists('slurmdbV0039AddClusters', 'dbv0039ClustersInfo', dbv0039ClustersInfo)
            const localVarPath = `/slurmdb/v0.0.39/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039ClustersInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add wckeys
         * @param {Dbv0039WckeyInfo} [dbv0039WckeyInfo] add wckeys
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039AddWckeys: async (dbv0039WckeyInfo?: Dbv0039WckeyInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/wckeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039WckeyInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Slurm Account Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAccount: async (accountName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0039DeleteAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.39/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAssociation: async (cluster?: string, account?: string, user?: string, partition?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/association`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAssociations: async (cluster?: string, account?: string, user?: string, partition?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/associations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteCluster: async (clusterName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0039DeleteCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.39/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qosName Slurm QOS Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteQos: async (qosName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qosName' is not null or undefined
            assertParamExists('slurmdbV0039DeleteQos', 'qosName', qosName)
            const localVarPath = `/slurmdb/v0.0.39/qos/{qos_name}`
                .replace(`{${"qos_name"}}`, encodeURIComponent(String(qosName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userName Slurm User Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteUser: async (userName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('slurmdbV0039DeleteUser', 'userName', userName)
            const localVarPath = `/slurmdb/v0.0.39/user/{user_name}`
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteWckey: async (wckey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wckey' is not null or undefined
            assertParamExists('slurmdbV0039DeleteWckey', 'wckey', wckey)
            const localVarPath = `/slurmdb/v0.0.39/wckey/{wckey}`
                .replace(`{${"wckey"}}`, encodeURIComponent(String(wckey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039Diag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/diag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Slurm Account Name
         * @param {SlurmdbV0039GetAccountWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAccount: async (accountName: string, withDeleted?: SlurmdbV0039GetAccountWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0039GetAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.39/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account list
         * @param {SlurmdbV0039GetAccountsWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAccounts: async (withDeleted?: SlurmdbV0039GetAccountsWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAssociation: async (cluster?: string, account?: string, user?: string, partition?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/association`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAssociations: async (cluster?: string, account?: string, user?: string, partition?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/associations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetCluster: async (clusterName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0039GetCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.39/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetClusters: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/clusters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmdbV0039GetJob', 'jobId', jobId)
            const localVarPath = `/slurmdb/v0.0.39/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [users] Filter by comma delimited list of user names
         * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [account] Comma delimited list of accounts to match
         * @param {string} [association] Comma delimited list of associations to match
         * @param {string} [cluster] Comma delimited list of cluster to match
         * @param {string} [constraints] Comma delimited list of constraints to match
         * @param {string} [cpusMax] Number of CPUs high range
         * @param {string} [cpusMin] Number of CPUs low range
         * @param {SlurmdbV0039GetJobsSkipStepsEnum} [skipSteps] Report job step information
         * @param {SlurmdbV0039GetJobsDisableWaitForResultEnum} [disableWaitForResult] Disable waiting for result from slurmdbd
         * @param {string} [exitCode] Exit code of job
         * @param {string} [format] Comma delimited list of formats to match
         * @param {string} [group] Comma delimited list of groups to match
         * @param {string} [jobName] Comma delimited list of job names to match
         * @param {string} [nodesMax] Number of nodes high range
         * @param {string} [nodesMin] Number of nodes low range
         * @param {string} [partition] Comma delimited list of partitions to match
         * @param {string} [qos] Comma delimited list of QOS to match
         * @param {string} [reason] Comma delimited list of job reasons to match
         * @param {string} [reservation] Comma delimited list of reservations to match
         * @param {string} [state] Comma delimited list of states to match
         * @param {string} [step] Comma delimited list of job steps to match
         * @param {string} [node] Comma delimited list of used nodes to match
         * @param {string} [wckey] Comma delimited list of wckeys to match
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetJobs: async (users?: string, submitTime?: string, startTime?: string, endTime?: string, account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, skipSteps?: SlurmdbV0039GetJobsSkipStepsEnum, disableWaitForResult?: SlurmdbV0039GetJobsDisableWaitForResultEnum, exitCode?: string, format?: string, group?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, state?: string, step?: string, node?: string, wckey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (users !== undefined) {
                localVarQueryParameter['users'] = users;
            }

            if (submitTime !== undefined) {
                localVarQueryParameter['submit_time'] = submitTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (association !== undefined) {
                localVarQueryParameter['association'] = association;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (constraints !== undefined) {
                localVarQueryParameter['constraints'] = constraints;
            }

            if (cpusMax !== undefined) {
                localVarQueryParameter['cpus_max'] = cpusMax;
            }

            if (cpusMin !== undefined) {
                localVarQueryParameter['cpus_min'] = cpusMin;
            }

            if (skipSteps !== undefined) {
                localVarQueryParameter['skip_steps'] = skipSteps;
            }

            if (disableWaitForResult !== undefined) {
                localVarQueryParameter['disable_wait_for_result'] = disableWaitForResult;
            }

            if (exitCode !== undefined) {
                localVarQueryParameter['exit_code'] = exitCode;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (jobName !== undefined) {
                localVarQueryParameter['job_name'] = jobName;
            }

            if (nodesMax !== undefined) {
                localVarQueryParameter['nodes_max'] = nodesMax;
            }

            if (nodesMin !== undefined) {
                localVarQueryParameter['nodes_min'] = nodesMin;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (reservation !== undefined) {
                localVarQueryParameter['reservation'] = reservation;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (wckey !== undefined) {
                localVarQueryParameter['wckey'] = wckey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS list
         * @param {SlurmdbV0039GetQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetQos: async (withDeleted?: SlurmdbV0039GetQosWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/qos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qosName Slurm QOS Name
         * @param {SlurmdbV0039GetSingleQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetSingleQos: async (qosName: string, withDeleted?: SlurmdbV0039GetSingleQosWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qosName' is not null or undefined
            assertParamExists('slurmdbV0039GetSingleQos', 'qosName', qosName)
            const localVarPath = `/slurmdb/v0.0.39/qos/{qos_name}`
                .replace(`{${"qos_name"}}`, encodeURIComponent(String(qosName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetTres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/tres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {string} userName Slurm User Name
         * @param {SlurmdbV0039GetUserWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetUser: async (userName: string, withDeleted?: SlurmdbV0039GetUserWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('slurmdbV0039GetUser', 'userName', userName)
            const localVarPath = `/slurmdb/v0.0.39/user/{user_name}`
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0039GetUsersWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetUsers: async (withDeleted?: SlurmdbV0039GetUsersWithDeletedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetWckey: async (wckey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wckey' is not null or undefined
            assertParamExists('slurmdbV0039GetWckey', 'wckey', wckey)
            const localVarPath = `/slurmdb/v0.0.39/wckey/{wckey}`
                .replace(`{${"wckey"}}`, encodeURIComponent(String(wckey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetWckeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/wckeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {Dbv0039SetConfig} [dbv0039SetConfig] Add or update config
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039SetConfig: async (dbv0039SetConfig?: Dbv0039SetConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.39/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039SetConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update accounts
         * @param {Dbv0039AccountInfo} dbv0039AccountInfo update/create accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateAccounts: async (dbv0039AccountInfo: Dbv0039AccountInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039AccountInfo' is not null or undefined
            assertParamExists('slurmdbV0039UpdateAccounts', 'dbv0039AccountInfo', dbv0039AccountInfo)
            const localVarPath = `/slurmdb/v0.0.39/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039AccountInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set associations info
         * @param {Dbv0039AssociationsInfo} dbv0039AssociationsInfo Add or update associations
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateAssociations: async (dbv0039AssociationsInfo: Dbv0039AssociationsInfo, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039AssociationsInfo' is not null or undefined
            assertParamExists('slurmdbV0039UpdateAssociations', 'dbv0039AssociationsInfo', dbv0039AssociationsInfo)
            const localVarPath = `/slurmdb/v0.0.39/associations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039AssociationsInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set QOS info
         * @param {Dbv0039UpdateQos} dbv0039UpdateQos Add or update QOSs
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateQos: async (dbv0039UpdateQos: Dbv0039UpdateQos, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039UpdateQos' is not null or undefined
            assertParamExists('slurmdbV0039UpdateQos', 'dbv0039UpdateQos', dbv0039UpdateQos)
            const localVarPath = `/slurmdb/v0.0.39/qos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039UpdateQos, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set TRES info
         * @param {Dbv0039TresUpdate} dbv0039TresUpdate Add or Update TRES
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateTres: async (dbv0039TresUpdate: Dbv0039TresUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039TresUpdate' is not null or undefined
            assertParamExists('slurmdbV0039UpdateTres', 'dbv0039TresUpdate', dbv0039TresUpdate)
            const localVarPath = `/slurmdb/v0.0.39/tres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039TresUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {Dbv0039UpdateUsers} dbv0039UpdateUsers add or update user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateUsers: async (dbv0039UpdateUsers: Dbv0039UpdateUsers, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbv0039UpdateUsers' is not null or undefined
            assertParamExists('slurmdbV0039UpdateUsers', 'dbv0039UpdateUsers', dbv0039UpdateUsers)
            const localVarPath = `/slurmdb/v0.0.39/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbv0039UpdateUsers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlurmApi - functional programming interface
 * @export
 */
export const SlurmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlurmApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Slurm Job ID
         * @param {SlurmV0039CancelJobSignalEnum} [signal] signal to send to job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039CancelJob(jobId: string, signal?: SlurmV0039CancelJobSignalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039CancelJob(jobId, signal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039CancelJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039DeleteNode(nodeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039DeleteNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039Diag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039Diag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039Diag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039Diag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039JobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get list of jobs
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetJobs(updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039JobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetJobs(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetNode(nodeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetNode(nodeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all node info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetNodes(updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039NodesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetNodes(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Slurm Partition Name
         * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetPartition(partitionName: string, updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039PartitionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetPartition(partitionName, updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetPartition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all partition info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetPartitions(updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039PartitionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetPartitions(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetPartitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Slurm Reservation Name
         * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetReservation(reservationName: string, updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039ReservationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetReservation(reservationName, updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all reservation info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039GetReservations(updateTime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039ReservationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039GetReservations(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039GetReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039Ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039Pings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039Ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039Ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039SlurmctldGetLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039LicensesInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039SlurmctldGetLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039SlurmctldGetLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary submit new job
         * @param {V0039JobSubmission} v0039JobSubmission submit new job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039SubmitJob(v0039JobSubmission: V0039JobSubmission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039JobSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039SubmitJob(v0039JobSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039SubmitJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Slurm Job ID
         * @param {V0039JobDescMsg} v0039JobDescMsg update job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039UpdateJob(jobId: string, v0039JobDescMsg: V0039JobDescMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0039JobUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039UpdateJob(jobId, v0039JobDescMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039UpdateJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Slurm Node Name
         * @param {V0039UpdateNodeMsg} v0039UpdateNodeMsg update node
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmV0039UpdateNode(nodeName: string, v0039UpdateNodeMsg: V0039UpdateNodeMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0039UpdateNode(nodeName, v0039UpdateNodeMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0039UpdateNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0040DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040DeleteJob(jobId: string, signal?: string, flags?: SlurmV0040DeleteJobFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040DeleteJob(jobId, signal, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040DeleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0040KillJobsMsg} [v0040KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040DeleteJobs(v0040KillJobsMsg?: V0040KillJobsMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiKillJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040DeleteJobs(v0040KillJobsMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040DeleteJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040DeleteNode(nodeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040DeleteNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetDiag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiDiagResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetDiag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetDiag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetJob(jobId: string, updateTime?: string, flags?: SlurmV0040GetJobFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetJob(jobId, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetJobs(updateTime?: string, flags?: SlurmV0040GetJobsFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetJobs(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetJobsState(updateTime?: string, flags?: SlurmV0040GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetJobsState(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetJobsState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiLicensesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0040GetNodeFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiNodesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetNode(nodeName, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetNodes(updateTime?: string, flags?: SlurmV0040GetNodesFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiNodesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetNodes(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0040GetPartitionFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiPartitionResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetPartition(partitionName, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetPartition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetPartitions(updateTime?: string, flags?: SlurmV0040GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiPartitionResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetPartitions(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetPartitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetPing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiPingArrayResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetPing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetReconfigure(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetReconfigure(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetReconfigure']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiReservationResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetReservation(reservationName, updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetReservations(updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiReservationResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetReservations(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSharesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040GetShares(accounts, users, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040GetShares']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0040JobDescMsg} [v0040JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040PostJob(jobId: string, v0040JobDescMsg?: V0040JobDescMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiJobPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040PostJob(jobId, v0040JobDescMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040PostJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary submit new job
         * @param {V0040JobSubmitReq} [v0040JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040PostJobSubmit(v0040JobSubmitReq?: V0040JobSubmitReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiJobSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040PostJobSubmit(v0040JobSubmitReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040PostJobSubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0040UpdateNodeMsg} [v0040UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0040PostNode(nodeName: string, v0040UpdateNodeMsg?: V0040UpdateNodeMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0040PostNode(nodeName, v0040UpdateNodeMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0040PostNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0041DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041DeleteJob(jobId: string, signal?: string, flags?: SlurmV0041DeleteJobFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041DeleteJob(jobId, signal, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041DeleteJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0041KillJobsMsg} [v0041KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041DeleteJobs(v0041KillJobsMsg?: V0041KillJobsMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiKillJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041DeleteJobs(v0041KillJobsMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041DeleteJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041DeleteNode(nodeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041DeleteNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetDiag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiDiagResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetDiag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetDiag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetJob(jobId: string, updateTime?: string, flags?: SlurmV0041GetJobFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetJob(jobId, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetJobs(updateTime?: string, flags?: SlurmV0041GetJobsFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetJobs(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetJobsState(updateTime?: string, flags?: SlurmV0041GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobInfoResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetJobsState(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetJobsState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiLicensesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0041GetNodeFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiNodesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetNode(nodeName, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetNodes(updateTime?: string, flags?: SlurmV0041GetNodesFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiNodesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetNodes(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0041GetPartitionFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiPartitionResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetPartition(partitionName, updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetPartition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetPartitions(updateTime?: string, flags?: SlurmV0041GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiPartitionResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetPartitions(updateTime, flags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetPartitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetPing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiPingArrayResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetPing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetReconfigure(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetReconfigure(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetReconfigure']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiReservationResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetReservation(reservationName, updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetReservation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetReservations(updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiReservationResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetReservations(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetReservations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSharesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041GetShares(accounts, users, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041GetShares']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0041JobDescMsg} [v0041JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041PostJob(jobId: string, v0041JobDescMsg?: V0041JobDescMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041PostJob(jobId, v0041JobDescMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041PostJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary submit new job allocation without any steps that must be signaled to stop
         * @param {V0041JobAllocReq} [v0041JobAllocReq] Job allocation description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041PostJobAllocate(v0041JobAllocReq?: V0041JobAllocReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobAllocResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041PostJobAllocate(v0041JobAllocReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041PostJobAllocate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary submit new job
         * @param {V0041JobSubmitReq} [v0041JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041PostJobSubmit(v0041JobSubmitReq?: V0041JobSubmitReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiJobSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041PostJobSubmit(v0041JobSubmitReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041PostJobSubmit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0041UpdateNodeMsg} [v0041UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmV0041PostNode(nodeName: string, v0041UpdateNodeMsg?: V0041UpdateNodeMsg, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmV0041PostNode(nodeName, v0041UpdateNodeMsg, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmV0041PostNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add clusters
         * @param {Dbv0039ClustersInfo} dbv0039ClustersInfo Add or update clusters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039AddClusters(dbv0039ClustersInfo: Dbv0039ClustersInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039AddClusters(dbv0039ClustersInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039AddClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add wckeys
         * @param {Dbv0039WckeyInfo} [dbv0039WckeyInfo] add wckeys
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039AddWckeys(dbv0039WckeyInfo?: Dbv0039WckeyInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039AddWckeys(dbv0039WckeyInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039AddWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Slurm Account Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteAccount(accountName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039ResponseAssociationsDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteAssociation(cluster, account, user, partition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039ResponseAssociationsDelete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteAssociations(cluster, account, user, partition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteCluster(clusterName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteCluster(clusterName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qosName Slurm QOS Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteQos(qosName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteQos(qosName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userName Slurm User Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteUser(userName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteUser(userName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039DeleteWckey(wckey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039DeleteWckey(wckey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039DeleteWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039Diag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039Diag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039Diag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039Diag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Slurm Account Name
         * @param {SlurmdbV0039GetAccountWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetAccount(accountName: string, withDeleted?: SlurmdbV0039GetAccountWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetAccount(accountName, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account list
         * @param {SlurmdbV0039GetAccountsWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetAccounts(withDeleted?: SlurmdbV0039GetAccountsWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetAccounts(withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039AssociationsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetAssociation(cluster, account, user, partition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039AssociationsInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetAssociations(cluster, account, user, partition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetCluster(clusterName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039ClustersInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetCluster(clusterName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetClusters(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039ClustersInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetClusters(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039ConfigInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039JobInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [users] Filter by comma delimited list of user names
         * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [account] Comma delimited list of accounts to match
         * @param {string} [association] Comma delimited list of associations to match
         * @param {string} [cluster] Comma delimited list of cluster to match
         * @param {string} [constraints] Comma delimited list of constraints to match
         * @param {string} [cpusMax] Number of CPUs high range
         * @param {string} [cpusMin] Number of CPUs low range
         * @param {SlurmdbV0039GetJobsSkipStepsEnum} [skipSteps] Report job step information
         * @param {SlurmdbV0039GetJobsDisableWaitForResultEnum} [disableWaitForResult] Disable waiting for result from slurmdbd
         * @param {string} [exitCode] Exit code of job
         * @param {string} [format] Comma delimited list of formats to match
         * @param {string} [group] Comma delimited list of groups to match
         * @param {string} [jobName] Comma delimited list of job names to match
         * @param {string} [nodesMax] Number of nodes high range
         * @param {string} [nodesMin] Number of nodes low range
         * @param {string} [partition] Comma delimited list of partitions to match
         * @param {string} [qos] Comma delimited list of QOS to match
         * @param {string} [reason] Comma delimited list of job reasons to match
         * @param {string} [reservation] Comma delimited list of reservations to match
         * @param {string} [state] Comma delimited list of states to match
         * @param {string} [step] Comma delimited list of job steps to match
         * @param {string} [node] Comma delimited list of used nodes to match
         * @param {string} [wckey] Comma delimited list of wckeys to match
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetJobs(users?: string, submitTime?: string, startTime?: string, endTime?: string, account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, skipSteps?: SlurmdbV0039GetJobsSkipStepsEnum, disableWaitForResult?: SlurmdbV0039GetJobsDisableWaitForResultEnum, exitCode?: string, format?: string, group?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, state?: string, step?: string, node?: string, wckey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039JobInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetJobs(users, submitTime, startTime, endTime, account, association, cluster, constraints, cpusMax, cpusMin, skipSteps, disableWaitForResult, exitCode, format, group, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, state, step, node, wckey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS list
         * @param {SlurmdbV0039GetQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetQos(withDeleted?: SlurmdbV0039GetQosWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039QosInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetQos(withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qosName Slurm QOS Name
         * @param {SlurmdbV0039GetSingleQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetSingleQos(qosName: string, withDeleted?: SlurmdbV0039GetSingleQosWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039QosInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetSingleQos(qosName, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetSingleQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetTres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039TresInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetTres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user info
         * @param {string} userName Slurm User Name
         * @param {SlurmdbV0039GetUserWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetUser(userName: string, withDeleted?: SlurmdbV0039GetUserWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetUser(userName, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0039GetUsersWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetUsers(withDeleted?: SlurmdbV0039GetUsersWithDeletedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetUsers(withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetWckey(wckey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039WckeyInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetWckey(wckey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039GetWckeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dbv0039WckeyInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039GetWckeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039GetWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {Dbv0039SetConfig} [dbv0039SetConfig] Add or update config
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039SetConfig(dbv0039SetConfig?: Dbv0039SetConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039SetConfig(dbv0039SetConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039SetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update accounts
         * @param {Dbv0039AccountInfo} dbv0039AccountInfo update/create accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039UpdateAccounts(dbv0039AccountInfo: Dbv0039AccountInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039UpdateAccounts(dbv0039AccountInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039UpdateAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set associations info
         * @param {Dbv0039AssociationsInfo} dbv0039AssociationsInfo Add or update associations
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo: Dbv0039AssociationsInfo, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039UpdateAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set QOS info
         * @param {Dbv0039UpdateQos} dbv0039UpdateQos Add or update QOSs
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039UpdateQos(dbv0039UpdateQos: Dbv0039UpdateQos, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039UpdateQos(dbv0039UpdateQos, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039UpdateQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set TRES info
         * @param {Dbv0039TresUpdate} dbv0039TresUpdate Add or Update TRES
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039UpdateTres(dbv0039TresUpdate: Dbv0039TresUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039UpdateTres(dbv0039TresUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039UpdateTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update user
         * @param {Dbv0039UpdateUsers} dbv0039UpdateUsers add or update user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slurmdbV0039UpdateUsers(dbv0039UpdateUsers: Dbv0039UpdateUsers, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0039UpdateUsers(dbv0039UpdateUsers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmApi.slurmdbV0039UpdateUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SlurmApi - factory interface
 * @export
 */
export const SlurmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlurmApiFp(configuration)
    return {
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Slurm Job ID
         * @param {SlurmV0039CancelJobSignalEnum} [signal] signal to send to job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039CancelJob(jobId: string, signal?: SlurmV0039CancelJobSignalEnum, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmV0039CancelJob(jobId, signal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmV0039DeleteNode(nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039Diag(options?: RawAxiosRequestConfig): AxiosPromise<V0039Diag> {
            return localVarFp.slurmV0039Diag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<V0039JobsResponse> {
            return localVarFp.slurmV0039GetJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get list of jobs
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetJobs(updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039JobsResponse> {
            return localVarFp.slurmV0039GetJobs(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Slurm Node Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetNode(nodeName: string, options?: RawAxiosRequestConfig): AxiosPromise<V0039NodesResponse> {
            return localVarFp.slurmV0039GetNode(nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all node info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetNodes(updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039NodesResponse> {
            return localVarFp.slurmV0039GetNodes(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Slurm Partition Name
         * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetPartition(partitionName: string, updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039PartitionsResponse> {
            return localVarFp.slurmV0039GetPartition(partitionName, updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all partition info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetPartitions(updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039PartitionsResponse> {
            return localVarFp.slurmV0039GetPartitions(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Slurm Reservation Name
         * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetReservation(reservationName: string, updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039ReservationsResponse> {
            return localVarFp.slurmV0039GetReservation(reservationName, updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all reservation info
         * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039GetReservations(updateTime?: number, options?: RawAxiosRequestConfig): AxiosPromise<V0039ReservationsResponse> {
            return localVarFp.slurmV0039GetReservations(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039Ping(options?: RawAxiosRequestConfig): AxiosPromise<V0039Pings> {
            return localVarFp.slurmV0039Ping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039SlurmctldGetLicenses(options?: RawAxiosRequestConfig): AxiosPromise<V0039LicensesInfo> {
            return localVarFp.slurmV0039SlurmctldGetLicenses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit new job
         * @param {V0039JobSubmission} v0039JobSubmission submit new job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039SubmitJob(v0039JobSubmission: V0039JobSubmission, options?: RawAxiosRequestConfig): AxiosPromise<V0039JobSubmissionResponse> {
            return localVarFp.slurmV0039SubmitJob(v0039JobSubmission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Slurm Job ID
         * @param {V0039JobDescMsg} v0039JobDescMsg update job
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039UpdateJob(jobId: string, v0039JobDescMsg: V0039JobDescMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0039JobUpdateResponse> {
            return localVarFp.slurmV0039UpdateJob(jobId, v0039JobDescMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Slurm Node Name
         * @param {V0039UpdateNodeMsg} v0039UpdateNodeMsg update node
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmV0039UpdateNode(nodeName: string, v0039UpdateNodeMsg: V0039UpdateNodeMsg, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmV0039UpdateNode(nodeName, v0039UpdateNodeMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0040DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteJob(jobId: string, signal?: string, flags?: SlurmV0040DeleteJobFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmV0040DeleteJob(jobId, signal, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0040KillJobsMsg} [v0040KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteJobs(v0040KillJobsMsg?: V0040KillJobsMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiKillJobsResp> {
            return localVarFp.slurmV0040DeleteJobs(v0040KillJobsMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmV0040DeleteNode(nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetDiag(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiDiagResp> {
            return localVarFp.slurmV0040GetDiag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJob(jobId: string, updateTime?: string, flags?: SlurmV0040GetJobFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiJobInfoResp> {
            return localVarFp.slurmV0040GetJob(jobId, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJobs(updateTime?: string, flags?: SlurmV0040GetJobsFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiJobInfoResp> {
            return localVarFp.slurmV0040GetJobs(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetJobsState(updateTime?: string, flags?: SlurmV0040GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiJobInfoResp> {
            return localVarFp.slurmV0040GetJobsState(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetLicenses(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiLicensesResp> {
            return localVarFp.slurmV0040GetLicenses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0040GetNodeFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiNodesResp> {
            return localVarFp.slurmV0040GetNode(nodeName, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0040GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetNodes(updateTime?: string, flags?: SlurmV0040GetNodesFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiNodesResp> {
            return localVarFp.slurmV0040GetNodes(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0040GetPartitionFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiPartitionResp> {
            return localVarFp.slurmV0040GetPartition(partitionName, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0040GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPartitions(updateTime?: string, flags?: SlurmV0040GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiPartitionResp> {
            return localVarFp.slurmV0040GetPartitions(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetPing(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiPingArrayResp> {
            return localVarFp.slurmV0040GetPing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReconfigure(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmV0040GetReconfigure(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiReservationResp> {
            return localVarFp.slurmV0040GetReservation(reservationName, updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetReservations(updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiReservationResp> {
            return localVarFp.slurmV0040GetReservations(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSharesResp> {
            return localVarFp.slurmV0040GetShares(accounts, users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0040JobDescMsg} [v0040JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostJob(jobId: string, v0040JobDescMsg?: V0040JobDescMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiJobPostResponse> {
            return localVarFp.slurmV0040PostJob(jobId, v0040JobDescMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit new job
         * @param {V0040JobSubmitReq} [v0040JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostJobSubmit(v0040JobSubmitReq?: V0040JobSubmitReq, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiJobSubmitResponse> {
            return localVarFp.slurmV0040PostJobSubmit(v0040JobSubmitReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0040UpdateNodeMsg} [v0040UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0040PostNode(nodeName: string, v0040UpdateNodeMsg?: V0040UpdateNodeMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmV0040PostNode(nodeName, v0040UpdateNodeMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel or signal job
         * @param {string} jobId Job ID
         * @param {string} [signal] Signal to send to Job
         * @param {SlurmV0041DeleteJobFlagsEnum} [flags] Signalling flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteJob(jobId: string, signal?: string, flags?: SlurmV0041DeleteJobFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmV0041DeleteJob(jobId, signal, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send signal to list of jobs
         * @param {V0041KillJobsMsg} [v0041KillJobsMsg] Signal or cancel jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteJobs(v0041KillJobsMsg?: V0041KillJobsMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiKillJobsResp> {
            return localVarFp.slurmV0041DeleteJobs(v0041KillJobsMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete node
         * @param {string} nodeName Node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041DeleteNode(nodeName: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmV0041DeleteNode(nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetDiag(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiDiagResp> {
            return localVarFp.slurmV0041GetDiag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get job info
         * @param {string} jobId Job ID
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJob(jobId: string, updateTime?: string, flags?: SlurmV0041GetJobFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobInfoResp> {
            return localVarFp.slurmV0041GetJob(jobId, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get list of jobs
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJobs(updateTime?: string, flags?: SlurmV0041GetJobsFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobInfoResp> {
            return localVarFp.slurmV0041GetJobs(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get list of job states
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetJobsStateFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetJobsState(updateTime?: string, flags?: SlurmV0041GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobInfoResp> {
            return localVarFp.slurmV0041GetJobsState(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all Slurm tracked license info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetLicenses(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiLicensesResp> {
            return localVarFp.slurmV0041GetLicenses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get node info
         * @param {string} nodeName Node name
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodeFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0041GetNodeFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiNodesResp> {
            return localVarFp.slurmV0041GetNode(nodeName, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get node(s) info
         * @param {string} [updateTime] Filter jobs since update timestamp
         * @param {SlurmV0041GetNodesFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetNodes(updateTime?: string, flags?: SlurmV0041GetNodesFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiNodesResp> {
            return localVarFp.slurmV0041GetNodes(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get partition info
         * @param {string} partitionName Partition name
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0041GetPartitionFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiPartitionResp> {
            return localVarFp.slurmV0041GetPartition(partitionName, updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all partition info
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmV0041GetPartitionsFlagsEnum} [flags] Query flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPartitions(updateTime?: string, flags?: SlurmV0041GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiPartitionResp> {
            return localVarFp.slurmV0041GetPartitions(updateTime, flags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ping test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetPing(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiPingArrayResp> {
            return localVarFp.slurmV0041GetPing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary request slurmctld reconfigure
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReconfigure(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmV0041GetReconfigure(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get reservation info
         * @param {string} reservationName Reservation name
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiReservationResp> {
            return localVarFp.slurmV0041GetReservation(reservationName, updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all reservation info
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetReservations(updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiReservationResp> {
            return localVarFp.slurmV0041GetReservations(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get fairshare info
         * @param {string} [accounts] Accounts to query
         * @param {string} [users] Users to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSharesResp> {
            return localVarFp.slurmV0041GetShares(accounts, users, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update job
         * @param {string} jobId Job ID
         * @param {V0041JobDescMsg} [v0041JobDescMsg] Job update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJob(jobId: string, v0041JobDescMsg?: V0041JobDescMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobPostResponse> {
            return localVarFp.slurmV0041PostJob(jobId, v0041JobDescMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit new job allocation without any steps that must be signaled to stop
         * @param {V0041JobAllocReq} [v0041JobAllocReq] Job allocation description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJobAllocate(v0041JobAllocReq?: V0041JobAllocReq, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobAllocResp> {
            return localVarFp.slurmV0041PostJobAllocate(v0041JobAllocReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit new job
         * @param {V0041JobSubmitReq} [v0041JobSubmitReq] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostJobSubmit(v0041JobSubmitReq?: V0041JobSubmitReq, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiJobSubmitResponse> {
            return localVarFp.slurmV0041PostJobSubmit(v0041JobSubmitReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update node properties
         * @param {string} nodeName Node name
         * @param {V0041UpdateNodeMsg} [v0041UpdateNodeMsg] Node update description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmV0041PostNode(nodeName: string, v0041UpdateNodeMsg?: V0041UpdateNodeMsg, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmV0041PostNode(nodeName, v0041UpdateNodeMsg, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add clusters
         * @param {Dbv0039ClustersInfo} dbv0039ClustersInfo Add or update clusters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039AddClusters(dbv0039ClustersInfo: Dbv0039ClustersInfo, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039AddClusters(dbv0039ClustersInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add wckeys
         * @param {Dbv0039WckeyInfo} [dbv0039WckeyInfo] add wckeys
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039AddWckeys(dbv0039WckeyInfo?: Dbv0039WckeyInfo, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039AddWckeys(dbv0039WckeyInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Slurm Account Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039DeleteAccount(accountName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039ResponseAssociationsDelete> {
            return localVarFp.slurmdbV0039DeleteAssociation(cluster, account, user, partition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039ResponseAssociationsDelete> {
            return localVarFp.slurmdbV0039DeleteAssociations(cluster, account, user, partition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteCluster(clusterName: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039DeleteCluster(clusterName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qosName Slurm QOS Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteQos(qosName: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039DeleteQos(qosName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} userName Slurm User Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteUser(userName: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039DeleteUser(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039DeleteWckey(wckey: string, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039DeleteWckey(wckey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039Diag(options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039Diag> {
            return localVarFp.slurmdbV0039Diag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Slurm Account Name
         * @param {SlurmdbV0039GetAccountWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAccount(accountName: string, withDeleted?: SlurmdbV0039GetAccountWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039AccountInfo> {
            return localVarFp.slurmdbV0039GetAccount(accountName, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account list
         * @param {SlurmdbV0039GetAccountsWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAccounts(withDeleted?: SlurmdbV0039GetAccountsWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039AccountInfo> {
            return localVarFp.slurmdbV0039GetAccounts(withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039AssociationsInfo> {
            return localVarFp.slurmdbV0039GetAssociation(cluster, account, user, partition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [cluster] Cluster name
         * @param {string} [account] Account name
         * @param {string} [user] User name
         * @param {string} [partition] Partition Name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039AssociationsInfo> {
            return localVarFp.slurmdbV0039GetAssociations(cluster, account, user, partition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Slurm cluster name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetCluster(clusterName: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039ClustersInfo> {
            return localVarFp.slurmdbV0039GetCluster(clusterName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetClusters(options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039ClustersInfo> {
            return localVarFp.slurmdbV0039GetClusters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetConfig(options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039ConfigInfo> {
            return localVarFp.slurmdbV0039GetConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Slurm JobID
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039JobInfo> {
            return localVarFp.slurmdbV0039GetJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [users] Filter by comma delimited list of user names
         * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
         * @param {string} [account] Comma delimited list of accounts to match
         * @param {string} [association] Comma delimited list of associations to match
         * @param {string} [cluster] Comma delimited list of cluster to match
         * @param {string} [constraints] Comma delimited list of constraints to match
         * @param {string} [cpusMax] Number of CPUs high range
         * @param {string} [cpusMin] Number of CPUs low range
         * @param {SlurmdbV0039GetJobsSkipStepsEnum} [skipSteps] Report job step information
         * @param {SlurmdbV0039GetJobsDisableWaitForResultEnum} [disableWaitForResult] Disable waiting for result from slurmdbd
         * @param {string} [exitCode] Exit code of job
         * @param {string} [format] Comma delimited list of formats to match
         * @param {string} [group] Comma delimited list of groups to match
         * @param {string} [jobName] Comma delimited list of job names to match
         * @param {string} [nodesMax] Number of nodes high range
         * @param {string} [nodesMin] Number of nodes low range
         * @param {string} [partition] Comma delimited list of partitions to match
         * @param {string} [qos] Comma delimited list of QOS to match
         * @param {string} [reason] Comma delimited list of job reasons to match
         * @param {string} [reservation] Comma delimited list of reservations to match
         * @param {string} [state] Comma delimited list of states to match
         * @param {string} [step] Comma delimited list of job steps to match
         * @param {string} [node] Comma delimited list of used nodes to match
         * @param {string} [wckey] Comma delimited list of wckeys to match
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetJobs(users?: string, submitTime?: string, startTime?: string, endTime?: string, account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, skipSteps?: SlurmdbV0039GetJobsSkipStepsEnum, disableWaitForResult?: SlurmdbV0039GetJobsDisableWaitForResultEnum, exitCode?: string, format?: string, group?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, state?: string, step?: string, node?: string, wckey?: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039JobInfo> {
            return localVarFp.slurmdbV0039GetJobs(users, submitTime, startTime, endTime, account, association, cluster, constraints, cpusMax, cpusMin, skipSteps, disableWaitForResult, exitCode, format, group, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, state, step, node, wckey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS list
         * @param {SlurmdbV0039GetQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetQos(withDeleted?: SlurmdbV0039GetQosWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039QosInfo> {
            return localVarFp.slurmdbV0039GetQos(withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qosName Slurm QOS Name
         * @param {SlurmdbV0039GetSingleQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetSingleQos(qosName: string, withDeleted?: SlurmdbV0039GetSingleQosWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039QosInfo> {
            return localVarFp.slurmdbV0039GetSingleQos(qosName, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetTres(options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039TresInfo> {
            return localVarFp.slurmdbV0039GetTres(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {string} userName Slurm User Name
         * @param {SlurmdbV0039GetUserWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetUser(userName: string, withDeleted?: SlurmdbV0039GetUserWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039UserInfo> {
            return localVarFp.slurmdbV0039GetUser(userName, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0039GetUsersWithDeletedEnum} [withDeleted] Include deleted users. False by default.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetUsers(withDeleted?: SlurmdbV0039GetUsersWithDeletedEnum, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039UserInfo> {
            return localVarFp.slurmdbV0039GetUsers(withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} wckey Slurm wckey name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetWckey(wckey: string, options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039WckeyInfo> {
            return localVarFp.slurmdbV0039GetWckey(wckey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey list
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039GetWckeys(options?: RawAxiosRequestConfig): AxiosPromise<Dbv0039WckeyInfo> {
            return localVarFp.slurmdbV0039GetWckeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {Dbv0039SetConfig} [dbv0039SetConfig] Add or update config
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039SetConfig(dbv0039SetConfig?: Dbv0039SetConfig, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039SetConfig(dbv0039SetConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update accounts
         * @param {Dbv0039AccountInfo} dbv0039AccountInfo update/create accounts
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateAccounts(dbv0039AccountInfo: Dbv0039AccountInfo, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039UpdateAccounts(dbv0039AccountInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set associations info
         * @param {Dbv0039AssociationsInfo} dbv0039AssociationsInfo Add or update associations
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo: Dbv0039AssociationsInfo, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set QOS info
         * @param {Dbv0039UpdateQos} dbv0039UpdateQos Add or update QOSs
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateQos(dbv0039UpdateQos: Dbv0039UpdateQos, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039UpdateQos(dbv0039UpdateQos, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set TRES info
         * @param {Dbv0039TresUpdate} dbv0039TresUpdate Add or Update TRES
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateTres(dbv0039TresUpdate: Dbv0039TresUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039UpdateTres(dbv0039TresUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {Dbv0039UpdateUsers} dbv0039UpdateUsers add or update user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slurmdbV0039UpdateUsers(dbv0039UpdateUsers: Dbv0039UpdateUsers, options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.slurmdbV0039UpdateUsers(dbv0039UpdateUsers, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlurmApi - object-oriented interface
 * @export
 * @class SlurmApi
 * @extends {BaseAPI}
 */
export class SlurmApi extends BaseAPI {
    /**
     * 
     * @summary cancel or signal job
     * @param {string} jobId Slurm Job ID
     * @param {SlurmV0039CancelJobSignalEnum} [signal] signal to send to job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039CancelJob(jobId: string, signal?: SlurmV0039CancelJobSignalEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039CancelJob(jobId, signal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete node
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039DeleteNode(nodeName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039DeleteNode(nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039Diag(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039Diag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get job info
     * @param {string} jobId Slurm JobID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetJob(jobId: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get list of jobs
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetJobs(updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetJobs(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get node info
     * @param {string} nodeName Slurm Node Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetNode(nodeName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetNode(nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all node info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetNodes(updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetNodes(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get partition info
     * @param {string} partitionName Slurm Partition Name
     * @param {number} [updateTime] Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetPartition(partitionName: string, updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetPartition(partitionName, updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all partition info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetPartitions(updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetPartitions(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get reservation info
     * @param {string} reservationName Slurm Reservation Name
     * @param {number} [updateTime] Filter if no reservation (not limited to reservation in URL) changed since update_time.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetReservation(reservationName: string, updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetReservation(reservationName, updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all reservation info
     * @param {number} [updateTime] Filter if changed since update_time. Use of this parameter can result in faster replies.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039GetReservations(updateTime?: number, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039GetReservations(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039Ping(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039Ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all Slurm tracked license info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039SlurmctldGetLicenses(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039SlurmctldGetLicenses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit new job
     * @param {V0039JobSubmission} v0039JobSubmission submit new job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039SubmitJob(v0039JobSubmission: V0039JobSubmission, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039SubmitJob(v0039JobSubmission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update job
     * @param {string} jobId Slurm Job ID
     * @param {V0039JobDescMsg} v0039JobDescMsg update job
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039UpdateJob(jobId: string, v0039JobDescMsg: V0039JobDescMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039UpdateJob(jobId, v0039JobDescMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update node properties
     * @param {string} nodeName Slurm Node Name
     * @param {V0039UpdateNodeMsg} v0039UpdateNodeMsg update node
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0039UpdateNode(nodeName: string, v0039UpdateNodeMsg: V0039UpdateNodeMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0039UpdateNode(nodeName, v0039UpdateNodeMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel or signal job
     * @param {string} jobId Job ID
     * @param {string} [signal] Signal to send to Job
     * @param {SlurmV0040DeleteJobFlagsEnum} [flags] Signalling flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040DeleteJob(jobId: string, signal?: string, flags?: SlurmV0040DeleteJobFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040DeleteJob(jobId, signal, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send signal to list of jobs
     * @param {V0040KillJobsMsg} [v0040KillJobsMsg] Signal or cancel jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040DeleteJobs(v0040KillJobsMsg?: V0040KillJobsMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040DeleteJobs(v0040KillJobsMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete node
     * @param {string} nodeName Node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040DeleteNode(nodeName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040DeleteNode(nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetDiag(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetDiag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get job info
     * @param {string} jobId Job ID
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0040GetJobFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetJob(jobId: string, updateTime?: string, flags?: SlurmV0040GetJobFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetJob(jobId, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get list of jobs
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0040GetJobsFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetJobs(updateTime?: string, flags?: SlurmV0040GetJobsFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetJobs(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get list of job states
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0040GetJobsStateFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetJobsState(updateTime?: string, flags?: SlurmV0040GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetJobsState(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all Slurm tracked license info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetLicenses(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetLicenses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get node info
     * @param {string} nodeName Node name
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0040GetNodeFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0040GetNodeFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetNode(nodeName, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get node(s) info
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0040GetNodesFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetNodes(updateTime?: string, flags?: SlurmV0040GetNodesFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetNodes(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get partition info
     * @param {string} partitionName Partition name
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmV0040GetPartitionFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0040GetPartitionFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetPartition(partitionName, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all partition info
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmV0040GetPartitionsFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetPartitions(updateTime?: string, flags?: SlurmV0040GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetPartitions(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetPing(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetPing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary request slurmctld reconfigure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetReconfigure(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetReconfigure(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get reservation info
     * @param {string} reservationName Reservation name
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetReservation(reservationName, updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all reservation info
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetReservations(updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetReservations(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get fairshare info
     * @param {string} [accounts] Accounts to query
     * @param {string} [users] Users to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040GetShares(accounts, users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update job
     * @param {string} jobId Job ID
     * @param {V0040JobDescMsg} [v0040JobDescMsg] Job update description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040PostJob(jobId: string, v0040JobDescMsg?: V0040JobDescMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040PostJob(jobId, v0040JobDescMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit new job
     * @param {V0040JobSubmitReq} [v0040JobSubmitReq] Job description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040PostJobSubmit(v0040JobSubmitReq?: V0040JobSubmitReq, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040PostJobSubmit(v0040JobSubmitReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update node properties
     * @param {string} nodeName Node name
     * @param {V0040UpdateNodeMsg} [v0040UpdateNodeMsg] Node update description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0040PostNode(nodeName: string, v0040UpdateNodeMsg?: V0040UpdateNodeMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0040PostNode(nodeName, v0040UpdateNodeMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel or signal job
     * @param {string} jobId Job ID
     * @param {string} [signal] Signal to send to Job
     * @param {SlurmV0041DeleteJobFlagsEnum} [flags] Signalling flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041DeleteJob(jobId: string, signal?: string, flags?: SlurmV0041DeleteJobFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041DeleteJob(jobId, signal, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send signal to list of jobs
     * @param {V0041KillJobsMsg} [v0041KillJobsMsg] Signal or cancel jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041DeleteJobs(v0041KillJobsMsg?: V0041KillJobsMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041DeleteJobs(v0041KillJobsMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete node
     * @param {string} nodeName Node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041DeleteNode(nodeName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041DeleteNode(nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetDiag(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetDiag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get job info
     * @param {string} jobId Job ID
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0041GetJobFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetJob(jobId: string, updateTime?: string, flags?: SlurmV0041GetJobFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetJob(jobId, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get list of jobs
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0041GetJobsFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetJobs(updateTime?: string, flags?: SlurmV0041GetJobsFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetJobs(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get list of job states
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0041GetJobsStateFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetJobsState(updateTime?: string, flags?: SlurmV0041GetJobsStateFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetJobsState(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all Slurm tracked license info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetLicenses(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetLicenses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get node info
     * @param {string} nodeName Node name
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0041GetNodeFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetNode(nodeName: string, updateTime?: string, flags?: SlurmV0041GetNodeFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetNode(nodeName, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get node(s) info
     * @param {string} [updateTime] Filter jobs since update timestamp
     * @param {SlurmV0041GetNodesFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetNodes(updateTime?: string, flags?: SlurmV0041GetNodesFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetNodes(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get partition info
     * @param {string} partitionName Partition name
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmV0041GetPartitionFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetPartition(partitionName: string, updateTime?: string, flags?: SlurmV0041GetPartitionFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetPartition(partitionName, updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all partition info
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmV0041GetPartitionsFlagsEnum} [flags] Query flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetPartitions(updateTime?: string, flags?: SlurmV0041GetPartitionsFlagsEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetPartitions(updateTime, flags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ping test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetPing(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetPing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary request slurmctld reconfigure
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetReconfigure(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetReconfigure(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get reservation info
     * @param {string} reservationName Reservation name
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetReservation(reservationName: string, updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetReservation(reservationName, updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all reservation info
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetReservations(updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetReservations(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get fairshare info
     * @param {string} [accounts] Accounts to query
     * @param {string} [users] Users to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041GetShares(accounts?: string, users?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041GetShares(accounts, users, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update job
     * @param {string} jobId Job ID
     * @param {V0041JobDescMsg} [v0041JobDescMsg] Job update description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041PostJob(jobId: string, v0041JobDescMsg?: V0041JobDescMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041PostJob(jobId, v0041JobDescMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit new job allocation without any steps that must be signaled to stop
     * @param {V0041JobAllocReq} [v0041JobAllocReq] Job allocation description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041PostJobAllocate(v0041JobAllocReq?: V0041JobAllocReq, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041PostJobAllocate(v0041JobAllocReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit new job
     * @param {V0041JobSubmitReq} [v0041JobSubmitReq] Job description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041PostJobSubmit(v0041JobSubmitReq?: V0041JobSubmitReq, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041PostJobSubmit(v0041JobSubmitReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update node properties
     * @param {string} nodeName Node name
     * @param {V0041UpdateNodeMsg} [v0041UpdateNodeMsg] Node update description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmV0041PostNode(nodeName: string, v0041UpdateNodeMsg?: V0041UpdateNodeMsg, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmV0041PostNode(nodeName, v0041UpdateNodeMsg, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add clusters
     * @param {Dbv0039ClustersInfo} dbv0039ClustersInfo Add or update clusters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039AddClusters(dbv0039ClustersInfo: Dbv0039ClustersInfo, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039AddClusters(dbv0039ClustersInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add wckeys
     * @param {Dbv0039WckeyInfo} [dbv0039WckeyInfo] add wckeys
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039AddWckeys(dbv0039WckeyInfo?: Dbv0039WckeyInfo, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039AddWckeys(dbv0039WckeyInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account
     * @param {string} accountName Slurm Account Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteAccount(accountName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteAccount(accountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete association
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteAssociation(cluster, account, user, partition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete associations
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteAssociations(cluster, account, user, partition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete cluster
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteCluster(clusterName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteCluster(clusterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete QOS
     * @param {string} qosName Slurm QOS Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteQos(qosName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteQos(qosName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} userName Slurm User Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteUser(userName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteUser(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete wckey
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039DeleteWckey(wckey: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039DeleteWckey(wckey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039Diag(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039Diag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account info
     * @param {string} accountName Slurm Account Name
     * @param {SlurmdbV0039GetAccountWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetAccount(accountName: string, withDeleted?: SlurmdbV0039GetAccountWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetAccount(accountName, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account list
     * @param {SlurmdbV0039GetAccountsWithDeletedEnum} [withDeleted] Include deleted accounts. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetAccounts(withDeleted?: SlurmdbV0039GetAccountsWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetAccounts(withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association info
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetAssociation(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetAssociation(cluster, account, user, partition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association list
     * @param {string} [cluster] Cluster name
     * @param {string} [account] Account name
     * @param {string} [user] User name
     * @param {string} [partition] Partition Name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetAssociations(cluster?: string, account?: string, user?: string, partition?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetAssociations(cluster, account, user, partition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster info
     * @param {string} clusterName Slurm cluster name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetCluster(clusterName: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetCluster(clusterName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster list
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetClusters(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetClusters(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetConfig(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {string} jobId Slurm JobID
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetJob(jobId: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job list
     * @param {string} [users] Filter by comma delimited list of user names
     * @param {string} [submitTime] Filter by submission time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [startTime] Filter by start time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [endTime] Filter by end time  Accepted formats:  HH:MM[:SS] [AM|PM]  MMDD[YY] or MM/DD[/YY] or MM.DD[.YY]  MM/DD[/YY]-HH:MM[:SS]  YYYY-MM-DD[THH:MM[:SS]]
     * @param {string} [account] Comma delimited list of accounts to match
     * @param {string} [association] Comma delimited list of associations to match
     * @param {string} [cluster] Comma delimited list of cluster to match
     * @param {string} [constraints] Comma delimited list of constraints to match
     * @param {string} [cpusMax] Number of CPUs high range
     * @param {string} [cpusMin] Number of CPUs low range
     * @param {SlurmdbV0039GetJobsSkipStepsEnum} [skipSteps] Report job step information
     * @param {SlurmdbV0039GetJobsDisableWaitForResultEnum} [disableWaitForResult] Disable waiting for result from slurmdbd
     * @param {string} [exitCode] Exit code of job
     * @param {string} [format] Comma delimited list of formats to match
     * @param {string} [group] Comma delimited list of groups to match
     * @param {string} [jobName] Comma delimited list of job names to match
     * @param {string} [nodesMax] Number of nodes high range
     * @param {string} [nodesMin] Number of nodes low range
     * @param {string} [partition] Comma delimited list of partitions to match
     * @param {string} [qos] Comma delimited list of QOS to match
     * @param {string} [reason] Comma delimited list of job reasons to match
     * @param {string} [reservation] Comma delimited list of reservations to match
     * @param {string} [state] Comma delimited list of states to match
     * @param {string} [step] Comma delimited list of job steps to match
     * @param {string} [node] Comma delimited list of used nodes to match
     * @param {string} [wckey] Comma delimited list of wckeys to match
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetJobs(users?: string, submitTime?: string, startTime?: string, endTime?: string, account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, skipSteps?: SlurmdbV0039GetJobsSkipStepsEnum, disableWaitForResult?: SlurmdbV0039GetJobsDisableWaitForResultEnum, exitCode?: string, format?: string, group?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, state?: string, step?: string, node?: string, wckey?: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetJobs(users, submitTime, startTime, endTime, account, association, cluster, constraints, cpusMax, cpusMin, skipSteps, disableWaitForResult, exitCode, format, group, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, state, step, node, wckey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS list
     * @param {SlurmdbV0039GetQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetQos(withDeleted?: SlurmdbV0039GetQosWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetQos(withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS info
     * @param {string} qosName Slurm QOS Name
     * @param {SlurmdbV0039GetSingleQosWithDeletedEnum} [withDeleted] Include deleted QOSs. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetSingleQos(qosName: string, withDeleted?: SlurmdbV0039GetSingleQosWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetSingleQos(qosName, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetTres(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetTres(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {string} userName Slurm User Name
     * @param {SlurmdbV0039GetUserWithDeletedEnum} [withDeleted] Include deleted users. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetUser(userName: string, withDeleted?: SlurmdbV0039GetUserWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetUser(userName, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user list
     * @param {SlurmdbV0039GetUsersWithDeletedEnum} [withDeleted] Include deleted users. False by default.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetUsers(withDeleted?: SlurmdbV0039GetUsersWithDeletedEnum, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetUsers(withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey info
     * @param {string} wckey Slurm wckey name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetWckey(wckey: string, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetWckey(wckey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey list
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039GetWckeys(options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039GetWckeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load all configuration information
     * @param {Dbv0039SetConfig} [dbv0039SetConfig] Add or update config
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039SetConfig(dbv0039SetConfig?: Dbv0039SetConfig, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039SetConfig(dbv0039SetConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update accounts
     * @param {Dbv0039AccountInfo} dbv0039AccountInfo update/create accounts
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039UpdateAccounts(dbv0039AccountInfo: Dbv0039AccountInfo, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039UpdateAccounts(dbv0039AccountInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set associations info
     * @param {Dbv0039AssociationsInfo} dbv0039AssociationsInfo Add or update associations
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo: Dbv0039AssociationsInfo, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039UpdateAssociations(dbv0039AssociationsInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set QOS info
     * @param {Dbv0039UpdateQos} dbv0039UpdateQos Add or update QOSs
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039UpdateQos(dbv0039UpdateQos: Dbv0039UpdateQos, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039UpdateQos(dbv0039UpdateQos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set TRES info
     * @param {Dbv0039TresUpdate} dbv0039TresUpdate Add or Update TRES
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039UpdateTres(dbv0039TresUpdate: Dbv0039TresUpdate, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039UpdateTres(dbv0039TresUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {Dbv0039UpdateUsers} dbv0039UpdateUsers add or update user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlurmApi
     */
    public slurmdbV0039UpdateUsers(dbv0039UpdateUsers: Dbv0039UpdateUsers, options?: RawAxiosRequestConfig) {
        return SlurmApiFp(this.configuration).slurmdbV0039UpdateUsers(dbv0039UpdateUsers, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SlurmV0039CancelJobSignalEnum = {
    Hup: 'HUP',
    Int: 'INT',
    Quit: 'QUIT',
    Abrt: 'ABRT',
    Kill: 'KILL',
    Alrm: 'ALRM',
    Term: 'TERM',
    Usr1: 'USR1',
    Usr2: 'USR2',
    Urg: 'URG',
    Cont: 'CONT',
    Stop: 'STOP',
    Tstp: 'TSTP',
    Ttin: 'TTIN',
    Ttou: 'TTOU'
} as const;
export type SlurmV0039CancelJobSignalEnum = typeof SlurmV0039CancelJobSignalEnum[keyof typeof SlurmV0039CancelJobSignalEnum];
/**
 * @export
 */
export const SlurmV0040DeleteJobFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    NoCronJobs: 'NO_CRON_JOBS',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;
export type SlurmV0040DeleteJobFlagsEnum = typeof SlurmV0040DeleteJobFlagsEnum[keyof typeof SlurmV0040DeleteJobFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetJobFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetJobFlagsEnum = typeof SlurmV0040GetJobFlagsEnum[keyof typeof SlurmV0040GetJobFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetJobsFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetJobsFlagsEnum = typeof SlurmV0040GetJobsFlagsEnum[keyof typeof SlurmV0040GetJobsFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetJobsStateFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetJobsStateFlagsEnum = typeof SlurmV0040GetJobsStateFlagsEnum[keyof typeof SlurmV0040GetJobsStateFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetNodeFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetNodeFlagsEnum = typeof SlurmV0040GetNodeFlagsEnum[keyof typeof SlurmV0040GetNodeFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetNodesFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetNodesFlagsEnum = typeof SlurmV0040GetNodesFlagsEnum[keyof typeof SlurmV0040GetNodesFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetPartitionFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetPartitionFlagsEnum = typeof SlurmV0040GetPartitionFlagsEnum[keyof typeof SlurmV0040GetPartitionFlagsEnum];
/**
 * @export
 */
export const SlurmV0040GetPartitionsFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0040GetPartitionsFlagsEnum = typeof SlurmV0040GetPartitionsFlagsEnum[keyof typeof SlurmV0040GetPartitionsFlagsEnum];
/**
 * @export
 */
export const SlurmV0041DeleteJobFlagsEnum = {
    BatchJob: 'BATCH_JOB',
    ArrayTask: 'ARRAY_TASK',
    FullStepsOnly: 'FULL_STEPS_ONLY',
    FullJob: 'FULL_JOB',
    FederationRequeue: 'FEDERATION_REQUEUE',
    Hurry: 'HURRY',
    OutOfMemory: 'OUT_OF_MEMORY',
    NoSiblingJobs: 'NO_SIBLING_JOBS',
    ReservationJob: 'RESERVATION_JOB',
    Verbose: 'VERBOSE',
    CronJobs: 'CRON_JOBS',
    WarningSent: 'WARNING_SENT'
} as const;
export type SlurmV0041DeleteJobFlagsEnum = typeof SlurmV0041DeleteJobFlagsEnum[keyof typeof SlurmV0041DeleteJobFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetJobFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetJobFlagsEnum = typeof SlurmV0041GetJobFlagsEnum[keyof typeof SlurmV0041GetJobFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetJobsFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetJobsFlagsEnum = typeof SlurmV0041GetJobsFlagsEnum[keyof typeof SlurmV0041GetJobsFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetJobsStateFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetJobsStateFlagsEnum = typeof SlurmV0041GetJobsStateFlagsEnum[keyof typeof SlurmV0041GetJobsStateFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetNodeFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetNodeFlagsEnum = typeof SlurmV0041GetNodeFlagsEnum[keyof typeof SlurmV0041GetNodeFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetNodesFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetNodesFlagsEnum = typeof SlurmV0041GetNodesFlagsEnum[keyof typeof SlurmV0041GetNodesFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetPartitionFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetPartitionFlagsEnum = typeof SlurmV0041GetPartitionFlagsEnum[keyof typeof SlurmV0041GetPartitionFlagsEnum];
/**
 * @export
 */
export const SlurmV0041GetPartitionsFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmV0041GetPartitionsFlagsEnum = typeof SlurmV0041GetPartitionsFlagsEnum[keyof typeof SlurmV0041GetPartitionsFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0039GetAccountWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetAccountWithDeletedEnum = typeof SlurmdbV0039GetAccountWithDeletedEnum[keyof typeof SlurmdbV0039GetAccountWithDeletedEnum];
/**
 * @export
 */
export const SlurmdbV0039GetAccountsWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetAccountsWithDeletedEnum = typeof SlurmdbV0039GetAccountsWithDeletedEnum[keyof typeof SlurmdbV0039GetAccountsWithDeletedEnum];
/**
 * @export
 */
export const SlurmdbV0039GetJobsSkipStepsEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetJobsSkipStepsEnum = typeof SlurmdbV0039GetJobsSkipStepsEnum[keyof typeof SlurmdbV0039GetJobsSkipStepsEnum];
/**
 * @export
 */
export const SlurmdbV0039GetJobsDisableWaitForResultEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetJobsDisableWaitForResultEnum = typeof SlurmdbV0039GetJobsDisableWaitForResultEnum[keyof typeof SlurmdbV0039GetJobsDisableWaitForResultEnum];
/**
 * @export
 */
export const SlurmdbV0039GetQosWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetQosWithDeletedEnum = typeof SlurmdbV0039GetQosWithDeletedEnum[keyof typeof SlurmdbV0039GetQosWithDeletedEnum];
/**
 * @export
 */
export const SlurmdbV0039GetSingleQosWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetSingleQosWithDeletedEnum = typeof SlurmdbV0039GetSingleQosWithDeletedEnum[keyof typeof SlurmdbV0039GetSingleQosWithDeletedEnum];
/**
 * @export
 */
export const SlurmdbV0039GetUserWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetUserWithDeletedEnum = typeof SlurmdbV0039GetUserWithDeletedEnum[keyof typeof SlurmdbV0039GetUserWithDeletedEnum];
/**
 * @export
 */
export const SlurmdbV0039GetUsersWithDeletedEnum = {
    True: 'true',
    False: 'false'
} as const;
export type SlurmdbV0039GetUsersWithDeletedEnum = typeof SlurmdbV0039GetUsersWithDeletedEnum[keyof typeof SlurmdbV0039GetUsersWithDeletedEnum];


/**
 * SlurmdbApi - axios parameter creator
 * @export
 */
export const SlurmdbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAccount: async (accountName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0040DeleteAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.40/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAssociation: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAssociations: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteCluster: async (clusterName: string, classification?: SlurmdbV0040DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0040DeleteCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.40/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (classification !== undefined) {
                localVarQueryParameter['classification'] = classification;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (federation !== undefined) {
                localVarQueryParameter['federation'] = federation;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rpcVersion !== undefined) {
                localVarQueryParameter['rpc_version'] = rpcVersion;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteSingleQos: async (qos: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qos' is not null or undefined
            assertParamExists('slurmdbV0040DeleteSingleQos', 'qos', qos)
            const localVarPath = `/slurmdb/v0.0.40/qos/{qos}`
                .replace(`{${"qos"}}`, encodeURIComponent(String(qos)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteUser: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('slurmdbV0040DeleteUser', 'name', name)
            const localVarPath = `/slurmdb/v0.0.40/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteWckey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slurmdbV0040DeleteWckey', 'id', id)
            const localVarPath = `/slurmdb/v0.0.40/wckey/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAccount: async (accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0040GetAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.40/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAccounts: async (description?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAssociation: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAssociations: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetCluster: async (clusterName: string, classification?: SlurmdbV0040GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0040GetCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.40/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (classification !== undefined) {
                localVarQueryParameter['classification'] = classification;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (federation !== undefined) {
                localVarQueryParameter['federation'] = federation;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rpcVersion !== undefined) {
                localVarQueryParameter['rpc_version'] = rpcVersion;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetClusters: async (updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetDiag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/diag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetInstance: async (cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/instance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instance_id'] = instanceId;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (nodeList !== undefined) {
                localVarQueryParameter['node_list'] = nodeList;
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = timeEnd;
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = timeStart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetInstances: async (cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/instances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instance_id'] = instanceId;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (nodeList !== undefined) {
                localVarQueryParameter['node_list'] = nodeList;
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = timeEnd;
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = timeStart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmdbV0040GetJob', 'jobId', jobId)
            const localVarPath = `/slurmdb/v0.0.40/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [cpusMax] Maximum number of cpus
         * @param {string} [cpusMin] Minimum number of cpus
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [nodesMax] Maximum number of nodes
         * @param {string} [nodesMin] Minimum number of nodes
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [timelimitMax] Maximum timelimit (seconds)
         * @param {string} [timelimitMin] Minimum timelimit (seconds)
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [submitTime] Submit time (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetJobs: async (account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, timelimitMax?: string, timelimitMin?: string, endTime?: string, startTime?: string, submitTime?: string, node?: string, users?: string, wckey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (association !== undefined) {
                localVarQueryParameter['association'] = association;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (constraints !== undefined) {
                localVarQueryParameter['constraints'] = constraints;
            }

            if (cpusMax !== undefined) {
                localVarQueryParameter['cpus_max'] = cpusMax;
            }

            if (cpusMin !== undefined) {
                localVarQueryParameter['cpus_min'] = cpusMin;
            }

            if (schedulerUnset !== undefined) {
                localVarQueryParameter['scheduler_unset'] = schedulerUnset;
            }

            if (scheduledOnSubmit !== undefined) {
                localVarQueryParameter['scheduled_on_submit'] = scheduledOnSubmit;
            }

            if (scheduledByMain !== undefined) {
                localVarQueryParameter['scheduled_by_main'] = scheduledByMain;
            }

            if (scheduledByBackfill !== undefined) {
                localVarQueryParameter['scheduled_by_backfill'] = scheduledByBackfill;
            }

            if (jobStarted !== undefined) {
                localVarQueryParameter['job_started'] = jobStarted;
            }

            if (exitCode !== undefined) {
                localVarQueryParameter['exit_code'] = exitCode;
            }

            if (showDuplicates !== undefined) {
                localVarQueryParameter['show_duplicates'] = showDuplicates;
            }

            if (skipSteps !== undefined) {
                localVarQueryParameter['skip_steps'] = skipSteps;
            }

            if (disableTruncateUsageTime !== undefined) {
                localVarQueryParameter['disable_truncate_usage_time'] = disableTruncateUsageTime;
            }

            if (wholeHetjob !== undefined) {
                localVarQueryParameter['whole_hetjob'] = wholeHetjob;
            }

            if (disableWholeHetjob !== undefined) {
                localVarQueryParameter['disable_whole_hetjob'] = disableWholeHetjob;
            }

            if (disableWaitForResult !== undefined) {
                localVarQueryParameter['disable_wait_for_result'] = disableWaitForResult;
            }

            if (usageTimeAsSubmitTime !== undefined) {
                localVarQueryParameter['usage_time_as_submit_time'] = usageTimeAsSubmitTime;
            }

            if (showBatchScript !== undefined) {
                localVarQueryParameter['show_batch_script'] = showBatchScript;
            }

            if (showJobEnvironment !== undefined) {
                localVarQueryParameter['show_job_environment'] = showJobEnvironment;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (jobName !== undefined) {
                localVarQueryParameter['job_name'] = jobName;
            }

            if (nodesMax !== undefined) {
                localVarQueryParameter['nodes_max'] = nodesMax;
            }

            if (nodesMin !== undefined) {
                localVarQueryParameter['nodes_min'] = nodesMin;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (reservation !== undefined) {
                localVarQueryParameter['reservation'] = reservation;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (timelimitMax !== undefined) {
                localVarQueryParameter['timelimit_max'] = timelimitMax;
            }

            if (timelimitMin !== undefined) {
                localVarQueryParameter['timelimit_min'] = timelimitMin;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (submitTime !== undefined) {
                localVarQueryParameter['submit_time'] = submitTime;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (users !== undefined) {
                localVarQueryParameter['users'] = users;
            }

            if (wckey !== undefined) {
                localVarQueryParameter['wckey'] = wckey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetQos: async (description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040GetQosPreemptModeEnum, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/qos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (preemptMode !== undefined) {
                localVarQueryParameter['preempt_mode'] = preemptMode;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetSingleQos: async (qos: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qos' is not null or undefined
            assertParamExists('slurmdbV0040GetSingleQos', 'qos', qos)
            const localVarPath = `/slurmdb/v0.0.40/qos/{qos}`
                .replace(`{${"qos"}}`, encodeURIComponent(String(qos)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetTres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/tres/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetUser: async (name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('slurmdbV0040GetUser', 'name', name)
            const localVarPath = `/slurmdb/v0.0.40/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withWckeys !== undefined) {
                localVarQueryParameter['with_wckeys'] = withWckeys;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0040GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetUsers: async (adminLevel?: SlurmdbV0040GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (adminLevel !== undefined) {
                localVarQueryParameter['admin_level'] = adminLevel;
            }

            if (defaultAccount !== undefined) {
                localVarQueryParameter['default_account'] = defaultAccount;
            }

            if (defaultWckey !== undefined) {
                localVarQueryParameter['default_wckey'] = defaultWckey;
            }

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withWckeys !== undefined) {
                localVarQueryParameter['with_wckeys'] = withWckeys;
            }

            if (withoutDefaults !== undefined) {
                localVarQueryParameter['without_defaults'] = withoutDefaults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetWckey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slurmdbV0040GetWckey', 'id', id)
            const localVarPath = `/slurmdb/v0.0.40/wckey/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetWckeys: async (cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/wckeys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0040OpenapiAccountsResp} [v0040OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAccounts: async (v0040OpenapiAccountsResp?: V0040OpenapiAccountsResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiAccountsResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0040OpenapiAccountsAddCondResp} [v0040OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAccountsAssociation: async (v0040OpenapiAccountsAddCondResp?: V0040OpenapiAccountsAddCondResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/accounts_association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiAccountsAddCondResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0040OpenapiAssocsResp} [v0040OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAssociations: async (v0040OpenapiAssocsResp?: V0040OpenapiAssocsResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiAssocsResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0040OpenapiClustersResp} [v0040OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostClusters: async (updateTime?: string, v0040OpenapiClustersResp?: V0040OpenapiClustersResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiClustersResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0040OpenapiSlurmdbdConfigResp} [v0040OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostConfig: async (v0040OpenapiSlurmdbdConfigResp?: V0040OpenapiSlurmdbdConfigResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiSlurmdbdConfigResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0040OpenapiSlurmdbdQosResp} [v0040OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostQos: async (description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040PostQosPreemptModeEnum, withDeleted?: string, v0040OpenapiSlurmdbdQosResp?: V0040OpenapiSlurmdbdQosResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/qos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (preemptMode !== undefined) {
                localVarQueryParameter['preempt_mode'] = preemptMode;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiSlurmdbdQosResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0040OpenapiTresResp} [v0040OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostTres: async (v0040OpenapiTresResp?: V0040OpenapiTresResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/tres/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiTresResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update users
         * @param {V0040OpenapiUsersResp} [v0040OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostUsers: async (v0040OpenapiUsersResp?: V0040OpenapiUsersResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiUsersResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0040PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0040OpenapiUsersAddCondResp} [v0040OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostUsersAssociation: async (updateTime?: string, flags?: SlurmdbV0040PostUsersAssociationFlagsEnum, v0040OpenapiUsersAddCondResp?: V0040OpenapiUsersAddCondResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/users_association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiUsersAddCondResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0040OpenapiWckeyResp} [v0040OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostWckeys: async (cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0040OpenapiWckeyResp?: V0040OpenapiWckeyResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.40/wckeys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0040OpenapiWckeyResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAccount: async (accountName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0041DeleteAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.41/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAssociation: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAssociations: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteCluster: async (clusterName: string, classification?: SlurmdbV0041DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0041DeleteCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.41/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (classification !== undefined) {
                localVarQueryParameter['classification'] = classification;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (federation !== undefined) {
                localVarQueryParameter['federation'] = federation;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rpcVersion !== undefined) {
                localVarQueryParameter['rpc_version'] = rpcVersion;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteSingleQos: async (qos: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qos' is not null or undefined
            assertParamExists('slurmdbV0041DeleteSingleQos', 'qos', qos)
            const localVarPath = `/slurmdb/v0.0.41/qos/{qos}`
                .replace(`{${"qos"}}`, encodeURIComponent(String(qos)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteUser: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('slurmdbV0041DeleteUser', 'name', name)
            const localVarPath = `/slurmdb/v0.0.41/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteWckey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slurmdbV0041DeleteWckey', 'id', id)
            const localVarPath = `/slurmdb/v0.0.41/wckey/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAccount: async (accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountName' is not null or undefined
            assertParamExists('slurmdbV0041GetAccount', 'accountName', accountName)
            const localVarPath = `/slurmdb/v0.0.41/account/{account_name}`
                .replace(`{${"account_name"}}`, encodeURIComponent(String(accountName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [dELETED] include deleted associations
         * @param {string} [withAssociations] query includes associations
         * @param {string} [withCoordinators] query includes coordinators
         * @param {string} [noUsersAreCoords] remove users as coordinators
         * @param {string} [usersAreCoords] users are coordinators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAccounts: async (description?: string, dELETED?: string, withAssociations?: string, withCoordinators?: string, noUsersAreCoords?: string, usersAreCoords?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (dELETED !== undefined) {
                localVarQueryParameter['DELETED'] = dELETED;
            }

            if (withAssociations !== undefined) {
                localVarQueryParameter['WithAssociations'] = withAssociations;
            }

            if (withCoordinators !== undefined) {
                localVarQueryParameter['WithCoordinators'] = withCoordinators;
            }

            if (noUsersAreCoords !== undefined) {
                localVarQueryParameter['NoUsersAreCoords'] = noUsersAreCoords;
            }

            if (usersAreCoords !== undefined) {
                localVarQueryParameter['UsersAreCoords'] = usersAreCoords;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAssociation: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAssociations: async (account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (defaultQos !== undefined) {
                localVarQueryParameter['default_qos'] = defaultQos;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (parentAccount !== undefined) {
                localVarQueryParameter['parent_account'] = parentAccount;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withRawQos !== undefined) {
                localVarQueryParameter['with_raw_qos'] = withRawQos;
            }

            if (withSubAccts !== undefined) {
                localVarQueryParameter['with_sub_accts'] = withSubAccts;
            }

            if (withoutParentInfo !== undefined) {
                localVarQueryParameter['without_parent_info'] = withoutParentInfo;
            }

            if (withoutParentLimits !== undefined) {
                localVarQueryParameter['without_parent_limits'] = withoutParentLimits;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetCluster: async (clusterName: string, classification?: SlurmdbV0041GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterName' is not null or undefined
            assertParamExists('slurmdbV0041GetCluster', 'clusterName', clusterName)
            const localVarPath = `/slurmdb/v0.0.41/cluster/{cluster_name}`
                .replace(`{${"cluster_name"}}`, encodeURIComponent(String(clusterName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (classification !== undefined) {
                localVarQueryParameter['classification'] = classification;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (federation !== undefined) {
                localVarQueryParameter['federation'] = federation;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (rpcVersion !== undefined) {
                localVarQueryParameter['rpc_version'] = rpcVersion;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetClusters: async (updateTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetDiag: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/diag/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetInstance: async (cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/instance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instance_id'] = instanceId;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (nodeList !== undefined) {
                localVarQueryParameter['node_list'] = nodeList;
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = timeEnd;
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = timeStart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetInstances: async (cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/instances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (extra !== undefined) {
                localVarQueryParameter['extra'] = extra;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instance_id'] = instanceId;
            }

            if (instanceType !== undefined) {
                localVarQueryParameter['instance_type'] = instanceType;
            }

            if (nodeList !== undefined) {
                localVarQueryParameter['node_list'] = nodeList;
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = timeEnd;
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = timeStart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('slurmdbV0041GetJob', 'jobId', jobId)
            const localVarPath = `/slurmdb/v0.0.41/job/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetJobs: async (account?: string, association?: string, cluster?: string, constraints?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, endTime?: string, startTime?: string, node?: string, users?: string, wckey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (association !== undefined) {
                localVarQueryParameter['association'] = association;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (constraints !== undefined) {
                localVarQueryParameter['constraints'] = constraints;
            }

            if (schedulerUnset !== undefined) {
                localVarQueryParameter['scheduler_unset'] = schedulerUnset;
            }

            if (scheduledOnSubmit !== undefined) {
                localVarQueryParameter['scheduled_on_submit'] = scheduledOnSubmit;
            }

            if (scheduledByMain !== undefined) {
                localVarQueryParameter['scheduled_by_main'] = scheduledByMain;
            }

            if (scheduledByBackfill !== undefined) {
                localVarQueryParameter['scheduled_by_backfill'] = scheduledByBackfill;
            }

            if (jobStarted !== undefined) {
                localVarQueryParameter['job_started'] = jobStarted;
            }

            if (exitCode !== undefined) {
                localVarQueryParameter['exit_code'] = exitCode;
            }

            if (showDuplicates !== undefined) {
                localVarQueryParameter['show_duplicates'] = showDuplicates;
            }

            if (skipSteps !== undefined) {
                localVarQueryParameter['skip_steps'] = skipSteps;
            }

            if (disableTruncateUsageTime !== undefined) {
                localVarQueryParameter['disable_truncate_usage_time'] = disableTruncateUsageTime;
            }

            if (wholeHetjob !== undefined) {
                localVarQueryParameter['whole_hetjob'] = wholeHetjob;
            }

            if (disableWholeHetjob !== undefined) {
                localVarQueryParameter['disable_whole_hetjob'] = disableWholeHetjob;
            }

            if (disableWaitForResult !== undefined) {
                localVarQueryParameter['disable_wait_for_result'] = disableWaitForResult;
            }

            if (usageTimeAsSubmitTime !== undefined) {
                localVarQueryParameter['usage_time_as_submit_time'] = usageTimeAsSubmitTime;
            }

            if (showBatchScript !== undefined) {
                localVarQueryParameter['show_batch_script'] = showBatchScript;
            }

            if (showJobEnvironment !== undefined) {
                localVarQueryParameter['show_job_environment'] = showJobEnvironment;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (jobName !== undefined) {
                localVarQueryParameter['job_name'] = jobName;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (qos !== undefined) {
                localVarQueryParameter['qos'] = qos;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            if (reservation !== undefined) {
                localVarQueryParameter['reservation'] = reservation;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (step !== undefined) {
                localVarQueryParameter['step'] = step;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (users !== undefined) {
                localVarQueryParameter['users'] = users;
            }

            if (wckey !== undefined) {
                localVarQueryParameter['wckey'] = wckey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetQos: async (description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041GetQosPreemptModeEnum, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/qos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (preemptMode !== undefined) {
                localVarQueryParameter['preempt_mode'] = preemptMode;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetSingleQos: async (qos: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qos' is not null or undefined
            assertParamExists('slurmdbV0041GetSingleQos', 'qos', qos)
            const localVarPath = `/slurmdb/v0.0.41/qos/{qos}`
                .replace(`{${"qos"}}`, encodeURIComponent(String(qos)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetTres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/tres/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetUser: async (name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('slurmdbV0041GetUser', 'name', name)
            const localVarPath = `/slurmdb/v0.0.41/user/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withWckeys !== undefined) {
                localVarQueryParameter['with_wckeys'] = withWckeys;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0041GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetUsers: async (adminLevel?: SlurmdbV0041GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (adminLevel !== undefined) {
                localVarQueryParameter['admin_level'] = adminLevel;
            }

            if (defaultAccount !== undefined) {
                localVarQueryParameter['default_account'] = defaultAccount;
            }

            if (defaultWckey !== undefined) {
                localVarQueryParameter['default_wckey'] = defaultWckey;
            }

            if (withAssocs !== undefined) {
                localVarQueryParameter['with_assocs'] = withAssocs;
            }

            if (withCoords !== undefined) {
                localVarQueryParameter['with_coords'] = withCoords;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }

            if (withWckeys !== undefined) {
                localVarQueryParameter['with_wckeys'] = withWckeys;
            }

            if (withoutDefaults !== undefined) {
                localVarQueryParameter['without_defaults'] = withoutDefaults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetWckey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('slurmdbV0041GetWckey', 'id', id)
            const localVarPath = `/slurmdb/v0.0.41/wckey/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetWckeys: async (cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/wckeys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0041OpenapiAccountsResp} [v0041OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAccounts: async (v0041OpenapiAccountsResp?: V0041OpenapiAccountsResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/accounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiAccountsResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0041OpenapiAccountsAddCondResp} [v0041OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAccountsAssociation: async (v0041OpenapiAccountsAddCondResp?: V0041OpenapiAccountsAddCondResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/accounts_association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiAccountsAddCondResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0041OpenapiAssocsResp} [v0041OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAssociations: async (v0041OpenapiAssocsResp?: V0041OpenapiAssocsResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/associations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiAssocsResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0041OpenapiClustersResp} [v0041OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostClusters: async (updateTime?: string, v0041OpenapiClustersResp?: V0041OpenapiClustersResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiClustersResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0041OpenapiSlurmdbdConfigResp} [v0041OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostConfig: async (v0041OpenapiSlurmdbdConfigResp?: V0041OpenapiSlurmdbdConfigResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiSlurmdbdConfigResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0041OpenapiSlurmdbdQosResp} [v0041OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostQos: async (description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041PostQosPreemptModeEnum, withDeleted?: string, v0041OpenapiSlurmdbdQosResp?: V0041OpenapiSlurmdbdQosResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/qos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (preemptMode !== undefined) {
                localVarQueryParameter['preempt_mode'] = preemptMode;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiSlurmdbdQosResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0041OpenapiTresResp} [v0041OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostTres: async (v0041OpenapiTresResp?: V0041OpenapiTresResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/tres/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiTresResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update users
         * @param {V0041OpenapiUsersResp} [v0041OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostUsers: async (v0041OpenapiUsersResp?: V0041OpenapiUsersResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiUsersResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0041PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0041OpenapiUsersAddCondResp} [v0041OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostUsersAssociation: async (updateTime?: string, flags?: SlurmdbV0041PostUsersAssociationFlagsEnum, v0041OpenapiUsersAddCondResp?: V0041OpenapiUsersAddCondResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/users_association/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (updateTime !== undefined) {
                localVarQueryParameter['update_time'] = updateTime;
            }

            if (flags !== undefined) {
                localVarQueryParameter['flags'] = flags;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiUsersAddCondResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0041OpenapiWckeyResp} [v0041OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostWckeys: async (cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0041OpenapiWckeyResp?: V0041OpenapiWckeyResp, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/slurmdb/v0.0.41/wckeys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication user required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-NAME", configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "X-SLURM-USER-TOKEN", configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (onlyDefaults !== undefined) {
                localVarQueryParameter['only_defaults'] = onlyDefaults;
            }

            if (usageEnd !== undefined) {
                localVarQueryParameter['usage_end'] = usageEnd;
            }

            if (usageStart !== undefined) {
                localVarQueryParameter['usage_start'] = usageStart;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (withUsage !== undefined) {
                localVarQueryParameter['with_usage'] = withUsage;
            }

            if (withDeleted !== undefined) {
                localVarQueryParameter['with_deleted'] = withDeleted;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(v0041OpenapiWckeyResp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SlurmdbApi - functional programming interface
 * @export
 */
export const SlurmdbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SlurmdbApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAccountsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteAccount(accountName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAssocsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAssocsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteCluster(clusterName: string, classification?: SlurmdbV0040DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiClustersRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdQosRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteSingleQos(qos, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteSingleQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteUser(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteUser(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040DeleteWckey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiWckeyRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040DeleteWckey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040DeleteWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAccountsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetAccount(accountName, withAssocs, withCoords, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetAccounts(description?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAccountsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetAccounts(description, withAssocs, withCoords, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAssocsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAssocsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetCluster(clusterName: string, classification?: SlurmdbV0040GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiClustersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetClusters(updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiClustersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetClusters(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdConfigResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetDiag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdStatsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetDiag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetDiag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiInstancesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiInstancesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [cpusMax] Maximum number of cpus
         * @param {string} [cpusMin] Minimum number of cpus
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [nodesMax] Maximum number of nodes
         * @param {string} [nodesMin] Minimum number of nodes
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [timelimitMax] Maximum timelimit (seconds)
         * @param {string} [timelimitMin] Minimum timelimit (seconds)
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [submitTime] Submit time (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, timelimitMax?: string, timelimitMin?: string, endTime?: string, startTime?: string, submitTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetJobs(account, association, cluster, constraints, cpusMax, cpusMin, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, reservationId, state, step, timelimitMax, timelimitMin, endTime, startTime, submitTime, node, users, wckey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdQosResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetQos(description, id, format, name, preemptMode, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiSlurmdbdQosResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetSingleQos(qos, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetSingleQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetTres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiTresResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetTres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiUsersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0040GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetUsers(adminLevel?: SlurmdbV0040GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiUsersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetWckey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiWckeyResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetWckey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiWckeyResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040GetWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0040OpenapiAccountsResp} [v0040OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostAccounts(v0040OpenapiAccountsResp?: V0040OpenapiAccountsResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostAccounts(v0040OpenapiAccountsResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0040OpenapiAccountsAddCondResp} [v0040OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp?: V0040OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiAccountsAddCondRespStr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostAccountsAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0040OpenapiAssocsResp} [v0040OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostAssociations(v0040OpenapiAssocsResp?: V0040OpenapiAssocsResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostAssociations(v0040OpenapiAssocsResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0040OpenapiClustersResp} [v0040OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostClusters(updateTime?: string, v0040OpenapiClustersResp?: V0040OpenapiClustersResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostClusters(updateTime, v0040OpenapiClustersResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0040OpenapiSlurmdbdConfigResp} [v0040OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp?: V0040OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0040OpenapiSlurmdbdQosResp} [v0040OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040PostQosPreemptModeEnum, withDeleted?: string, v0040OpenapiSlurmdbdQosResp?: V0040OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostQos(description, id, format, name, preemptMode, withDeleted, v0040OpenapiSlurmdbdQosResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0040OpenapiTresResp} [v0040OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostTres(v0040OpenapiTresResp?: V0040OpenapiTresResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostTres(v0040OpenapiTresResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update users
         * @param {V0040OpenapiUsersResp} [v0040OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostUsers(v0040OpenapiUsersResp?: V0040OpenapiUsersResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostUsers(v0040OpenapiUsersResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0040PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0040OpenapiUsersAddCondResp} [v0040OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0040PostUsersAssociationFlagsEnum, v0040OpenapiUsersAddCondResp?: V0040OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiUsersAddCondRespStr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostUsersAssociation(updateTime, flags, v0040OpenapiUsersAddCondResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostUsersAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0040OpenapiWckeyResp} [v0040OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0040PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0040OpenapiWckeyResp?: V0040OpenapiWckeyResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0040OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0040PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0040OpenapiWckeyResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0040PostWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAccountsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteAccount(accountName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAssocsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAssocsRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteCluster(clusterName: string, classification?: SlurmdbV0041DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiClustersRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdQosRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteSingleQos(qos, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteSingleQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteUser(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteUser(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041DeleteWckey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiWckeyRemovedResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041DeleteWckey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041DeleteWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAccountsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetAccount(accountName, withAssocs, withCoords, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [dELETED] include deleted associations
         * @param {string} [withAssociations] query includes associations
         * @param {string} [withCoordinators] query includes coordinators
         * @param {string} [noUsersAreCoords] remove users as coordinators
         * @param {string} [usersAreCoords] users are coordinators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetAccounts(description?: string, dELETED?: string, withAssociations?: string, withCoordinators?: string, noUsersAreCoords?: string, usersAreCoords?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAccountsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetAccounts(description, dELETED, withAssociations, withCoordinators, noUsersAreCoords, usersAreCoords, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAssocsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAssocsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetCluster(clusterName: string, classification?: SlurmdbV0041GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiClustersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetCluster']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetClusters(updateTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiClustersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetClusters(updateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdConfigResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetDiag(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdStatsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetDiag(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetDiag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiInstancesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetInstance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiInstancesResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetInstances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, endTime?: string, startTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdJobsResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetJobs(account, association, cluster, constraints, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, partition, qos, reason, reservation, reservationId, state, step, endTime, startTime, node, users, wckey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdQosResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetQos(description, id, format, name, preemptMode, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiSlurmdbdQosResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetSingleQos(qos, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetSingleQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetTres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiTresResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetTres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiUsersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0041GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetUsers(adminLevel?: SlurmdbV0041GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiUsersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetWckey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiWckeyResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetWckey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetWckey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiWckeyResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041GetWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0041OpenapiAccountsResp} [v0041OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostAccounts(v0041OpenapiAccountsResp?: V0041OpenapiAccountsResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostAccounts(v0041OpenapiAccountsResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0041OpenapiAccountsAddCondResp} [v0041OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp?: V0041OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiAccountsAddCondRespStr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostAccountsAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0041OpenapiAssocsResp} [v0041OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostAssociations(v0041OpenapiAssocsResp?: V0041OpenapiAssocsResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostAssociations(v0041OpenapiAssocsResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostAssociations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0041OpenapiClustersResp} [v0041OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostClusters(updateTime?: string, v0041OpenapiClustersResp?: V0041OpenapiClustersResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostClusters(updateTime, v0041OpenapiClustersResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostClusters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0041OpenapiSlurmdbdConfigResp} [v0041OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp?: V0041OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0041OpenapiSlurmdbdQosResp} [v0041OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041PostQosPreemptModeEnum, withDeleted?: string, v0041OpenapiSlurmdbdQosResp?: V0041OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostQos(description, id, format, name, preemptMode, withDeleted, v0041OpenapiSlurmdbdQosResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostQos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0041OpenapiTresResp} [v0041OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostTres(v0041OpenapiTresResp?: V0041OpenapiTresResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostTres(v0041OpenapiTresResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostTres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update users
         * @param {V0041OpenapiUsersResp} [v0041OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostUsers(v0041OpenapiUsersResp?: V0041OpenapiUsersResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostUsers(v0041OpenapiUsersResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0041PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0041OpenapiUsersAddCondResp} [v0041OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0041PostUsersAssociationFlagsEnum, v0041OpenapiUsersAddCondResp?: V0041OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiUsersAddCondRespStr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostUsersAssociation(updateTime, flags, v0041OpenapiUsersAddCondResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostUsersAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0041OpenapiWckeyResp} [v0041OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slurmdbV0041PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0041OpenapiWckeyResp?: V0041OpenapiWckeyResp, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V0041OpenapiResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slurmdbV0041PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0041OpenapiWckeyResp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SlurmdbApi.slurmdbV0041PostWckeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SlurmdbApi - factory interface
 * @export
 */
export const SlurmdbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SlurmdbApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAccountsRemovedResp> {
            return localVarFp.slurmdbV0040DeleteAccount(accountName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAssocsRemovedResp> {
            return localVarFp.slurmdbV0040DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAssocsRemovedResp> {
            return localVarFp.slurmdbV0040DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteCluster(clusterName: string, classification?: SlurmdbV0040DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiClustersRemovedResp> {
            return localVarFp.slurmdbV0040DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdQosRemovedResp> {
            return localVarFp.slurmdbV0040DeleteSingleQos(qos, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteUser(name: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040DeleteUser(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040DeleteWckey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiWckeyRemovedResp> {
            return localVarFp.slurmdbV0040DeleteWckey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAccountsResp> {
            return localVarFp.slurmdbV0040GetAccount(accountName, withAssocs, withCoords, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAccounts(description?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAccountsResp> {
            return localVarFp.slurmdbV0040GetAccounts(description, withAssocs, withCoords, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAssocsResp> {
            return localVarFp.slurmdbV0040GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information also
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAssocsResp> {
            return localVarFp.slurmdbV0040GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0040GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0040GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetCluster(clusterName: string, classification?: SlurmdbV0040GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiClustersResp> {
            return localVarFp.slurmdbV0040GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetClusters(updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiClustersResp> {
            return localVarFp.slurmdbV0040GetClusters(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetConfig(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdConfigResp> {
            return localVarFp.slurmdbV0040GetConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetDiag(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdStatsResp> {
            return localVarFp.slurmdbV0040GetDiag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiInstancesResp> {
            return localVarFp.slurmdbV0040GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiInstancesResp> {
            return localVarFp.slurmdbV0040GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdJobsResp> {
            return localVarFp.slurmdbV0040GetJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [cpusMax] Maximum number of cpus
         * @param {string} [cpusMin] Minimum number of cpus
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [nodesMax] Maximum number of nodes
         * @param {string} [nodesMin] Minimum number of nodes
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [timelimitMax] Maximum timelimit (seconds)
         * @param {string} [timelimitMin] Minimum timelimit (seconds)
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [submitTime] Submit time (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, timelimitMax?: string, timelimitMin?: string, endTime?: string, startTime?: string, submitTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdJobsResp> {
            return localVarFp.slurmdbV0040GetJobs(account, association, cluster, constraints, cpusMax, cpusMin, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, reservationId, state, step, timelimitMax, timelimitMin, endTime, startTime, submitTime, node, users, wckey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdQosResp> {
            return localVarFp.slurmdbV0040GetQos(description, id, format, name, preemptMode, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiSlurmdbdQosResp> {
            return localVarFp.slurmdbV0040GetSingleQos(qos, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetTres(options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiTresResp> {
            return localVarFp.slurmdbV0040GetTres(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiUsersResp> {
            return localVarFp.slurmdbV0040GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0040GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetUsers(adminLevel?: SlurmdbV0040GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiUsersResp> {
            return localVarFp.slurmdbV0040GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetWckey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiWckeyResp> {
            return localVarFp.slurmdbV0040GetWckey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiWckeyResp> {
            return localVarFp.slurmdbV0040GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0040OpenapiAccountsResp} [v0040OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAccounts(v0040OpenapiAccountsResp?: V0040OpenapiAccountsResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostAccounts(v0040OpenapiAccountsResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0040OpenapiAccountsAddCondResp} [v0040OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp?: V0040OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiAccountsAddCondRespStr> {
            return localVarFp.slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0040OpenapiAssocsResp} [v0040OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostAssociations(v0040OpenapiAssocsResp?: V0040OpenapiAssocsResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostAssociations(v0040OpenapiAssocsResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0040OpenapiClustersResp} [v0040OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostClusters(updateTime?: string, v0040OpenapiClustersResp?: V0040OpenapiClustersResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostClusters(updateTime, v0040OpenapiClustersResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0040OpenapiSlurmdbdConfigResp} [v0040OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp?: V0040OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0040PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0040OpenapiSlurmdbdQosResp} [v0040OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040PostQosPreemptModeEnum, withDeleted?: string, v0040OpenapiSlurmdbdQosResp?: V0040OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostQos(description, id, format, name, preemptMode, withDeleted, v0040OpenapiSlurmdbdQosResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0040OpenapiTresResp} [v0040OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostTres(v0040OpenapiTresResp?: V0040OpenapiTresResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostTres(v0040OpenapiTresResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update users
         * @param {V0040OpenapiUsersResp} [v0040OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostUsers(v0040OpenapiUsersResp?: V0040OpenapiUsersResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostUsers(v0040OpenapiUsersResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0040PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0040OpenapiUsersAddCondResp} [v0040OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0040PostUsersAssociationFlagsEnum, v0040OpenapiUsersAddCondResp?: V0040OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiUsersAddCondRespStr> {
            return localVarFp.slurmdbV0040PostUsersAssociation(updateTime, flags, v0040OpenapiUsersAddCondResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0040OpenapiWckeyResp} [v0040OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0040PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0040OpenapiWckeyResp?: V0040OpenapiWckeyResp, options?: RawAxiosRequestConfig): AxiosPromise<V0040OpenapiResp> {
            return localVarFp.slurmdbV0040PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0040OpenapiWckeyResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountName Account name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAccount(accountName: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAccountsRemovedResp> {
            return localVarFp.slurmdbV0041DeleteAccount(accountName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete association
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAssocsRemovedResp> {
            return localVarFp.slurmdbV0041DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete associations
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAssocsRemovedResp> {
            return localVarFp.slurmdbV0041DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete cluster
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041DeleteClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041DeleteClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteCluster(clusterName: string, classification?: SlurmdbV0041DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiClustersRemovedResp> {
            return localVarFp.slurmdbV0041DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete QOS
         * @param {string} qos QOS name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdQosRemovedResp> {
            return localVarFp.slurmdbV0041DeleteSingleQos(qos, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {string} name User name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteUser(name: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041DeleteUser(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete wckey
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041DeleteWckey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiWckeyRemovedResp> {
            return localVarFp.slurmdbV0041DeleteWckey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account info
         * @param {string} accountName Account name
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withDeleted] Include deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAccountsResp> {
            return localVarFp.slurmdbV0041GetAccount(accountName, withAssocs, withCoords, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account list
         * @param {string} [description] CSV description list
         * @param {string} [dELETED] include deleted associations
         * @param {string} [withAssociations] query includes associations
         * @param {string} [withCoordinators] query includes coordinators
         * @param {string} [noUsersAreCoords] remove users as coordinators
         * @param {string} [usersAreCoords] users are coordinators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAccounts(description?: string, dELETED?: string, withAssociations?: string, withCoordinators?: string, noUsersAreCoords?: string, usersAreCoords?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAccountsResp> {
            return localVarFp.slurmdbV0041GetAccounts(description, dELETED, withAssociations, withCoordinators, noUsersAreCoords, usersAreCoords, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association info
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAssocsResp> {
            return localVarFp.slurmdbV0041GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get association list
         * @param {string} [account] CSV accounts list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [defaultQos] CSV QOS list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [onlyDefaults] Filter to only defaults
         * @param {string} [parentAccount] CSV names of parent account
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted associations
         * @param {string} [withRawQos] Include a raw qos or delta_qos
         * @param {string} [withSubAccts] Include sub acct information
         * @param {string} [withoutParentInfo] Exclude parent id/name
         * @param {string} [withoutParentLimits] Exclude limits from parents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAssocsResp> {
            return localVarFp.slurmdbV0041GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster info
         * @param {string} clusterName Cluster name
         * @param {SlurmdbV0041GetClusterClassificationEnum} [classification] Type of machine
         * @param {string} [cluster] CSV cluster list
         * @param {string} [federation] CSV federation list
         * @param {SlurmdbV0041GetClusterFlagsEnum} [flags] Query flags
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [rpcVersion] CSV RPC version list
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [withDeleted] Include deleted clusters
         * @param {string} [withUsage] Include usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetCluster(clusterName: string, classification?: SlurmdbV0041GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiClustersResp> {
            return localVarFp.slurmdbV0041GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetClusters(updateTime?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiClustersResp> {
            return localVarFp.slurmdbV0041GetClusters(updateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dump all configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetConfig(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdConfigResp> {
            return localVarFp.slurmdbV0041GetConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get slurmdb diagnostics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetDiag(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdStatsResp> {
            return localVarFp.slurmdbV0041GetDiag(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance info
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiInstancesResp> {
            return localVarFp.slurmdbV0041GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get instance list
         * @param {string} [cluster] CSV clusters list
         * @param {string} [extra] CSV extra list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [instanceId] CSV instance_id list
         * @param {string} [instanceType] CSV instance_type list
         * @param {string} [nodeList] Ranged node string
         * @param {string} [timeEnd] Time end (UNIX timestamp)
         * @param {string} [timeStart] Time start (UNIX timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiInstancesResp> {
            return localVarFp.slurmdbV0041GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
         * @summary Get job info
         * @param {string} jobId Job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdJobsResp> {
            return localVarFp.slurmdbV0041GetJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get job list
         * @param {string} [account] CSV account list
         * @param {string} [association] CSV association list
         * @param {string} [cluster] CSV cluster list
         * @param {string} [constraints] CSV constraint list
         * @param {string} [schedulerUnset] Schedule bits not set
         * @param {string} [scheduledOnSubmit] Job was started on submit
         * @param {string} [scheduledByMain] Job was started from main scheduler
         * @param {string} [scheduledByBackfill] Job was started from backfill
         * @param {string} [jobStarted] Job start RPC was received
         * @param {string} [exitCode] Job exit code (numeric)
         * @param {string} [showDuplicates] Include duplicate job entries
         * @param {string} [skipSteps] Exclude job step details
         * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
         * @param {string} [wholeHetjob] Include details on all hetjob components
         * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
         * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
         * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
         * @param {string} [showBatchScript] Include job script
         * @param {string} [showJobEnvironment] Include job environment
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [groups] CSV group list
         * @param {string} [jobName] CSV job name list
         * @param {string} [partition] CSV partition name list
         * @param {string} [qos] CSV QOS name list
         * @param {string} [reason] CSV reason list
         * @param {string} [reservation] CSV reservation name list
         * @param {string} [reservationId] CSV reservation ID list
         * @param {string} [state] CSV state list
         * @param {string} [step] CSV step id list
         * @param {string} [endTime] Usage end (UNIX timestamp)
         * @param {string} [startTime] Usage start (UNIX timestamp)
         * @param {string} [node] Ranged node string where jobs ran
         * @param {string} [users] CSV user name list
         * @param {string} [wckey] CSV wckey list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, endTime?: string, startTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdJobsResp> {
            return localVarFp.slurmdbV0041GetJobs(account, association, cluster, constraints, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, partition, qos, reason, reservation, reservationId, state, step, endTime, startTime, node, users, wckey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS list
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdQosResp> {
            return localVarFp.slurmdbV0041GetQos(description, id, format, name, preemptMode, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get QOS info
         * @param {string} qos QOS name
         * @param {string} [withDeleted] Query includes deleted QOS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiSlurmdbdQosResp> {
            return localVarFp.slurmdbV0041GetSingleQos(qos, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get TRES info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetTres(options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiTresResp> {
            return localVarFp.slurmdbV0041GetTres(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user info
         * @param {string} name User name
         * @param {string} [withDeleted] Include deleted users
         * @param {string} [withAssocs] Include associations
         * @param {string} [withCoords] Include coordinators
         * @param {string} [withWckeys] Include wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiUsersResp> {
            return localVarFp.slurmdbV0041GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user list
         * @param {SlurmdbV0041GetUsersAdminLevelEnum} [adminLevel] Administrator level
         * @param {string} [defaultAccount] CSV default account list
         * @param {string} [defaultWckey] CSV default wckey list
         * @param {string} [withAssocs] With associations
         * @param {string} [withCoords] With coordinators
         * @param {string} [withDeleted] With deleted
         * @param {string} [withWckeys] With wckeys
         * @param {string} [withoutDefaults] Exclude defaults
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetUsers(adminLevel?: SlurmdbV0041GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiUsersResp> {
            return localVarFp.slurmdbV0041GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey info
         * @param {string} id wckey id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetWckey(id: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiWckeyResp> {
            return localVarFp.slurmdbV0041GetWckey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get wckey list
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiWckeyResp> {
            return localVarFp.slurmdbV0041GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/update list of accounts
         * @param {V0041OpenapiAccountsResp} [v0041OpenapiAccountsResp] Description of accounts to update/create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAccounts(v0041OpenapiAccountsResp?: V0041OpenapiAccountsResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostAccounts(v0041OpenapiAccountsResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add accounts with conditional association
         * @param {V0041OpenapiAccountsAddCondResp} [v0041OpenapiAccountsAddCondResp] Add list of accounts with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp?: V0041OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiAccountsAddCondRespStr> {
            return localVarFp.slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set associations info
         * @param {V0041OpenapiAssocsResp} [v0041OpenapiAssocsResp] Job description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostAssociations(v0041OpenapiAssocsResp?: V0041OpenapiAssocsResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostAssociations(v0041OpenapiAssocsResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get cluster list
         * @param {string} [updateTime] Filter reservations since update timestamp
         * @param {V0041OpenapiClustersResp} [v0041OpenapiClustersResp] Cluster add or update descriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostClusters(updateTime?: string, v0041OpenapiClustersResp?: V0041OpenapiClustersResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostClusters(updateTime, v0041OpenapiClustersResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Load all configuration information
         * @param {V0041OpenapiSlurmdbdConfigResp} [v0041OpenapiSlurmdbdConfigResp] Add or update config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp?: V0041OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add or update QOSs
         * @param {string} [description] CSV description list
         * @param {string} [id] CSV QOS id list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [name] CSV QOS name list
         * @param {SlurmdbV0041PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
         * @param {string} [withDeleted] Include deleted QOS
         * @param {V0041OpenapiSlurmdbdQosResp} [v0041OpenapiSlurmdbdQosResp] Description of QOS to add or update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041PostQosPreemptModeEnum, withDeleted?: string, v0041OpenapiSlurmdbdQosResp?: V0041OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostQos(description, id, format, name, preemptMode, withDeleted, v0041OpenapiSlurmdbdQosResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add TRES
         * @param {V0041OpenapiTresResp} [v0041OpenapiTresResp] TRES descriptions. Only works in developer mode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostTres(v0041OpenapiTresResp?: V0041OpenapiTresResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostTres(v0041OpenapiTresResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update users
         * @param {V0041OpenapiUsersResp} [v0041OpenapiUsersResp] add or update user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostUsers(v0041OpenapiUsersResp?: V0041OpenapiUsersResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostUsers(v0041OpenapiUsersResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add users with conditional association
         * @param {string} [updateTime] Filter partitions since update timestamp
         * @param {SlurmdbV0041PostUsersAssociationFlagsEnum} [flags] Query flags
         * @param {V0041OpenapiUsersAddCondResp} [v0041OpenapiUsersAddCondResp] Create users with conditional association
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0041PostUsersAssociationFlagsEnum, v0041OpenapiUsersAddCondResp?: V0041OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiUsersAddCondRespStr> {
            return localVarFp.slurmdbV0041PostUsersAssociation(updateTime, flags, v0041OpenapiUsersAddCondResp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add or update wckeys
         * @param {string} [cluster] CSV cluster name list
         * @param {string} [format] Ignored; process JSON manually to control output format
         * @param {string} [id] CSV id list
         * @param {string} [name] CSV name list
         * @param {string} [onlyDefaults] Only query defaults
         * @param {string} [usageEnd] Usage end (UNIX timestamp)
         * @param {string} [usageStart] Usage start (UNIX timestamp)
         * @param {string} [user] CSV user list
         * @param {string} [withUsage] Include usage
         * @param {string} [withDeleted] Include deleted wckeys
         * @param {V0041OpenapiWckeyResp} [v0041OpenapiWckeyResp] wckeys description
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slurmdbV0041PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0041OpenapiWckeyResp?: V0041OpenapiWckeyResp, options?: RawAxiosRequestConfig): AxiosPromise<V0041OpenapiResp> {
            return localVarFp.slurmdbV0041PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0041OpenapiWckeyResp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlurmdbApi - object-oriented interface
 * @export
 * @class SlurmdbApi
 * @extends {BaseAPI}
 */
export class SlurmdbApi extends BaseAPI {
    /**
     * 
     * @summary Delete account
     * @param {string} accountName Account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteAccount(accountName: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteAccount(accountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete association
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information also
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete associations
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information also
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete cluster
     * @param {string} clusterName Cluster name
     * @param {SlurmdbV0040DeleteClusterClassificationEnum} [classification] Type of machine
     * @param {string} [cluster] CSV cluster list
     * @param {string} [federation] CSV federation list
     * @param {SlurmdbV0040DeleteClusterFlagsEnum} [flags] Query flags
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [rpcVersion] CSV RPC version list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [withDeleted] Include deleted clusters
     * @param {string} [withUsage] Include usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteCluster(clusterName: string, classification?: SlurmdbV0040DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete QOS
     * @param {string} qos QOS name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteSingleQos(qos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteUser(name: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteUser(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete wckey
     * @param {string} id wckey id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040DeleteWckey(id: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040DeleteWckey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account info
     * @param {string} accountName Account name
     * @param {string} [withAssocs] Include associations
     * @param {string} [withCoords] Include coordinators
     * @param {string} [withDeleted] Include deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetAccount(accountName, withAssocs, withCoords, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account list
     * @param {string} [description] CSV description list
     * @param {string} [withAssocs] Include associations
     * @param {string} [withCoords] Include coordinators
     * @param {string} [withDeleted] Include deleted accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetAccounts(description?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetAccounts(description, withAssocs, withCoords, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association info
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information also
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association list
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information also
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster info
     * @param {string} clusterName Cluster name
     * @param {SlurmdbV0040GetClusterClassificationEnum} [classification] Type of machine
     * @param {string} [cluster] CSV cluster list
     * @param {string} [federation] CSV federation list
     * @param {SlurmdbV0040GetClusterFlagsEnum} [flags] Query flags
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [rpcVersion] CSV RPC version list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [withDeleted] Include deleted clusters
     * @param {string} [withUsage] Include usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetCluster(clusterName: string, classification?: SlurmdbV0040GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0040GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster list
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetClusters(updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetClusters(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetConfig(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetDiag(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetDiag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance info
     * @param {string} [cluster] CSV clusters list
     * @param {string} [extra] CSV extra list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [instanceId] CSV instance_id list
     * @param {string} [instanceType] CSV instance_type list
     * @param {string} [nodeList] Ranged node string
     * @param {string} [timeEnd] Time end (UNIX timestamp)
     * @param {string} [timeStart] Time start (UNIX timestamp)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [extra] CSV extra list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [instanceId] CSV instance_id list
     * @param {string} [instanceType] CSV instance_type list
     * @param {string} [nodeList] Ranged node string
     * @param {string} [timeEnd] Time end (UNIX timestamp)
     * @param {string} [timeStart] Time start (UNIX timestamp)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {string} jobId Job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetJob(jobId: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job list
     * @param {string} [account] CSV account list
     * @param {string} [association] CSV association list
     * @param {string} [cluster] CSV cluster list
     * @param {string} [constraints] CSV constraint list
     * @param {string} [cpusMax] Maximum number of cpus
     * @param {string} [cpusMin] Minimum number of cpus
     * @param {string} [schedulerUnset] Schedule bits not set
     * @param {string} [scheduledOnSubmit] Job was started on submit
     * @param {string} [scheduledByMain] Job was started from main scheduler
     * @param {string} [scheduledByBackfill] Job was started from backfill
     * @param {string} [jobStarted] Job start RPC was received
     * @param {string} [exitCode] Job exit code (numeric)
     * @param {string} [showDuplicates] Include duplicate job entries
     * @param {string} [skipSteps] Exclude job step details
     * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
     * @param {string} [wholeHetjob] Include details on all hetjob components
     * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
     * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
     * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
     * @param {string} [showBatchScript] Include job script
     * @param {string} [showJobEnvironment] Include job environment
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [groups] CSV group list
     * @param {string} [jobName] CSV job name list
     * @param {string} [nodesMax] Maximum number of nodes
     * @param {string} [nodesMin] Minimum number of nodes
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS name list
     * @param {string} [reason] CSV reason list
     * @param {string} [reservation] CSV reservation name list
     * @param {string} [reservationId] CSV reservation ID list
     * @param {string} [state] CSV state list
     * @param {string} [step] CSV step id list
     * @param {string} [timelimitMax] Maximum timelimit (seconds)
     * @param {string} [timelimitMin] Minimum timelimit (seconds)
     * @param {string} [endTime] Usage end (UNIX timestamp)
     * @param {string} [startTime] Usage start (UNIX timestamp)
     * @param {string} [submitTime] Submit time (UNIX timestamp)
     * @param {string} [node] Ranged node string where jobs ran
     * @param {string} [users] CSV user name list
     * @param {string} [wckey] CSV wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, cpusMax?: string, cpusMin?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, nodesMax?: string, nodesMin?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, timelimitMax?: string, timelimitMin?: string, endTime?: string, startTime?: string, submitTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetJobs(account, association, cluster, constraints, cpusMax, cpusMin, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, nodesMax, nodesMin, partition, qos, reason, reservation, reservationId, state, step, timelimitMax, timelimitMin, endTime, startTime, submitTime, node, users, wckey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS list
     * @param {string} [description] CSV description list
     * @param {string} [id] CSV QOS id list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [name] CSV QOS name list
     * @param {SlurmdbV0040GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
     * @param {string} [withDeleted] Include deleted QOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetQos(description, id, format, name, preemptMode, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS info
     * @param {string} qos QOS name
     * @param {string} [withDeleted] Query includes deleted QOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetSingleQos(qos, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetTres(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetTres(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {string} name User name
     * @param {string} [withDeleted] Include deleted users
     * @param {string} [withAssocs] Include associations
     * @param {string} [withCoords] Include coordinators
     * @param {string} [withWckeys] Include wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user list
     * @param {SlurmdbV0040GetUsersAdminLevelEnum} [adminLevel] Administrator level
     * @param {string} [defaultAccount] CSV default account list
     * @param {string} [defaultWckey] CSV default wckey list
     * @param {string} [withAssocs] With associations
     * @param {string} [withCoords] With coordinators
     * @param {string} [withDeleted] With deleted
     * @param {string} [withWckeys] With wckeys
     * @param {string} [withoutDefaults] Exclude defaults
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetUsers(adminLevel?: SlurmdbV0040GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey info
     * @param {string} id wckey id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetWckey(id: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetWckey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey list
     * @param {string} [cluster] CSV cluster name list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [name] CSV name list
     * @param {string} [onlyDefaults] Only query defaults
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/update list of accounts
     * @param {V0040OpenapiAccountsResp} [v0040OpenapiAccountsResp] Description of accounts to update/create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostAccounts(v0040OpenapiAccountsResp?: V0040OpenapiAccountsResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostAccounts(v0040OpenapiAccountsResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add accounts with conditional association
     * @param {V0040OpenapiAccountsAddCondResp} [v0040OpenapiAccountsAddCondResp] Add list of accounts with conditional association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp?: V0040OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostAccountsAssociation(v0040OpenapiAccountsAddCondResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set associations info
     * @param {V0040OpenapiAssocsResp} [v0040OpenapiAssocsResp] Job description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostAssociations(v0040OpenapiAssocsResp?: V0040OpenapiAssocsResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostAssociations(v0040OpenapiAssocsResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster list
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {V0040OpenapiClustersResp} [v0040OpenapiClustersResp] Cluster add or update descriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostClusters(updateTime?: string, v0040OpenapiClustersResp?: V0040OpenapiClustersResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostClusters(updateTime, v0040OpenapiClustersResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load all configuration information
     * @param {V0040OpenapiSlurmdbdConfigResp} [v0040OpenapiSlurmdbdConfigResp] Add or update config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp?: V0040OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostConfig(v0040OpenapiSlurmdbdConfigResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add or update QOSs
     * @param {string} [description] CSV description list
     * @param {string} [id] CSV QOS id list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [name] CSV QOS name list
     * @param {SlurmdbV0040PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
     * @param {string} [withDeleted] Include deleted QOS
     * @param {V0040OpenapiSlurmdbdQosResp} [v0040OpenapiSlurmdbdQosResp] Description of QOS to add or update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0040PostQosPreemptModeEnum, withDeleted?: string, v0040OpenapiSlurmdbdQosResp?: V0040OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostQos(description, id, format, name, preemptMode, withDeleted, v0040OpenapiSlurmdbdQosResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add TRES
     * @param {V0040OpenapiTresResp} [v0040OpenapiTresResp] TRES descriptions. Only works in developer mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostTres(v0040OpenapiTresResp?: V0040OpenapiTresResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostTres(v0040OpenapiTresResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update users
     * @param {V0040OpenapiUsersResp} [v0040OpenapiUsersResp] add or update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostUsers(v0040OpenapiUsersResp?: V0040OpenapiUsersResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostUsers(v0040OpenapiUsersResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add users with conditional association
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmdbV0040PostUsersAssociationFlagsEnum} [flags] Query flags
     * @param {V0040OpenapiUsersAddCondResp} [v0040OpenapiUsersAddCondResp] Create users with conditional association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0040PostUsersAssociationFlagsEnum, v0040OpenapiUsersAddCondResp?: V0040OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostUsersAssociation(updateTime, flags, v0040OpenapiUsersAddCondResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add or update wckeys
     * @param {string} [cluster] CSV cluster name list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [name] CSV name list
     * @param {string} [onlyDefaults] Only query defaults
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted wckeys
     * @param {V0040OpenapiWckeyResp} [v0040OpenapiWckeyResp] wckeys description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0040PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0040OpenapiWckeyResp?: V0040OpenapiWckeyResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0040PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0040OpenapiWckeyResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account
     * @param {string} accountName Account name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteAccount(accountName: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteAccount(accountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete association
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete associations
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete cluster
     * @param {string} clusterName Cluster name
     * @param {SlurmdbV0041DeleteClusterClassificationEnum} [classification] Type of machine
     * @param {string} [cluster] CSV cluster list
     * @param {string} [federation] CSV federation list
     * @param {SlurmdbV0041DeleteClusterFlagsEnum} [flags] Query flags
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [rpcVersion] CSV RPC version list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [withDeleted] Include deleted clusters
     * @param {string} [withUsage] Include usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteCluster(clusterName: string, classification?: SlurmdbV0041DeleteClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041DeleteClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete QOS
     * @param {string} qos QOS name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteSingleQos(qos: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteSingleQos(qos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteUser(name: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteUser(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete wckey
     * @param {string} id wckey id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041DeleteWckey(id: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041DeleteWckey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account info
     * @param {string} accountName Account name
     * @param {string} [withAssocs] Include associations
     * @param {string} [withCoords] Include coordinators
     * @param {string} [withDeleted] Include deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetAccount(accountName: string, withAssocs?: string, withCoords?: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetAccount(accountName, withAssocs, withCoords, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account list
     * @param {string} [description] CSV description list
     * @param {string} [dELETED] include deleted associations
     * @param {string} [withAssociations] query includes associations
     * @param {string} [withCoordinators] query includes coordinators
     * @param {string} [noUsersAreCoords] remove users as coordinators
     * @param {string} [usersAreCoords] users are coordinators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetAccounts(description?: string, dELETED?: string, withAssociations?: string, withCoordinators?: string, noUsersAreCoords?: string, usersAreCoords?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetAccounts(description, dELETED, withAssociations, withCoordinators, noUsersAreCoords, usersAreCoords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association info
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetAssociation(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetAssociation(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get association list
     * @param {string} [account] CSV accounts list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [defaultQos] CSV QOS list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [onlyDefaults] Filter to only defaults
     * @param {string} [parentAccount] CSV names of parent account
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted associations
     * @param {string} [withRawQos] Include a raw qos or delta_qos
     * @param {string} [withSubAccts] Include sub acct information
     * @param {string} [withoutParentInfo] Exclude parent id/name
     * @param {string} [withoutParentLimits] Exclude limits from parents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetAssociations(account?: string, cluster?: string, defaultQos?: string, format?: string, id?: string, onlyDefaults?: string, parentAccount?: string, partition?: string, qos?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, withRawQos?: string, withSubAccts?: string, withoutParentInfo?: string, withoutParentLimits?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetAssociations(account, cluster, defaultQos, format, id, onlyDefaults, parentAccount, partition, qos, usageEnd, usageStart, user, withUsage, withDeleted, withRawQos, withSubAccts, withoutParentInfo, withoutParentLimits, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster info
     * @param {string} clusterName Cluster name
     * @param {SlurmdbV0041GetClusterClassificationEnum} [classification] Type of machine
     * @param {string} [cluster] CSV cluster list
     * @param {string} [federation] CSV federation list
     * @param {SlurmdbV0041GetClusterFlagsEnum} [flags] Query flags
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [rpcVersion] CSV RPC version list
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [withDeleted] Include deleted clusters
     * @param {string} [withUsage] Include usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetCluster(clusterName: string, classification?: SlurmdbV0041GetClusterClassificationEnum, cluster?: string, federation?: string, flags?: SlurmdbV0041GetClusterFlagsEnum, format?: string, rpcVersion?: string, usageEnd?: string, usageStart?: string, withDeleted?: string, withUsage?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetCluster(clusterName, classification, cluster, federation, flags, format, rpcVersion, usageEnd, usageStart, withDeleted, withUsage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster list
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetClusters(updateTime?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetClusters(updateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dump all configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetConfig(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get slurmdb diagnostics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetDiag(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetDiag(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance info
     * @param {string} [cluster] CSV clusters list
     * @param {string} [extra] CSV extra list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [instanceId] CSV instance_id list
     * @param {string} [instanceType] CSV instance_type list
     * @param {string} [nodeList] Ranged node string
     * @param {string} [timeEnd] Time end (UNIX timestamp)
     * @param {string} [timeStart] Time start (UNIX timestamp)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetInstance(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetInstance(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get instance list
     * @param {string} [cluster] CSV clusters list
     * @param {string} [extra] CSV extra list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [instanceId] CSV instance_id list
     * @param {string} [instanceType] CSV instance_type list
     * @param {string} [nodeList] Ranged node string
     * @param {string} [timeEnd] Time end (UNIX timestamp)
     * @param {string} [timeStart] Time start (UNIX timestamp)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetInstances(cluster?: string, extra?: string, format?: string, instanceId?: string, instanceType?: string, nodeList?: string, timeEnd?: string, timeStart?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetInstances(cluster, extra, format, instanceId, instanceType, nodeList, timeEnd, timeStart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.
     * @summary Get job info
     * @param {string} jobId Job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetJob(jobId: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get job list
     * @param {string} [account] CSV account list
     * @param {string} [association] CSV association list
     * @param {string} [cluster] CSV cluster list
     * @param {string} [constraints] CSV constraint list
     * @param {string} [schedulerUnset] Schedule bits not set
     * @param {string} [scheduledOnSubmit] Job was started on submit
     * @param {string} [scheduledByMain] Job was started from main scheduler
     * @param {string} [scheduledByBackfill] Job was started from backfill
     * @param {string} [jobStarted] Job start RPC was received
     * @param {string} [exitCode] Job exit code (numeric)
     * @param {string} [showDuplicates] Include duplicate job entries
     * @param {string} [skipSteps] Exclude job step details
     * @param {string} [disableTruncateUsageTime] Do not truncate the time to usage_start and usage_end
     * @param {string} [wholeHetjob] Include details on all hetjob components
     * @param {string} [disableWholeHetjob] Only show details on specified hetjob components
     * @param {string} [disableWaitForResult] Tell dbd not to wait for the result
     * @param {string} [usageTimeAsSubmitTime] Use usage_time as the submit_time of the job
     * @param {string} [showBatchScript] Include job script
     * @param {string} [showJobEnvironment] Include job environment
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [groups] CSV group list
     * @param {string} [jobName] CSV job name list
     * @param {string} [partition] CSV partition name list
     * @param {string} [qos] CSV QOS name list
     * @param {string} [reason] CSV reason list
     * @param {string} [reservation] CSV reservation name list
     * @param {string} [reservationId] CSV reservation ID list
     * @param {string} [state] CSV state list
     * @param {string} [step] CSV step id list
     * @param {string} [endTime] Usage end (UNIX timestamp)
     * @param {string} [startTime] Usage start (UNIX timestamp)
     * @param {string} [node] Ranged node string where jobs ran
     * @param {string} [users] CSV user name list
     * @param {string} [wckey] CSV wckey list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetJobs(account?: string, association?: string, cluster?: string, constraints?: string, schedulerUnset?: string, scheduledOnSubmit?: string, scheduledByMain?: string, scheduledByBackfill?: string, jobStarted?: string, exitCode?: string, showDuplicates?: string, skipSteps?: string, disableTruncateUsageTime?: string, wholeHetjob?: string, disableWholeHetjob?: string, disableWaitForResult?: string, usageTimeAsSubmitTime?: string, showBatchScript?: string, showJobEnvironment?: string, format?: string, groups?: string, jobName?: string, partition?: string, qos?: string, reason?: string, reservation?: string, reservationId?: string, state?: string, step?: string, endTime?: string, startTime?: string, node?: string, users?: string, wckey?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetJobs(account, association, cluster, constraints, schedulerUnset, scheduledOnSubmit, scheduledByMain, scheduledByBackfill, jobStarted, exitCode, showDuplicates, skipSteps, disableTruncateUsageTime, wholeHetjob, disableWholeHetjob, disableWaitForResult, usageTimeAsSubmitTime, showBatchScript, showJobEnvironment, format, groups, jobName, partition, qos, reason, reservation, reservationId, state, step, endTime, startTime, node, users, wckey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS list
     * @param {string} [description] CSV description list
     * @param {string} [id] CSV QOS id list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [name] CSV QOS name list
     * @param {SlurmdbV0041GetQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
     * @param {string} [withDeleted] Include deleted QOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041GetQosPreemptModeEnum, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetQos(description, id, format, name, preemptMode, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get QOS info
     * @param {string} qos QOS name
     * @param {string} [withDeleted] Query includes deleted QOS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetSingleQos(qos: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetSingleQos(qos, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get TRES info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetTres(options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetTres(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user info
     * @param {string} name User name
     * @param {string} [withDeleted] Include deleted users
     * @param {string} [withAssocs] Include associations
     * @param {string} [withCoords] Include coordinators
     * @param {string} [withWckeys] Include wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetUser(name: string, withDeleted?: string, withAssocs?: string, withCoords?: string, withWckeys?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetUser(name, withDeleted, withAssocs, withCoords, withWckeys, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user list
     * @param {SlurmdbV0041GetUsersAdminLevelEnum} [adminLevel] Administrator level
     * @param {string} [defaultAccount] CSV default account list
     * @param {string} [defaultWckey] CSV default wckey list
     * @param {string} [withAssocs] With associations
     * @param {string} [withCoords] With coordinators
     * @param {string} [withDeleted] With deleted
     * @param {string} [withWckeys] With wckeys
     * @param {string} [withoutDefaults] Exclude defaults
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetUsers(adminLevel?: SlurmdbV0041GetUsersAdminLevelEnum, defaultAccount?: string, defaultWckey?: string, withAssocs?: string, withCoords?: string, withDeleted?: string, withWckeys?: string, withoutDefaults?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetUsers(adminLevel, defaultAccount, defaultWckey, withAssocs, withCoords, withDeleted, withWckeys, withoutDefaults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey info
     * @param {string} id wckey id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetWckey(id: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetWckey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get wckey list
     * @param {string} [cluster] CSV cluster name list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [name] CSV name list
     * @param {string} [onlyDefaults] Only query defaults
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted wckeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041GetWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041GetWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/update list of accounts
     * @param {V0041OpenapiAccountsResp} [v0041OpenapiAccountsResp] Description of accounts to update/create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostAccounts(v0041OpenapiAccountsResp?: V0041OpenapiAccountsResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostAccounts(v0041OpenapiAccountsResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add accounts with conditional association
     * @param {V0041OpenapiAccountsAddCondResp} [v0041OpenapiAccountsAddCondResp] Add list of accounts with conditional association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp?: V0041OpenapiAccountsAddCondResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostAccountsAssociation(v0041OpenapiAccountsAddCondResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set associations info
     * @param {V0041OpenapiAssocsResp} [v0041OpenapiAssocsResp] Job description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostAssociations(v0041OpenapiAssocsResp?: V0041OpenapiAssocsResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostAssociations(v0041OpenapiAssocsResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get cluster list
     * @param {string} [updateTime] Filter reservations since update timestamp
     * @param {V0041OpenapiClustersResp} [v0041OpenapiClustersResp] Cluster add or update descriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostClusters(updateTime?: string, v0041OpenapiClustersResp?: V0041OpenapiClustersResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostClusters(updateTime, v0041OpenapiClustersResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Load all configuration information
     * @param {V0041OpenapiSlurmdbdConfigResp} [v0041OpenapiSlurmdbdConfigResp] Add or update config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp?: V0041OpenapiSlurmdbdConfigResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostConfig(v0041OpenapiSlurmdbdConfigResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add or update QOSs
     * @param {string} [description] CSV description list
     * @param {string} [id] CSV QOS id list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [name] CSV QOS name list
     * @param {SlurmdbV0041PostQosPreemptModeEnum} [preemptMode] PreemptMode used when jobs in this QOS are preempted
     * @param {string} [withDeleted] Include deleted QOS
     * @param {V0041OpenapiSlurmdbdQosResp} [v0041OpenapiSlurmdbdQosResp] Description of QOS to add or update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostQos(description?: string, id?: string, format?: string, name?: string, preemptMode?: SlurmdbV0041PostQosPreemptModeEnum, withDeleted?: string, v0041OpenapiSlurmdbdQosResp?: V0041OpenapiSlurmdbdQosResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostQos(description, id, format, name, preemptMode, withDeleted, v0041OpenapiSlurmdbdQosResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add TRES
     * @param {V0041OpenapiTresResp} [v0041OpenapiTresResp] TRES descriptions. Only works in developer mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostTres(v0041OpenapiTresResp?: V0041OpenapiTresResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostTres(v0041OpenapiTresResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update users
     * @param {V0041OpenapiUsersResp} [v0041OpenapiUsersResp] add or update user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostUsers(v0041OpenapiUsersResp?: V0041OpenapiUsersResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostUsers(v0041OpenapiUsersResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add users with conditional association
     * @param {string} [updateTime] Filter partitions since update timestamp
     * @param {SlurmdbV0041PostUsersAssociationFlagsEnum} [flags] Query flags
     * @param {V0041OpenapiUsersAddCondResp} [v0041OpenapiUsersAddCondResp] Create users with conditional association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostUsersAssociation(updateTime?: string, flags?: SlurmdbV0041PostUsersAssociationFlagsEnum, v0041OpenapiUsersAddCondResp?: V0041OpenapiUsersAddCondResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostUsersAssociation(updateTime, flags, v0041OpenapiUsersAddCondResp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add or update wckeys
     * @param {string} [cluster] CSV cluster name list
     * @param {string} [format] Ignored; process JSON manually to control output format
     * @param {string} [id] CSV id list
     * @param {string} [name] CSV name list
     * @param {string} [onlyDefaults] Only query defaults
     * @param {string} [usageEnd] Usage end (UNIX timestamp)
     * @param {string} [usageStart] Usage start (UNIX timestamp)
     * @param {string} [user] CSV user list
     * @param {string} [withUsage] Include usage
     * @param {string} [withDeleted] Include deleted wckeys
     * @param {V0041OpenapiWckeyResp} [v0041OpenapiWckeyResp] wckeys description
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlurmdbApi
     */
    public slurmdbV0041PostWckeys(cluster?: string, format?: string, id?: string, name?: string, onlyDefaults?: string, usageEnd?: string, usageStart?: string, user?: string, withUsage?: string, withDeleted?: string, v0041OpenapiWckeyResp?: V0041OpenapiWckeyResp, options?: RawAxiosRequestConfig) {
        return SlurmdbApiFp(this.configuration).slurmdbV0041PostWckeys(cluster, format, id, name, onlyDefaults, usageEnd, usageStart, user, withUsage, withDeleted, v0041OpenapiWckeyResp, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SlurmdbV0040DeleteClusterClassificationEnum = {
    Unclassified: 'UNCLASSIFIED',
    Capability: 'CAPABILITY',
    Capacity: 'CAPACITY',
    CapapacityBothCapabilityAndCapacity: 'CAPAPACITY (both CAPABILITY and CAPACITY)'
} as const;
export type SlurmdbV0040DeleteClusterClassificationEnum = typeof SlurmdbV0040DeleteClusterClassificationEnum[keyof typeof SlurmdbV0040DeleteClusterClassificationEnum];
/**
 * @export
 */
export const SlurmdbV0040DeleteClusterFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;
export type SlurmdbV0040DeleteClusterFlagsEnum = typeof SlurmdbV0040DeleteClusterFlagsEnum[keyof typeof SlurmdbV0040DeleteClusterFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0040GetClusterClassificationEnum = {
    Unclassified: 'UNCLASSIFIED',
    Capability: 'CAPABILITY',
    Capacity: 'CAPACITY',
    CapapacityBothCapabilityAndCapacity: 'CAPAPACITY (both CAPABILITY and CAPACITY)'
} as const;
export type SlurmdbV0040GetClusterClassificationEnum = typeof SlurmdbV0040GetClusterClassificationEnum[keyof typeof SlurmdbV0040GetClusterClassificationEnum];
/**
 * @export
 */
export const SlurmdbV0040GetClusterFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;
export type SlurmdbV0040GetClusterFlagsEnum = typeof SlurmdbV0040GetClusterFlagsEnum[keyof typeof SlurmdbV0040GetClusterFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0040GetQosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;
export type SlurmdbV0040GetQosPreemptModeEnum = typeof SlurmdbV0040GetQosPreemptModeEnum[keyof typeof SlurmdbV0040GetQosPreemptModeEnum];
/**
 * @export
 */
export const SlurmdbV0040GetUsersAdminLevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;
export type SlurmdbV0040GetUsersAdminLevelEnum = typeof SlurmdbV0040GetUsersAdminLevelEnum[keyof typeof SlurmdbV0040GetUsersAdminLevelEnum];
/**
 * @export
 */
export const SlurmdbV0040PostQosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;
export type SlurmdbV0040PostQosPreemptModeEnum = typeof SlurmdbV0040PostQosPreemptModeEnum[keyof typeof SlurmdbV0040PostQosPreemptModeEnum];
/**
 * @export
 */
export const SlurmdbV0040PostUsersAssociationFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmdbV0040PostUsersAssociationFlagsEnum = typeof SlurmdbV0040PostUsersAssociationFlagsEnum[keyof typeof SlurmdbV0040PostUsersAssociationFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0041DeleteClusterClassificationEnum = {
    Unclassified: 'UNCLASSIFIED',
    Capability: 'CAPABILITY',
    Capacity: 'CAPACITY',
    CapapacityBothCapabilityAndCapacity: 'CAPAPACITY (both CAPABILITY and CAPACITY)'
} as const;
export type SlurmdbV0041DeleteClusterClassificationEnum = typeof SlurmdbV0041DeleteClusterClassificationEnum[keyof typeof SlurmdbV0041DeleteClusterClassificationEnum];
/**
 * @export
 */
export const SlurmdbV0041DeleteClusterFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;
export type SlurmdbV0041DeleteClusterFlagsEnum = typeof SlurmdbV0041DeleteClusterFlagsEnum[keyof typeof SlurmdbV0041DeleteClusterFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0041GetClusterClassificationEnum = {
    Unclassified: 'UNCLASSIFIED',
    Capability: 'CAPABILITY',
    Capacity: 'CAPACITY',
    CapapacityBothCapabilityAndCapacity: 'CAPAPACITY (both CAPABILITY and CAPACITY)'
} as const;
export type SlurmdbV0041GetClusterClassificationEnum = typeof SlurmdbV0041GetClusterClassificationEnum[keyof typeof SlurmdbV0041GetClusterClassificationEnum];
/**
 * @export
 */
export const SlurmdbV0041GetClusterFlagsEnum = {
    Registering: 'REGISTERING',
    MultipleSlurmd: 'MULTIPLE_SLURMD',
    FrontEnd: 'FRONT_END',
    Federation: 'FEDERATION',
    External: 'EXTERNAL'
} as const;
export type SlurmdbV0041GetClusterFlagsEnum = typeof SlurmdbV0041GetClusterFlagsEnum[keyof typeof SlurmdbV0041GetClusterFlagsEnum];
/**
 * @export
 */
export const SlurmdbV0041GetQosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;
export type SlurmdbV0041GetQosPreemptModeEnum = typeof SlurmdbV0041GetQosPreemptModeEnum[keyof typeof SlurmdbV0041GetQosPreemptModeEnum];
/**
 * @export
 */
export const SlurmdbV0041GetUsersAdminLevelEnum = {
    NotSet: 'Not Set',
    None: 'None',
    Operator: 'Operator',
    Administrator: 'Administrator'
} as const;
export type SlurmdbV0041GetUsersAdminLevelEnum = typeof SlurmdbV0041GetUsersAdminLevelEnum[keyof typeof SlurmdbV0041GetUsersAdminLevelEnum];
/**
 * @export
 */
export const SlurmdbV0041PostQosPreemptModeEnum = {
    Disabled: 'DISABLED',
    Suspend: 'SUSPEND',
    Requeue: 'REQUEUE',
    Cancel: 'CANCEL',
    Gang: 'GANG'
} as const;
export type SlurmdbV0041PostQosPreemptModeEnum = typeof SlurmdbV0041PostQosPreemptModeEnum[keyof typeof SlurmdbV0041PostQosPreemptModeEnum];
/**
 * @export
 */
export const SlurmdbV0041PostUsersAssociationFlagsEnum = {
    All: 'ALL',
    Detail: 'DETAIL',
    Mixed: 'MIXED',
    Local: 'LOCAL',
    Sibling: 'SIBLING',
    Federation: 'FEDERATION',
    Future: 'FUTURE'
} as const;
export type SlurmdbV0041PostUsersAssociationFlagsEnum = typeof SlurmdbV0041PostUsersAssociationFlagsEnum[keyof typeof SlurmdbV0041PostUsersAssociationFlagsEnum];


